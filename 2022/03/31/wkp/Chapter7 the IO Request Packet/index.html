<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16.ico">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"erkeai.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="IRP介绍​    IRP的全名是I&#x2F;O Request Package，即输入输出请求包，它是Windows内核中的一种非常重要的数据结构。上层应用程序与底层驱动程序通信时，应用程序会发出I&#x2F;O请求，操作系统将相应的I&#x2F;O请求转换成相应的IRP，不同的IRP会根据类型被分派到不同的派遣函数中进行处理。 ​      IRP有两个基本的属性，即MajorFunction和MinorFunction">
<meta property="og:type" content="article">
<meta property="og:title" content="Chapter 7 the I&#x2F;O Request Packet">
<meta property="og:url" content="https://erkeai.github.io/2022/03/31/wkp/Chapter7%20the%20IO%20Request%20Packet/index.html">
<meta property="og:site_name" content="hazel&#39;blog">
<meta property="og:description" content="IRP介绍​    IRP的全名是I&#x2F;O Request Package，即输入输出请求包，它是Windows内核中的一种非常重要的数据结构。上层应用程序与底层驱动程序通信时，应用程序会发出I&#x2F;O请求，操作系统将相应的I&#x2F;O请求转换成相应的IRP，不同的IRP会根据类型被分派到不同的派遣函数中进行处理。 ​      IRP有两个基本的属性，即MajorFunction和MinorFunction">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220304144523080.png">
<meta property="og:image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220331104749931.png">
<meta property="og:image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220331155121884.png">
<meta property="og:image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220331155052079.png">
<meta property="og:image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220331160047247.png">
<meta property="og:image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220511194722486.png">
<meta property="article:published_time" content="2022-03-30T16:00:00.000Z">
<meta property="article:modified_time" content="2022-06-06T12:19:58.159Z">
<meta property="article:author" content="ZouFeIYu">
<meta property="article:tag" content="WDM">
<meta property="article:tag" content="IRP">
<meta property="article:tag" content="设备栈">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220304144523080.png">

<link rel="canonical" href="https://erkeai.github.io/2022/03/31/wkp/Chapter7%20the%20IO%20Request%20Packet/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Chapter 7 the I/O Request Packet | hazel'blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hazel'blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">116</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">108</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2022/03/31/wkp/Chapter7%20the%20IO%20Request%20Packet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Chapter 7 the I/O Request Packet
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-31 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-31T00:00:00+08:00">2022-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-06 20:19:58" itemprop="dateModified" datetime="2022-06-06T20:19:58+08:00">2022-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">驱动开发</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="IRP介绍"><a href="#IRP介绍" class="headerlink" title="IRP介绍"></a>IRP介绍</h3><p>​    IRP的全名是I/O Request Package，即输入输出请求包，它是Windows内核中的一种非常重要的数据结构。上层应用程序与底层驱动程序通信时，应用程序会发出I/O请求，操作系统将相应的I/O请求转换成相应的IRP，不同的IRP会根据类型被分派到不同的派遣函数中进行处理。</p>
<p>​      IRP有两个基本的属性，即<strong>MajorFunction</strong>和<strong>MinorFunction</strong>，分别记录IRP的主类型和子类型。操作系统根据MajorFunction决定将IRP分发到哪个派遣函数，然后派遣函数根据MinorFunction进行细分处理。没有设置派遣函数的IRP，默认与<strong>IopInvalidDeviceRequest</strong>函数关联。</p>
<p>​      首先一个IRP在被分配时，调用者必须指定要分配多少个<strong>IO_STACK_LOCATION</strong>，这些结构直接在内存中伴随着IRP，其数量是设备堆栈中设备对象的数量。驱动程序会创建一个个设备对象，并将这些设备对象叠成一个垂直结构，叫做设备栈。IRP会被操作系统发送到设备栈顶层，如果顶层的设备对象的派遣函数结束了IRP的请求，那么这次I/O请求结束，如果没有，那么操作系统将IRP转发到设备栈的下一层设备处理，直到找到能够结束这个IRP请求的派遣函数的设备。</p>
<p>​      因此，一个IRP请求可能被转发多次，为了记录IRP在每层设备中做的操作，IRP会有个<strong>IO_STACK_LOCATION</strong>数组<u>（数组中的每个堆栈单元都对应一个将处理该IRP的驱动程序，另外还有一个堆栈单元供IRP的创建者使用。堆栈单元中包含该IRP的类型代码和参数信息以及完成函数的地址）</u>，数组的元素个数应该大于IRP穿过的设备数目， 当一个驱动程序接收到一个IRP时，将会获得一个指向IRP结构的指针，对于本层设备对应的<strong>IO_STACK_LOCATION</strong>,可以通过<code>IoGetCurrentIrpStackLocation</code>函数得到。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220304144523080.png" alt="image-20220304144523080"></p>
<h3 id="WDM与NT驱动程序"><a href="#WDM与NT驱动程序" class="headerlink" title="WDM与NT驱动程序"></a>WDM与NT驱动程序</h3><p>​     NT命名设备对象的名称形式为<code>\Device\DeviceName</code>, WDM驱动并不直接命名设备对象，系统规定了一个统一的命名方案，以确保设备名称不会在驱动程序之间发生冲突。WDM驱动程序命名方案：</p>
<ul>
<li>设备的 PDO 被命名。总线驱动程序为其枚举的设备请求命名 PDO。总线驱动程序在创建设备对象时指定 FILE_AUTOGENERATED_DEVICE_NAME 设备特性。</li>
<li>FDO 和FiDO 未命名。创建设备对象时，函数和过滤器驱动程序不请求名称。</li>
</ul>
<p>共有三种 WDM 设备对象：</p>
<ol>
<li>物理设备对象 (PDO) – 表示总线上的设备到<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/bus-drivers">总线驱动程序</a>，该设备对象表示在该总线上的该插槽中有某个设备。</li>
<li>功能设备对象 (FDO) – 代表<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/function-drivers">功能驱动程序</a>的设备，通常由硬件的供应商提供。</li>
<li>过滤设备对象（FiDO）——代表<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/filter-drivers">过滤器驱动程序</a>的设备。</li>
</ol>
<p>​    驱动程序通过创建设备对象 (<strong>IoCreateDevice</strong>）并将其附加到设备堆栈 （<strong>IoAttachDeviceToDeviceStack</strong> ）将自己添加到处理设备 I/O 的驱动程序堆栈中。<strong>IoAttachDeviceToDeviceStack</strong>确定设备堆栈的当前顶部并将新设备对象附加到设备堆栈的顶部。</p>
<h3 id="设备节点和设备堆栈"><a href="#设备节点和设备堆栈" class="headerlink" title="设备节点和设备堆栈"></a>设备节点和设备堆栈</h3><p>​    大多数发送到设备驱动程序的请求都打包在IRP中。通常，当向设备发送 I/O 请求时，多个驱动程序会帮助处理该请求。这些驱动程序中的每一个都与一个设备对象相关联，并且这些设备对象被安排在一个堆栈中。设备对象及其相关驱动程序的序列称为设备堆栈。每个设备由一个设备节点表示，每个设备节点都有一个设备栈。</p>
<p>​     即插即用管理器将一个设备节点与每个新创建的 PDO 相关联，并查看注册表以确定哪些驱动程序需要成为该节点的设备堆栈的一部分。设备堆栈必须有一个（并且只有一个）<strong>功能驱动程序</strong>，并且可以选择有一个或多个<strong>过滤器驱动程序</strong>。</p>
<p>​     功能驱动程序是设备栈的主要驱动程序，负责处理读取、写入和设备控制请求。过滤器驱动程序在处理读取、写入和设备控制请求时起到辅助作用。在加载每个函数和过滤器驱动程序时，它会创建一个设备对象并将自己附加到设备堆栈。由功能驱动程序创建的设备对象称为<strong>功能设备对象</strong>（FDO），过滤驱动创建的设备对象称为<strong>过滤设备对象</strong>（Filter DO）。</p>
<p>​       PDO 始终是设备堆栈中的底部设备对象。这是由设备堆栈的构造方式造成的。首先创建 PDO，当附加设备对象附加到堆栈时，它们将附加到现有堆栈的顶部。</p>
<p>​      在某些情况下，设备除了其内核模式设备堆栈外，还具有用户模式设备堆栈。用户模式驱动程序通常基于用户模式驱动程序框架 (UMDF)，它是Windows 驱动程序框架提供的驱动程序模型之一。<strong>在 UMDF 中，驱动程序是用户模式的 DLL，设备对象是实现 IWDFDevice 接口的 COM 对象</strong>。UMDF 设备堆栈中的设备对象称为<strong>WDF 设备对象</strong>(WDF DO)。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220331104749931.png" alt="image-20220331104749931"></p>
<p><code>IO_STACK_LOCATION</code>结构如下</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220331155121884.png" alt="image-20220331155121884"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_STACK_LOCATION</span> &#123;</span></span><br><span class="line">    UCHAR  MajorFunction;</span><br><span class="line">    UCHAR  MinorFunction;</span><br><span class="line">    UCHAR  Flags;</span><br><span class="line">    UCHAR  Control;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                PIO_SECURITY_CONTEXT SecurityContext;</span><br><span class="line">                ULONG Options;</span><br><span class="line">                USHORT POINTER_ALIGNMENT FileAttributes;</span><br><span class="line">                USHORT ShareAccess;</span><br><span class="line">                ULONG POINTER_ALIGNMENT EaLength;</span><br><span class="line">            &#125; Create;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                ULONG Length;</span><br><span class="line">                ULONG POINTER_ALIGNMENT Key;</span><br><span class="line">                LARGE_INTEGER ByteOffset;</span><br><span class="line">            &#125; Read;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                ULONG Length;</span><br><span class="line">                ULONG POINTER_ALIGNMENT Key;</span><br><span class="line">                LARGE_INTEGER ByteOffset;</span><br><span class="line">            &#125; Write;</span><br><span class="line">            ... ...</span><br><span class="line">        &#125; Parameters;</span><br><span class="line">    PDEVICE_OBJECT  DeviceObject;</span><br><span class="line">    PFILE_OBJECT  FileObject;</span><br><span class="line">    PIO_COMPLETION_ROUTINE CompletionRoutine;</span><br><span class="line">    PVOID Context;</span><br><span class="line">&#125; IO_STACK_LOCATION, *PIO_STACK_LOCATION;</span><br><span class="line"></span><br><span class="line">kd&gt; dt nt!_IO_STACK_LOCATION</span><br><span class="line">   +<span class="number">0x000</span> MajorFunction    : UChar</span><br><span class="line">   +<span class="number">0x001</span> MinorFunction    : UChar</span><br><span class="line">   +<span class="number">0x002</span> Flags            : UChar</span><br><span class="line">   +<span class="number">0x003</span> Control          : UChar</span><br><span class="line">   +<span class="number">0x004</span> Parameters       : &lt;unnamed-tag&gt;</span><br><span class="line">   +<span class="number">0x014</span> DeviceObject     : Ptr32 _DEVICE_OBJECT</span><br><span class="line">   +<span class="number">0x018</span> FileObject       : Ptr32 _FILE_OBJECT</span><br><span class="line">   +<span class="number">0x01c</span> CompletionRoutine : Ptr32     <span class="keyword">long</span> </span><br><span class="line">   +<span class="number">0x020</span> Context          : Ptr32 Void</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个结构的主要成员意义为：</p>
<ul>
<li><strong>MajorFunction(UCHAR) <strong>： 是该IRP的主功能码。这个代码应该为类似</strong>IRP_MJ_READ</strong>一样的值，并与驱动程序对象中<strong>MajorFunction</strong>表的某个派遣函数指针相对应。如果该代码存在于某个特殊驱动程序的I/O堆栈单元中，它有可能一开始是，例如<strong>IRP_MJ_READ</strong>，而后被驱动程序转换成其它代码，并沿着驱动程序堆栈发送到低层驱动程序。</li>
<li><strong>MinorFunction(UCHAR)</strong> ： 是该IRP的副功能码。它进一步指出该IRP属于哪个主功能类。例如，<strong>IRP_MJ_PNP</strong>请求就有约一打的副功能码，如<strong>IRP_MN_START_DEVICE</strong>、<strong>IRP_MN_REMOVE_DEVICE</strong>。</li>
<li><strong>Parameters(union)</strong> ： 是几个子结构的联合，每个请求类型都有自己专用的参数，而每个子结构就是一种参数。这些子结构包括**Create(IRP_MJ_CREATE请求)、Read(IRP_MJ_READ请求)、StartDevice(IRP_MJ_PNP的IRP_MN_START_DEVICE子类型)**，等等。</li>
<li><strong>DeviceObject(PDEVICE_OBJECT)</strong> ：是与该堆栈单元对应的设备对象的地址。该域由<strong>IoCallDriver</strong>函数负责填写。</li>
<li><strong>FileObject(PFILE_OBJECT)</strong> ： 是内核文件对象的地址，IRP的目标就是这个文件对象。驱动程序通常在处理清除请求(<strong>IRP_MJ_CLEANUP</strong>)时使用FileObject指针，以区分队列中与该文件对象无关的IRP。</li>
<li><strong>CompletionRoutine(PIO_COMPLETION_ROUTINE) <strong>： 是一个I/O完成例程的地址，该地址是由与这个堆栈单元对应的驱动程序的更上一层驱动程序设置的。绝对不要直接设置这个域，应该调用</strong>IoSetCompletionRoutine</strong>函数，该函数知道如何参考下一层驱动程序的堆栈单元。设备堆栈的最低一级驱动程序并不需要完成例程，因为它们必须直接完成请求。然而，请求的发起者有时确实需要一个完成例程，但通常没有自己的堆栈单元。这就是为什么每一级驱动程序都使用下一级驱动程序的堆栈单元保存自己完成例程指针的原因。</li>
<li><strong>Context(PVOID)</strong> ： 是一个任意的与上下文相关的值，将作为参数传递给完成例程。</li>
</ul>
<h3 id="IRP操作流程"><a href="#IRP操作流程" class="headerlink" title="IRP操作流程"></a>IRP操作流程</h3><p>​      通常大多数IRP是由I/O管理器创建的，该管理器初始化IRP结构和第一个I/O堆栈位置，然后它将IRP的指针传递到最上层。驱动程序在其适当的调度例程中接收到IRP。例如，如果这是一个ReadIRP，那么该驱动程序将从其驱动程序对象中调用其其主函数数组的IRP_MJ_READ索引。此时，驱动程序在处理IRP时可以有几个选项：</p>
<p>​        1.将请求向下传递。如果这个驱动设备并不是设备节点的最后一个设备，当对该请求不感兴趣时，可以将其向下传递。这是由接收到不感兴趣的请求的过滤器驱动完成的，为了不损害设备的功能，驱动将该请求向下传递。需要调用<code>IoCallDriver</code>，<code>IoCallDriver</code>会调用<code>IoGetNextIrpStackLocation</code>下移设备栈的指针，因此我们需要对设备栈做如下之一的操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IoCopyCurrentIrpStackLocationToNext( Irp ) &#123; \</span></span><br><span class="line"><span class="meta">    PIO_STACK_LOCATION irpSp; \</span></span><br><span class="line"><span class="meta">    PIO_STACK_LOCATION nextIrpSp; \</span></span><br><span class="line"><span class="meta">    irpSp = IoGetCurrentIrpStackLocation( (Irp) ); \</span></span><br><span class="line"><span class="meta">    nextIrpSp = IoGetNextIrpStackLocation( (Irp) ); \</span></span><br><span class="line"><span class="meta">    RtlCopyMemory( nextIrpSp, irpSp, FIELD_OFFSET(IO_STACK_LOCATION, CompletionRoutine)); \</span></span><br><span class="line"><span class="meta">    nextIrpSp-&gt;Control = 0; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IoSkipCurrentIrpStackLocation( Irp ) \</span></span><br><span class="line"><span class="meta">    (Irp)-&gt;CurrentLocation++; \</span></span><br><span class="line"><span class="meta">    (Irp)-&gt;Tail.Overlay.CurrentStackLocation++;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​       <code>IoCopyCurrentIrpStackLocationToNext</code> 拷贝<code>IO_STACK_LOCATION</code> 成员到下一层。由于初始化的时候只初始化了第一个I/O堆栈位置，所以每个驱动需要初始化下一个驱动。</p>
<p>​     <code>IoSkipCurrentIrpStackLocation</code> 上移一层，下次使用的时候仍旧使用当前的<code>IO_STACK_LOCATION</code>。</p>
<p>​     2.完全处理这个请求。接收到这个请求的设备可以调用<code>IoCompleterequest</code>处理这个请求，这样更低层的设备不会看到这个请求。</p>
<p>​     3.结合1和2，驱动程序可以检查IRP，做一些事情（比如记录请求），然后传递它。或者它可以对下一个I/O堆栈位置进行一些更改，然后传递请求。</p>
<p>​     4.传递请求并在请求完成时由底层设备通知。任何一层（除了最低的一层）都可以通过在传递请求之前调用<code>IoSetCompletionRoutine</code>来设置I/O完成例程。当其中一个较低的层完成请求时，将会调用驱动程序的完成例程。</p>
<p>​      5.开始一些异步IRP处理。驱动程序可能想要处理该请求，但如果请求很长（典型的硬件驱动程序，但也可能是软件驱动程序），驱动可能通过调用<code>IoMarkIrpPending</code>标记IRP为挂起，并从它的调度例程返回一个<code>STATUS_PENDING</code>。最终，它将不得不完成IRP。</p>
<p>​    一旦一些层调用<code>IoCompleteRequest</code>，该IRP就会向反方向回到IRP的发起者（通常是在管理器），如果完成例程已经注册，它们将按注册的相反顺序被调用，即从下到上。</p>
<h3 id="IRP"><a href="#IRP" class="headerlink" title="IRP"></a>IRP</h3><p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220331155052079.png" alt="image-20220331155052079"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span> &#123;</span></span><br><span class="line">	PMDL              MdlAddress;</span><br><span class="line">	ULONG             Flags;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span>*   <span class="title">MasterIrp</span>;</span></span><br><span class="line">		PVOID          SystemBuffer;</span><br><span class="line">	&#125; AssociatedIrp;</span><br><span class="line">	IO_STATUS_BLOCK   IoStatus;</span><br><span class="line">	KPROCESSOR_MODE   RequestorMode;</span><br><span class="line">	BOOLEAN           PendingReturned;</span><br><span class="line">	BOOLEAN           Cancel;</span><br><span class="line">	KIRQL             CancelIrql;</span><br><span class="line">	PDRIVER_CANCEL    CancelRoutine;</span><br><span class="line">	PVOID             UserBuffer;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">				KDEVICE_QUEUE_ENTRY DeviceQueueEntry;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">					PVOID    DriverContext[<span class="number">4</span>];</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">			PETHREAD     Thread;</span><br><span class="line">			LIST_ENTRY   ListEntry;</span><br><span class="line">		&#125; Overlay;</span><br><span class="line">	&#125; Tail;</span><br><span class="line">&#125; IRP, *PIRP;</span><br><span class="line"></span><br><span class="line">kd&gt; dt nt!_IRP</span><br><span class="line">   +<span class="number">0x000</span> Type             : Int2B</span><br><span class="line">   +<span class="number">0x002</span> Size             : Uint2B</span><br><span class="line">   +<span class="number">0x004</span> MdlAddress       : Ptr32 _MDL</span><br><span class="line">   +<span class="number">0x008</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x00c</span> AssociatedIrp    : &lt;unnamed-tag&gt;</span><br><span class="line">   +<span class="number">0x010</span> ThreadListEntry  : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x018</span> IoStatus         : _IO_STATUS_BLOCK</span><br><span class="line">   +<span class="number">0x020</span> RequestorMode    : Char</span><br><span class="line">   +<span class="number">0x021</span> PendingReturned  : UChar</span><br><span class="line">   +<span class="number">0x022</span> StackCount       : Char</span><br><span class="line">   +<span class="number">0x023</span> CurrentLocation  : Char</span><br><span class="line">   +<span class="number">0x024</span> Cancel           : UChar</span><br><span class="line">   +<span class="number">0x025</span> CancelIrql       : UChar</span><br><span class="line">   +<span class="number">0x026</span> ApcEnvironment   : Char</span><br><span class="line">   +<span class="number">0x027</span> AllocationFlags  : UChar</span><br><span class="line">   +<span class="number">0x028</span> UserIosb         : Ptr32 _IO_STATUS_BLOCK</span><br><span class="line">   +<span class="number">0x02c</span> UserEvent        : Ptr32 _KEVENT</span><br><span class="line">   +<span class="number">0x030</span> Overlay          : &lt;unnamed-tag&gt;</span><br><span class="line">   +<span class="number">0x038</span> CancelRoutine    : Ptr32     <span class="keyword">void</span> </span><br><span class="line">   +<span class="number">0x03c</span> UserBuffer       : Ptr32 Void</span><br><span class="line">   +<span class="number">0x040</span> Tail             : &lt;unnamed-tag&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>MdlAddress</strong> : 是一个MDL的指针，当内核层和用户层采用共享内存的结构传递数据的时候，这个MDL就代表共享的内存信息（共享物理内存，通过MDL映射）。这个成员生效的标记为：DO_DIRECT_IO, METHOD_IN_DIRECT 或者METHOD_OUT_DIRECT.</li>
<li><strong>AssociatedIrp</strong> : 这个成员是个联合体，其中存在一个SystemBuffer程序；当内核层使用用户层的数据的时候是通过拷贝数据的方式来实现的话，那么拷贝后的数据就放在了AssociatedIrp.SystemBuffer中了。这个成员生效的标记是DO_BUFFERED_IO或者METHOD_BUFFERED。</li>
<li><strong>IoStatus</strong> ： 返回的状态信息。</li>
<li><strong>RequestorMode</strong> : UserMode或KernelMode，指定原始I/O请求的来源。驱动程序有时需要查看这个值来决定是否要信任某些参数。</li>
<li>**PendingReturned **: Pending 状态，如果为TRUE，则表明处理该IRP的最低级派遣函数返回了STATUS_PENDING。</li>
<li><strong>StackCount</strong> : 设备栈的数目。</li>
<li><strong>CurrentLocation</strong> : 当前处于哪个设备栈的索引。</li>
<li><strong>Cancel</strong> : IRP是否被取消，如果为TRUE，则表明IoCancelIrp已被调用(该函数用于取消这个请求)。如果为FALSE，则表明没有调用IoCancelIrp函数。</li>
<li>**CancelIrql(KIRQL) **: 是一个IRQL值，表明那个专用的取消自旋锁是在这个IRQL上获取的.</li>
<li>**CancelRoutine(PDRIVER_CANCEL) **: 是驱动程序取消例程的地址。你应该使用IoSetCancelRoutine函数设置这个域而不是直接修改该域(因为可以原子修改）。</li>
<li><strong>UserBuffer(PVOID)</strong> : 用户层参数的直接地址，设置标记METHOD_NEITHER时候有效。</li>
<li>**Tail.Overlay **是Tail联合中的一种联合结构，如下：<br><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220331160047247.png" alt="image-20220331160047247"></li>
</ul>
<h3 id="访问用户缓冲区"><a href="#访问用户缓冲区" class="headerlink" title="访问用户缓冲区"></a>访问用户缓冲区</h3><p>驱动程序创建设备对象的时候，需要考虑该设备以何种方式读写。读写主要有缓冲区方式读写、直接方式读写、其他方式读写。一些派遣函数，比如IRP_MJ_READ，IRP_MJ_WRITE，IRP_MJ_DEVICE_CONTROL接受客户端提供的缓冲区——在大多数情况下来自用户模式。通常，派遣函数是在IRQL0和请求线程上下文中调用，这意味着用户模式提供的缓冲区指针非常容易访问：IRQL是0，所以页面错误通常会被处理，线程是请求者，因此指针在这个进程上下文中是有效的。</p>
<p>以WriteFile为例，WriteFile要求用户提供一段缓冲区，并且说明缓冲区大小，然后将这段内存数据传入到驱动程序中，这段缓冲区内存是用户模式的内存地址，驱动程序如果直接引用这段内存很危险。因为操作系统是多任务的，他可能随时切换到别的进程。</p>
<h4 id="缓冲区方式读写"><a href="#缓冲区方式读写" class="headerlink" title="缓冲区方式读写"></a>缓冲区方式读写</h4><p>针对解决上述问题，缓冲区方式读写这种方法中，<strong>操作系统将应用程序提供的缓冲区的数据复制到内核模式下的地址中</strong>。IRP的派遣函数操作的是内核模式下的缓冲区而不是用户模式下的。这样的方法的缺点是，影响了运行效率，在少量内存操作时，可以采用这种方法。</p>
<p>1.I/O管理器会从非分页池中分配一个与用户模式下的缓冲区相同大小的缓冲区。并且Read/WriteFile创建的IRP的AssociatedIrp-&gt;SystemBuffer子域会记录这段内存地址。（可以通过IO_STACK_LOCATION中的Parameters.Read(or Write).Length知道请求了多少字节。）</p>
<p>2.I/O管理器会进行用户模式地址和内核模式地址的数据复制。</p>
<p>3.一旦驱动程序完成了IRP，I/O管理器（对于ReadFile请求）将系统缓冲区复制回用户的缓冲区(复制的大小由IoStatus.Information(记录了实际操作了多少字节)决定)</p>
<p>4.最后，I/O管理器释放内核缓冲区。</p>
<p><strong>特点：</strong>使用简单，只需在设备对象中指定标志，其他所有事情都由I/O管理器处理。总是有一个副本，所以它最好用于小的缓冲区（通常最多一页）。大型缓冲区的复制成本可能会很高。在这种情况下，应该使用直接I/O来代替。</p>
<h4 id="直接方式读写"><a href="#直接方式读写" class="headerlink" title="直接方式读写"></a>直接方式读写</h4><p>与前一种方式不同，该方式读写设备时，操作系统会将用户模式下的缓冲区锁住。然后操作系统将这段缓冲区在内核模式地址再映射一遍。这样，用户模式和内核模式的缓冲区指向的是同一区域的物理内存。无论操作系统如何切换进程，内核模式地址都保持不变。</p>
<p>锁定后，操作系统用<strong>内存描述符表（MDL）</strong>记录这段内存,该数据结构描述了缓冲区是如何映射到RAM的，该数据结构存储在IRP的pIrp-&gt;MdlAddress。</p>
<img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220511194722486.png" alt="image-20220511194722486" style="zoom:67%;" />

<p>从上图可知，这段虚拟内存首地址应该是mdl-&gt;StartVa+mdl-&gt;ByteOffset。</p>
<p>实现中主要用到MmGetSystemAddressForMdlSafe函数（该函数第二个参数是指定优先级），得到MDL在内核模式下的映射，返回值是内核地址。</p>
<p>如果返回NULL，这意味着系统超出系统页表或系统页表很低（取决于上面的优先级参数）。这种情况可能出现在内存很少的情况下，如果出现这种情况，那么IRP的完成状态应该是STATUS_INSUFFICIENT_RESOURCES。</p>
<h4 id="其他方式读写"><a href="#其他方式读写" class="headerlink" title="其他方式读写"></a>其他方式读写</h4><p>派遣函数直接读写应用程序提供的额缓冲区地址，只有把驱动程序和应用程序运行在相同线程上下文的情况下，才能使用这种方式。</p>
<p>缓冲区内存地址，可以在派遣函数中通过IRP的pIrp-&gt;UsersBuffer得到。因为ReadFile可能把空指针地址或者非法地址传递给驱动程序，所以驱动程序在使用用户模式地址前，需要探测这段内存是否可读或者可写（使用ProbeForWrite函数和try块）</p>
<h4 id="IO设备控制操作"><a href="#IO设备控制操作" class="headerlink" title="IO设备控制操作"></a>IO设备控制操作</h4><p>除了前面说的ReadFile，WriteFile之外，还可以通过另外一种方式操作设备。DeviceIoControl内部会使操作系统创建一个IRP_MJ_DEVICE_CONTROL类型的IRP，然后操作系统会将这个IRP转发到派遣函数。</p>
<h5 id="DeviceIoControl与驱动交互"><a href="#DeviceIoControl与驱动交互" class="headerlink" title="DeviceIoControl与驱动交互"></a>DeviceIoControl与驱动交互</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DeviceIoControl</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE hDevice, <span class="comment">// handle to device or file</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwIoControlCode, <span class="comment">// IOCTL code (控制码)</span></span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID lpInBuffer, <span class="comment">// input buffer</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD nInBufferSize, <span class="comment">// size of input buffer</span></span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID lpOutBuffer, <span class="comment">// output buffer</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD nOutBufferSize, <span class="comment">// size of output buffer</span></span></span></span><br><span class="line"><span class="params"><span class="function">    PDWORD lpdwBytesReturned, <span class="comment">// # of bytes actually returned</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPOVERLAPPED lpOverlapped)</span></span>;</span><br></pre></td></tr></table></figure>

<p>（IOCTL）控制码主要由四个参数构成，由CTL_CODE宏提供</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CTL_CODE( DeviceType, Function, Method, Access ) ( \</span></span><br><span class="line"><span class="meta">((DeviceType) &lt;&lt; 16) | ((Access) &lt;&lt; 14) | ((Function) &lt;&lt; 2) | (Method))</span></span><br></pre></td></tr></table></figure>

<p>第三个参数比较关键，指的是操作模式（METHOD_BUFFERED、METHOD_IN_DIRECT、METHOD_OUT_DIRECT、METHOD_NEITHER）,这几种操作模式与前面提到的缓冲区、直接和其他访问方式类似，对于METHOD_IN/OUT_DIRECT的区别是，当以只读权限打开设备的时候，前者会成功，后者会失败。如果以读写权限打开设备，两者都成功。</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiangbaohui/article/details/104910607">windows驱动之IRP结构</a>、<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/driver-stacks">微软官方文档</a></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>ZouFeIYu
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://erkeai.github.io/2022/03/31/wkp/Chapter7%20the%20IO%20Request%20Packet/" title="Chapter 7 the I&#x2F;O Request Packet">https://erkeai.github.io/2022/03/31/wkp/Chapter7 the IO Request Packet/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/WDM/" rel="tag"># WDM</a>
              <a href="/tags/IRP/" rel="tag"># IRP</a>
              <a href="/tags/%E8%AE%BE%E5%A4%87%E6%A0%88/" rel="tag"># 设备栈</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/29/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AC%AC%E5%8D%81%E4%B8%83%E5%A4%A9/" rel="prev" title="代码随想录第十七天">
      <i class="fa fa-chevron-left"></i> 代码随想录第十七天
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/31/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AC%AC%E5%8D%81%E5%85%AB%E5%A4%A9/" rel="next" title="代码随想录第十八天">
      代码随想录第十八天 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#IRP%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">IRP介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WDM%E4%B8%8ENT%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.</span> <span class="nav-text">WDM与NT驱动程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E8%8A%82%E7%82%B9%E5%92%8C%E8%AE%BE%E5%A4%87%E5%A0%86%E6%A0%88"><span class="nav-number">3.</span> <span class="nav-text">设备节点和设备堆栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IRP%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">IRP操作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IRP"><span class="nav-number">5.</span> <span class="nav-text">IRP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E7%94%A8%E6%88%B7%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">6.</span> <span class="nav-text">访问用户缓冲区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%96%B9%E5%BC%8F%E8%AF%BB%E5%86%99"><span class="nav-number">6.1.</span> <span class="nav-text">缓冲区方式读写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%96%B9%E5%BC%8F%E8%AF%BB%E5%86%99"><span class="nav-number">6.2.</span> <span class="nav-text">直接方式读写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%96%B9%E5%BC%8F%E8%AF%BB%E5%86%99"><span class="nav-number">6.3.</span> <span class="nav-text">其他方式读写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IO%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">6.4.</span> <span class="nav-text">IO设备控制操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#DeviceIoControl%E4%B8%8E%E9%A9%B1%E5%8A%A8%E4%BA%A4%E4%BA%92"><span class="nav-number">6.4.1.</span> <span class="nav-text">DeviceIoControl与驱动交互</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZouFeIYu"
      src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
  <p class="site-author-name" itemprop="name">ZouFeIYu</p>
  <div class="site-description" itemprop="description">reading, coding, travelling</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">108</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">116</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/erkeai" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;erkeai" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:563783592@qq.com" title="E-Mail → mailto:563783592@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-feather"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZouFeIYu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">274k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:09</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
