<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16.ico">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"erkeai.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="reading, coding, travelling">
<meta property="og:type" content="website">
<meta property="og:title" content="hazel&#39;blog">
<meta property="og:url" content="https://erkeai.github.io/page/2/index.html">
<meta property="og:site_name" content="hazel&#39;blog">
<meta property="og:description" content="reading, coding, travelling">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ZouFeIYu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://erkeai.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>hazel'blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hazel'blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">38</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">32</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2021/10/27/sample/A%20step-by-step%20analysis%20of%20the%20new%20malware%20used%20by%20APT28Sofacy%20called%20SkinnyBoy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/27/sample/A%20step-by-step%20analysis%20of%20the%20new%20malware%20used%20by%20APT28Sofacy%20called%20SkinnyBoy/" class="post-title-link" itemprop="url">A step-by-step analysis of the new malware used by APT28/Sofacy called SkinnyBoy</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-27 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-27T00:00:00+08:00">2021-10-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-22 14:51:11" itemprop="dateModified" datetime="2021-12-22T14:51:11+08:00">2021-12-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">样本分析</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇文章主要分析一个dll，该恶意软件与APT28有关。</p>
<p>先拖进IDA,f5反汇编后如下图，第一次见这么简单的dll</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF69E.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF69E.tmp.jpg</a>) </p>
<p>我们查看导出有DllEntryPoint和RunMod，因为我们的IDA静态无法分析dll,所以用rundll32.exe通过调用RunMod函数启动dll</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF69F.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF69F.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A0.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A0.tmp.jpg</a>) </p>
<p>因为这样的动态调试还不会，所以先搁置一下，先用静态查看一下RunMod函数做了什么（Update already）</p>
<h2 id="IDA静态调试"><a href="#IDA静态调试" class="headerlink" title="IDA静态调试"></a>IDA静态调试</h2><p>IDA查看该函数发现，主要功能就是创建两个线程函数</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A1.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A1.tmp.jpg</a>) </p>
<p>先看线程函数下方的sub_10001CF0()函数，这个函数主要的函数是GetMessage，观察函数上下文应该是从线程队列中检索消息,如果线程消息等于22（WM _ ENDSESSION 消息通知应用程序会话是否正在结束），会中断循环。</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A2.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A2.tmp.jpg</a>) </p>
<h3 id="Thread1-StartAddress"><a href="#Thread1-StartAddress" class="headerlink" title="Thread1 StartAddress"></a>Thread1 StartAddress</h3><p>先看第一个thread，一开始的sub_100010C0函数有两条命令行指令systeminfo和tasklist，进去详细查看发现先createpipe创建了个管道<strong>（匿名），</strong>启动cmd执行命令。systeminfo输出用ReadFile函数读出，tasklist同样</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A3.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A3.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A4.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A4.tmp.jpg</a>) </p>
<p>紧接着查看下面的函数sub_100013B0，初步猜测影噶是检索各个文件目录作为目标对象，结合OD看一下是哪些目录</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A5.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A5.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A6.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A6.tmp.jpg</a>) </p>
<p>目录获取完成后，我们继续看下面的函数sub_100016C0就是一些关于堆空间的的分配，猜测是为下面的函数申请空间</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A7.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A7.tmp.jpg</a>) </p>
<p>从Sub_10002900进去看到的函数分析这部分应该是网络连接操作</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A8.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A8.tmp.jpg</a>) </p>
<p>InternetOpenW API 初始化 WinINet 函数的使用（用户代理被硬编码为“Opera”），使用 InternetSetOptionW 例程(0x6 = INTERNET_OPTION_CONTROL_RECEIVE_TIMEOUT and 0x5 = INTERNET_OPTION_CONTROL_SEND_TIMEOUT)将发送和接收超时设置为 600 秒，InternetConnection用443端口与服务器updaterweb.com建立连接</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6B9.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6B9.tmp.jpg</a>) </p>
<p>Base64加密完数据后就要开始发送了，主要关注下面这个函数，HttpOpenRequestW 例程用于创建 HTTP POST 请求句柄，恶意软件在 HTTP 请求句柄中添加了一个 HTTP 请求标头（“application/x-www-form-urlencoded”），使用 HttpSendRequestExW API 将请求发送到 HTTP 服务器，如下图所示，看到网上的分析443端口连接失败的情况下，会尝试80端口，但是在动静态分析的时候并没有看到。</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6BA.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6BA.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6BB.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6BB.tmp.jpg</a>) </p>
<p>最后线程会将之前创建的事件置为信号状态</p>
<h3 id="Thread2-sub-6BD71960"><a href="#Thread2-sub-6BD71960" class="headerlink" title="Thread2 sub_6BD71960"></a>Thread2 sub_6BD71960</h3><p>线程一开始就将事件之谓无信号状态![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6BC.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6BC.tmp.jpg</a>)</p>
<p>有一个类似的工作流程，从调用 InternetOpenW 函数开始，直到连接到端口 443（或端口 80，如果第一个不成功）上的 C2 服务器。这次的 POST 请求不同，因为它包含用于下载 DLL 文件的“cmd=y”命令：</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6BD.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6BD.tmp.jpg</a>) </p>
<p>恶意软件使用 InternetQueryDataAvailable 例程查询服务器以确定可用数据量，函数sub_10001FD0中有InternetReadFile函数读取dll文件，下前 4 个字节表示数据大小，还有 32 个字节表示内容的 SHA256 哈希值，图中还有一个CryptStringToBinaryA 函数，对base64编码后的文件进行解码(下图是网上分析)</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6BE.tmp.png">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6BE.tmp.png</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6BF.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6BF.tmp.jpg</a>) </p>
<p>CryptAcquireContextA 用于获取 Microsoft RSA 和 AES 加密提供程序 (0x18 = PROV_RSA_AES) 的句柄，CryptCreateHash 例程用于创建 CSP（加密服务提供程序）哈希对象 (0x800c = CALG_SHA_256) 的句柄，在 base64 编码的 DLL 文件被解码后，恶意软件会使用 SHA256 算法哈希应该包含 DLL 文件的缓冲区（CryptHashData）,通过调用CryptGetHashParam API提取哈希值，（0x2 = HP_HASHVAL）,恶意进程验证上面计算出的哈希值是否与 DLL 文件附带的 32 字节缓冲区重合![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C0.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C0.tmp.jpg</a>)</p>
<p>恶意进程会在%TEMP%目录下创建一个名为fvjoik.dll的文件，新创建的文件填充从 C2 服务器下载的潜在 DLL，使用 LoadLibraryW 例程将 DLL 文件加载到当前进程的地址空间中，恶意软件将使用序号 1 执行导出的函数</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C1.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C1.tmp.jpg</a>) </p>
<p>函数完成后，sub_10001000()函数中可以看到采用WinExec函数命令行执行cmd删除dll文件</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C2.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C2.tmp.jpg</a>) </p>
<p>最后还与C2服务器进行了通信，应该是传输了DLL执行的结果</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C3.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C3.tmp.jpg</a>) </p>
<h2 id="OD动态调试"><a href="#OD动态调试" class="headerlink" title="OD动态调试"></a>OD动态调试</h2><p>具体步骤参考博客：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/feiyucq/archive/2010/06/07/1753465.html">https://www.cnblogs.com/feiyucq/archive/2010/06/07/1753465.html</a></p>
<p>拖进去一开始，如果F8或者F7的话进的是DLL的主函数，如果不想跟这些主函数的话可以直接F9，然后OD会再停下来，在最下方的消息栏会提示DLL初始化完成。</p>
<p>如下图的操作点击，然后选择导出函数，在导出函数的地址下个断点就可以直接调试了，点击调用按钮程序就断在这里了</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C4.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C4.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C5.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C5.tmp.jpg</a>) </p>
<p>结合静态分析，查找下图的字符串定位函数位置</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C6.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C6.tmp.jpg</a>) </p>
<p>调试f7进SHGetFolderPathW函数，可以看到该函数想获取的是桌面文件夹路径</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C7.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C7.tmp.jpg</a>) </p>
<p>由静态分析的图可以看出后一个函数PathAddBackslashW是在路径后加反斜杠，通过findfirstfile和findNextfile枚举桌面所有文件,并在文件夹名称前后添加了18个“#”字符然后再与提取的文件和目录列表和前面的字符串连接起来</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C8.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C8.tmp.jpg</a>) </p>
<p>以下目录也是后门的目标“C:\Program Files”, “C:\Program Files (x86)”, “C:\Users&lt; User &gt;\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Administrative Tools”, “C:\Users&lt; User &gt;\AppData\Roaming”, “C:\Users&lt; User &gt;\AppData\Roaming\Microsoft\Windows\Templates”, “C:\WINDOWS” and “C:\Users&lt; User &gt;\AppData\Local\Temp”</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6D9.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6D9.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6DA.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6DA.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6DB.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6DB.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6DC.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6DC.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6DD.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6DD.tmp.jpg</a>) </p>
<p>使用 GetComputerNameA API 检索本地计算机的 NetBIOS 名称；GetUserNameA 用于提取与当前线程关联的用户名；恶意软件通过调用 GetVolumeInformationW 的函数提取当前目录根目录的卷序列号；systeminfo 命令的输出加 tasklist 命令的输出加目标目录列表及其内容使用 CryptBinaryToStringA API (0x1 = CRYPT_STRING_BASE64) 进行 base-64 编码（IDA）</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6DE.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6DE.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6DF.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6DF.tmp.jpg</a>) </p>
<p>（上面这张图应该是第二个线程的，因为命令中包含cmd=y，该命令用于下载dll文件，因为两个线程在网络连接那一块是类似的，所以通过查找字符串定位函数位置的时候找错了）</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6E0.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6E0.tmp.jpg</a>) </p>
<h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><p>主线程完成最后的收尾工作，将之前创建的事件设置为信号状态，使用GetExitCodeThread API获取两个线程的终止状态：</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6E1.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6E1.tmp.jpg</a>) </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2021/10/25/reverse/overlong/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/25/reverse/overlong/" class="post-title-link" itemprop="url">buuctf_overlong</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-25 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-25T00:00:00+08:00">2021-10-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-22 10:26:43" itemprop="dateModified" datetime="2021-12-22T10:26:43+08:00">2021-12-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/buuctf/" itemprop="url" rel="index"><span itemprop="name">buuctf</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>339</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="overlong"><a href="#overlong" class="headerlink" title="overlong"></a>overlong</h4><p>用PEid显示有壳，但是ExInfo不是，直接拖到IDA看看</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse6/image-20211025101621373.png" alt="image-20211025101621373"></p>
<p>我们转到sub_401160函数看一下，图中的\x1c是十进制的28</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse6/image-20211025104708760.png" alt="image-20211025104708760"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse6/image-20211025104824155.png" alt="image-20211025104824155"></p>
<p>unk_402008指针指向的内容与TEXT(a1)一共进行了28次的一些字符操作。但是该指针指向的内容不止28个字符，点击进去查看有175个</p>
<p>exe一开始运行是这样的，说从未破坏编码，那就直接将其改为读取175个</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse6/image-20211025105732834.png" alt="image-20211025105732834"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse6/image-20211025110224330.png" alt="image-20211025110224330"></p>
<p>这样直接修改会有错误，提示Invalid operand，可能是吧修改的数据会覆盖掉后面的一些数据，我们拖进OD试试，发现改了以后后面的代码也变了</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse6/image-20211025111317713.png" alt="image-20211025111317713"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse6/image-20211025111342988.png" alt="image-20211025111342988"></p>
<p>直接修改二进制码</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse6/image-20211025113152358.png" alt="image-20211025113152358"></p>
<p>运行后如图，得到flag</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse6/image-20211025113214588.png" alt="image-20211025113214588"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    这道题目的收获主要是关于修改代码，一般都是直接修改，还没有考虑过会改变后面的数据。以后修改代码最好用OD，可以看到后面代码是否被修改</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2021/10/18/Cheese_point/CFG%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/18/Cheese_point/CFG%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">CFG机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-18 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-18T00:00:00+08:00">2021-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-22 14:24:47" itemprop="dateModified" datetime="2021-12-22T14:24:47+08:00">2021-12-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">知识点补充学习</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Control Flow Guard（CFG）是较新的windows漏洞利用缓解措施，旨在解决内存损坏漏洞。 针对的是间接跳转的保护，比如call eax，jmp eax等。 CFG扩展了先前的漏洞缓解技术，例如GS，DEP和ASLR。毫无疑问，它将大大改变攻击者的利用技术。就像ALSR导致了堆喷射技术的出现，和DEP导致了ROP技术的出现。微软的CFG实现是基于间接调用的目标必须是一个可靠的函数的起始位置。</p>
<p>以往是没有蓝色那行的，它执行的操作是将目标地址接受为参数，并实现CFG，下图是没有启用CFG的时候，有一个间接调用，他的目标地址不在编译的时候决定，而是在运行的时候。</p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps267A.tmp.jpg" alt="img"> </p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/CheesePoint1/wps267B.tmp.jpg" alt="img"> </p>
<p>CFG主要关注缓解间接调用和调用目标不可靠（不是一个有效的函数起始地址）的问题（在攻击中，这是shellcode的第一步）。所以CFG的实现是基于间接调用的目标必须是一个可靠的函数的起始位置。下图是调用目标代码后</p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps267C.tmp.jpg" alt="img"> </p>
<p>在间接调用之前，目标地址传给_guard_check_icall函数，在其中实现CFG。在没有CFG支持的Windows中，这个函数不做任何事。在Windows 10中，有了CFG的支持，它指向ntdll!LdrpValidateUserCallTarget函数。这个函数使用目标地址作为参数，并且做了以下事情：</p>
<p>**1.**访问一个bitmap（称为CFGBitmap），其表示在进程空间内所有函数的起始位置。在进程空间内每8个字节的状态对应CFGBitmap中的一位。如果在每组8字节中有函数的起始地址，则在CFGBitmap中对应的位设置为1；否则设置为0。</p>
<p>**2.**将目标地址转化为CFGBitmap中的一个位。我们以00b01030为例：</p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps267D.tmp.jpg" alt="img"> </p>
<p>高位的高位的3个字节（蓝色圈中的24位）是CFGBitmap（单位是4字节/32位）的偏移。在这个例子中，高位的3个字节相当于0xb010。因此，CFGBitmap中指向字节单元的指针是CFGBitmap的基址加上0xb010。</p>
<p>同时，第四位到第八位（红色圈中的）有值X。如果目标地址以0x10对齐（目标地址&amp;0xf==0），则X为单位内的位偏移值。如果目标地址不以0x10对齐（目标地址&amp;0xf!=0），则X|0x1是位偏移值。</p>
<p>在这个例子中，目标地址是0x00b01030，表达式0x00b01030&amp;0xf值为0。X的值为6，所以偏移也是6。</p>
<p>**3.**接下来就是转换成CFGBitmap中的一位，上一步得出位偏移是6，所以从零开始数。我们将第六位置为1，这意味着间接调用的目标是可靠的</p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps267E.tmp.jpg" alt="img"> </p>
<p>我们会产生几个问题：</p>
<ul>
<li><ol>
<li>CFGBitmap的位信息来自哪里？</li>
</ol>
</li>
<li><ol start="2">
<li>何时且怎么生成CFGBitmap？</li>
</ol>
</li>
<li><ol start="3">
<li>系统怎么处理不可靠的间接调用触发的异常？</li>
</ol>
</li>
</ul>
<h3 id="深入CFG的实现"><a href="#深入CFG的实现" class="headerlink" title="深入CFG的实现"></a>深入CFG的实现</h3><p>启用CFG的情况下用编译器编译的PE文件，用VS的dumpbin.exe转储出来，可以看到以下内容。</p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps267F.tmp.jpg" alt="img"> </p>
<p>Guard CF address of check-function pointer：_guard_check_icall的地址。在Windows 10预览版中，当PE文件加载时，_guard_check_icall将被修改并指向nt!LdrpValidateUserCallTarget。</p>
<p>Guard CF function table：函数的相对虚拟地址（RVA）列表的指针，其包含了程序的代码。每个函数的RVA将转化为CFGBitmap中的“1”位。换句话说，CFGBitmap的位信息来自Guard CF function table。</p>
<p>Guard CF function count：函数RVA的个数。</p>
<p>CF Instrumented：表明程序中启用了CFG。</p>
<h4 id="1-OS对CFG机制的支持"><a href="#1-OS对CFG机制的支持" class="headerlink" title="1.OS对CFG机制的支持"></a>1.OS对CFG机制的支持</h4><p>在OS引导阶段，第一个与该机制相关的函数是MiInitializeCfg，这个函数的主要任务是创建包含CFGBitmap的共享内存，调用时间可以在NT内核阶段1的内存管理器初始化（MmInitSystem）的时候找到,如图，在这个初始化期间，会调用MmInitSystem两次，第一个MmInitSystem将进入MiInitializeCfg，该函数的主要功能如下流程图所示。</p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps2680.tmp.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps2681.tmp.jpg" alt="img"> </p>
<ul>
<li><p>步骤A：注册表值来自HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session\Manager\kernel: MitigationOptions</p>
</li>
<li><p>步骤B：MmEnableCfg是一个全局变量，它被用来表示系统是否启用CFG功能.</p>
</li>
<li><p>步骤C：MiCfgBitMapSection的DesiredAccess允许所有的权限；它的分配类型是“reserve”。<strong>共享内存的大小可能会因为Win10的版本而有所不同。</strong>对于build 6.4.9841，它按用户模式空间大小计算。表达式是size=User Mode Space Size&gt;&gt;6。（&gt;&gt;X：右移X位）。对于build 10.0.9926，这个大小是0x3000000。CFG bitmap能表示整个用户模式空间。MiCfgBitMapSection是CFG实现的核心组件，因为它被用来包含CFGBitmap。</p>
</li>
</ul>
<h4 id="2-获得压缩RVA列表信息的函数且保存到映像的Control-Area结构"><a href="#2-获得压缩RVA列表信息的函数且保存到映像的Control-Area结构" class="headerlink" title="2.获得压缩RVA列表信息的函数且保存到映像的Control_Area结构"></a>2.获得压缩RVA列表信息的函数且保存到映像的Control_Area结构</h4><p>PE映像第一次加载到系统。NT内核将调用MiRelocateImage来重定位。MiRelocateImage将调用MiParseImageCfgBits。在函数MiParseImageCfgBits中，PE映像的压缩的RVA列表被计算且存储在PE映像节中的Control_Area数据结构。在系统引导期间一个PE映像只发生一次。</p>
<p>当PE再次加载进进程，NT内核将调用MiRelocateImageAgain。因为它的压缩的RVA列表已经保存了（且不需要再次计算），MiRelocateImageAgain不需要调用MiParseImageCfgBits，这样节省一些处理时间。因为微软实现CFG需要消耗时间和空间。在MiRelocateImage中，它的CFG相关的部分被如下描述：</p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps2682.tmp.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps2683.tmp.jpg" alt="img"> </p>
<p>下面我们详细了解一下MiParseImageCfgBits这个函数，首先看一下这个函数调用的上下文。</p>
<p>函数MiParseImageCfgBits有5个参数：</p>
<p>a) 映像节的Control_Area结构的指针</p>
<p>b) 映像文件内容的指针</p>
<p>c) 映像大小</p>
<p>d) 包含PE可选头结构的指针</p>
<p>e) 输出压缩的CFG函数RVA列表的指针</p>
<p>MiParseImageCfgBits的主要工作如下：</p>
<p>a) 从映像的Load Config Table获得函数RVA列表</p>
<p>b) 使用压缩算法压缩列表，以便在小空间保存列表</p>
<p>c) 创建压缩的RVA列表作为输出</p>
<h4 id="3-CFGBimap共享内存对象被映射的两种用途"><a href="#3-CFGBimap共享内存对象被映射的两种用途" class="headerlink" title="3.CFGBimap共享内存对象被映射的两种用途"></a>3.CFGBimap共享内存对象被映射的两种用途</h4><p>a) 用来写共享模块（.DLL文件等）的bits。在bits写入完成后，映射将释放。通过这个映射写入的bits信息是共享的，意味着它能被操作系统内所有的进程读取。这个映射发生在MiUpdateCfgSystemWideBitmap函数中。（该小节的详细内容请看5.a）</p>
<p>b) 用来写私有的bits和读取校验间接调用的bits。通过这个映射写入的bits是私有的，意味着它只能被当前进程读取。这个映射的生存周期与进程的生命周期相同。这个映射发生在MiCfgInitializeProcess中。</p>
<p>基于调用堆栈，我们知道它在一个正在初始化的进程中被映射。映射的基    址和长度将被保存在类型为MI_CFG_BITMAP_INFO的结构体中，且地址被    修改了。稍后将讨论怎么将私有的bits写入映射空间中。              MI_CFG_BITMAP_INFO的结构如下：</p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps2684.tmp.jpg" alt="img"> </p>
<h4 id="4-将RVA列表翻译为CFGBitmap中的bits"><a href="#4-将RVA列表翻译为CFGBitmap中的bits" class="headerlink" title="4.将RVA列表翻译为CFGBitmap中的bits"></a>4.将RVA列表翻译为CFGBitmap中的bits</h4><p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps2685.tmp.jpg" alt="img"> </p>
<p>在深入了解每个场景之前，要搞清楚一些背景信息。在每个进程中，包含CFGBitmap的空间被分为两部分：共享和私有。</p>
<p>MiCfgBitMapSection是一个共享内存对象，包含了CFGBitmap的共享的bitmap的内容。它与每个进程共享。当它在自己的虚拟内存空间中映射MiCfgBitMapSection时，每个进程看见的内容都相同。共享模块（dll等）的bitmap信息将通过4.a节描述的映射方法写入。</p>
<p>然而每个进程需要CFGBitmap的一部分不是被所有进程共享的。它需要私有写入一些模块的bitmap信息到CFGBitmap中。这个私有的部分将不和所有的进程共享。EXE模块的bitmap信息使用4.b节描述的方法写入。</p>
<p><strong>a) 在ReloadImage/ReloadImageAgain中，通过MiUpdateCfgSystemWideBitmap写入共享模块（dll等）的bits。</strong></p>
<p>如前面第二部分所见，在得到压缩的函数的RVA列表并将它保存到Control_Area结构后，它将调用MiSelectImageBase。这个函数是ASLR实现的核心。它返回最终选择的基址。选择的基地址对于写bit信息到CFGBitmap中非常重要。在得到基地址后，它将调用MiUpdateCfgSystemWideBitmap。</p>
<p>MiUpdateCfgSystemWideBitmap的主要任务是将压缩的RVA列表翻译为CFGBitmap中的“1”bit。通过这个函数写入的bitmap信息是共享的，且被操作系统所有的进程共享。这个函数只针对共享模块有效（dll文件等）。</p>
<p>这个函数有三个参数MiUpdateCfgSystemWideBitmap有3个参数：</p>
<p>指向Control_Area结构的指针</p>
<p>映像的基址</p>
<p>指向压缩的RVA列表的指针</p>
<p>MiUpdateCfgSystemWideBitmap的主要逻辑如下：</p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps2686.tmp.jpg" alt="img"> </p>
<p>在步骤B中，它映射CFGBitmap共享内存到系统进程空间中。它不映射所有共享内存的全部大小。它转化映像的基址为CFGBitmap的偏移，且使用转化的结果作为映射的起始地址。转为过程如下：</p>
<p>Bitmap的偏移=基地址&gt;&gt;6。按这个公式，映射大小是映像大小右移6位。这个方法在映像需要重定位（ReloadImageAgain函数）的时候也会被使用</p>
<p><strong>b) 在进程初始化阶段写私有模块（exe文件等）的bits。</strong>它将调用MiCommitVadCfgBits，其是一个调度函数。你能使用图13作为参考。它在确定的场景被调用。该函数的主要任务是为输入虚拟地址描述符所描述的空间写入bits。主要逻辑如下：</p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps2687.tmp.jpg" alt="img"> </p>
<p>MiMarkPrivateImageCfgBits函数实现向CFG Bitmap中写入私有模块（exe等）的bit信息。当系统映射一个EXE的节或者启动一个进程时，这个函数被调用。</p>
<p>这个函数有2个参数：</p>
<ol>
<li><p>Cfg信息的全局变量地址</p>
</li>
<li><p>映像空间的VAD</p>
</li>
</ol>
<p>VAD是用来描述虚拟内存空间范围的一个结构。</p>
<p>函数的主要任务是将输入VAD的相关的压缩RVA列表转化为bitmap信息，且在CFGBitmap中写入bits。函数主要逻辑如下：</p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps2688.tmp.jpg" alt="img"> </p>
<p>在步骤A中，压缩的RVA列表能从输入的VAD关联的Control_Area结构中获得，在MiRelocateImage中保存（参见第二节）。</p>
<p>这个函数的主要步骤是步骤C。它实现私有写入映射的MiCfgBitMapSection32节（在3.b节有描述）。写入的私有的bits的映射是只读的。向映射的空间写入bits怎么实现？关键步骤如下：</p>
<p>i. 获得映射的空间地址的物理地址（PFN）</p>
<p>ii. 申请一个空的页表入口（PTE）并使用上步获得的物理地址填充PTE，新的PTE被映射到相同的物理页，其包含了映射的MiCfgBitMapSection32的虚拟地址。</p>
<p>iii. 复制结果缓冲区（图12）到新的PTE。物理页将包含结果缓冲区的内容</p>
<p>iv. 释放新的PTE</p>
<p>在上面步骤完成后，bitmap信息被拷贝到当前进程地址空间内。但是不会影响MiCfgBitMapSection。换句话说，MiCfgBitMapSection不知道bitmap改变了。其他进程也不会看到改变；新添加的bitmap信息对当前进程是私有的。</p>
<p><strong>c)写虚拟内存操作的bits。</strong>如果一个进程有虚拟内存操作，它可能会影响CFGBitmap中的bitmap的bits状态。从图13的场景看，它将调用MiMarkPrivateImageCfgBits。函数的主要工作是复制“1”或“0”页到CFGBitmap空间中。</p>
<p>i. 对于NtAllocVirtualMemory函数</p>
<p>如果一个进程调用NtAllocVirtualMemory函数来分配具有可执行属性的虚拟内存，NT内核将设置CFGBitmap中相关的位为“1”。但是如果分配的内存的保护属性有 SEC_WRITECOMBINE，NT内核将使用“0”设置bitmap。</p>
<p>ii. 对于MiProtectVirtualMemory函数</p>
<p>如果一个进程调用MiProtectVirtualMemory来改变虚拟内存的保护属性为“可执行”，NT内核将设置CFGBitmap相关位为“1”。</p>
<p><strong>d) 写映像和数据段映射的bits</strong></p>
<p>i. 对于映像（dll，EXE等）节的映射，如果映像不是共享的，处理过长如4.b节描述。如果是共享的，将由图13中的MiMarkPrivateImageCfgBits函数处理。它遍历映射空间中的每个页且将页地址转化为CFGBitmap中的偏移。</p>
<p>i. 如果CFGBitmap中的偏移不被PrototypePTE支持，相关的bits信息将被拷贝到CFGBitmap空间中。</p>
<p>ii. 如果CFGBitmap中的偏移已经有bitmap信息，CFGBitmap部分将改为只读。</p>
<p>ii. 对于数据段的映射，处理与前面的c.i相同。</p>
<h4 id="5-用户模式下获取CFGBitmap映射的地址"><a href="#5-用户模式下获取CFGBitmap映射的地址" class="headerlink" title="5. 用户模式下获取CFGBitmap映射的地址"></a>5. 用户模式下获取CFGBitmap映射的地址</h4><p>上面提到的步骤都发生在内核模式下。但是对于用户模式，CFGBitmap需要访问LdrpValidateUserCallTarget函数，它在上一部分已经描述了。当创建一个进程，NT内核调用PspPrepareSystemDllInitBlock函数来写CFGBitmap映射的地址和全局变量的长度，其数据结构是PspSystemDllInitBlock结构。PspSystemDllInitBlock是修正过的地址并且从用户模式和内核模式都能访问。用户模式可以访问硬编码的PspSystemDllInitBlock全局变量的CFGBitmap字段。</p>
<h4 id="6-LdrpCfgProcessLoadConfig"><a href="#6-LdrpCfgProcessLoadConfig" class="headerlink" title="6. LdrpCfgProcessLoadConfig"></a>6. LdrpCfgProcessLoadConfig</h4><p>在之前的图中，_guard_check_icall函数指针将指向ntdll的LdrpValidateUserCallTarget。何时发生，如何发生？LdrpCfgProcessLoadConfig来完成这个工作。进程创建过程将在用户模式下调用LdrpCfgProcessLoadConfig。</p>
<h4 id="7-RtlpHandleInvalidUserCallTarget"><a href="#7-RtlpHandleInvalidUserCallTarget" class="headerlink" title="7.RtlpHandleInvalidUserCallTarget"></a>7.RtlpHandleInvalidUserCallTarget</h4><p>在所有的准备都完成后，如果间接调用的目标地址相关的位在CFGBitmap中不是“1”，将触发CFG。进程将采取行动处理这个异常。处理函数是RtlpHandleInvalidUserCallTarget。这个函数使用间接调用的目标为唯一的参数。函数的主要逻辑如下：</p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps2689.tmp.jpg" alt="img"> </p>
<p>函数的主要流程是校验DEP状态和触发int 29中断，这个内核中断处理例程是KiRaiseSecurityCheckFailure。它的行为是结束进程。</p>
<p>如果一个间接调用的目标地址的CFGBitmap中的相关的位不能访问（如超出了CFGBitmap空间），意味着目标地址是不可靠的。系统将抛出访问异常。当这个异常回到用户模式的处理函数KiUserExceptionDispatcher时，它将调用RTLDispatchException。在RTLDispatchException中，它将校验异常发生的地址。如果指令的地址能访问CFGBitmap，它将继续调用RtlpHandleInvalidUserCallTarget。</p>
<p>如果一个进程需要自定义CFGBitmap，它能调用ntdll中的NtSetInformationVirtualMemory。在内核中函数MiCfgMarkValidEntries实现了这个功能。MiCfgMarkValidEntries以一个缓冲区和长度作为参数。缓冲区中的每个单位是8字节。头四个字节是目标地址，其想在CFGBitmap中设置相关的位，且后四个字节是设置“0”或“1”的标志。MiCfgMarkValidEntries自定义的CFGBitmap只在当前进程能看见。</p>
<p>如果一个攻击者需要改变用户模式下的CFGBitmap的内容，是不可能的。因为CFGBitmap被映射为只读（在3.b节讨论过）。不管改内存保护属性还是向空间中写值都将失败。</p>
<h3 id="CFG的弱点"><a href="#CFG的弱点" class="headerlink" title="CFG的弱点"></a>CFG的弱点</h3><p>当然，这个机制不是没有弱点的。指出了一些弱点如下：</p>
<p>CFGBitmap空间地址存储在修正过的地址中，其能被用户模式代码获得。这在CFG实现中讨论过。这是很重要的安全问题，但是被简单的放过了。</p>
<p>如果主模块没有开启CFG，即使加载的启用了CFG的模块，进程也不会受保护。</p>
<p>基于最后一个图，如果一个进程的主模块禁用了DEP（通过/NXCOMPAT:NO），能绕过CFG访问处理，即使间接调用的目标地址是不可靠的。</p>
<p>在CFGBitmap中的每个bit在进程空间中表示8个字节。因此如果一个不可靠的目标地址少于8个字节，CFG将认为是可靠的。</p>
<p>如果目标函数是动态生成的（类似JIT技术），CFG的实现不能保护。这是因为NtAllocVirtualMemory将在CFGBitmap中为所有分配的可执行的内存空间设置为“1”（4.c.i描述）。通过MiCfgMarkValidEntries自定义的CFGBitmap解决这个问题是可能的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2021/10/18/%E8%84%B1%E5%A3%B3%E5%AD%A6%E4%B9%A0/%E5%8A%A0%E5%A3%B3%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/18/%E8%84%B1%E5%A3%B3%E5%AD%A6%E4%B9%A0/%E5%8A%A0%E5%A3%B3%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">加壳知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-18 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-18T00:00:00+08:00">2021-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-22 16:30:32" itemprop="dateModified" datetime="2021-12-22T16:30:32+08:00">2021-12-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%84%B1%E5%A3%B3%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">脱壳学习</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="脱壳存根"><a href="#脱壳存根" class="headerlink" title="脱壳存根"></a>脱壳存根</h3><p>​    脱壳存根是一个类似于一个exe加载器，如果静态分析某个加壳的exe，实际上分析的是脱壳存根。主要执行如下：</p>
<pre><code>* 将原始程序脱壳到内存
* 解析原始可执行文件的所有导入函数
* 将可执行程序转移到原始的程序入口点（EOP）
</code></pre>
<h3 id="解析函数导入表"><a href="#解析函数导入表" class="headerlink" title="解析函数导入表"></a>解析函数导入表</h3><ul>
<li><p>导入Loadlibrary和GetProcAddress</p>
</li>
<li><p>保持原始导入表的完整，让windows加载器加载所有dll以及导入函数</p>
</li>
<li><p>为原始导入表种的每个dll保留一个导入函数</p>
</li>
<li><p>不导入任何函数，在不用函数的前提下，自己从库中查找所有需要的函数或者首先找到LoadLibrary和GetProcAddress，然后定位其他的库</p>
<p><u>第二种和第三种静态分析都会很容易看到导入库。</u></p>
</li>
</ul>
<h3 id="尾部跳转"><a href="#尾部跳转" class="headerlink" title="尾部跳转"></a>尾部跳转</h3><p>​    完成脱壳后必须使用尾部跳转指令跳转到OEP执行，jmp是最简单的指令，所以有些使用ret或者call来隐藏。有时还会使用操作系统转移控制的函数来掩盖（譬如NtContinue、ZwContinue）。</p>
<h3 id="脱壳过程"><a href="#脱壳过程" class="headerlink" title="脱壳过程"></a>脱壳过程</h3><p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/image-20211129202544768.png" alt="image-20211129202544768"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/image-20211129202522905.png" alt="image-20211129202522905"></p>
<h3 id="脱壳分类"><a href="#脱壳分类" class="headerlink" title="脱壳分类"></a>脱壳分类</h3><h4 id="自动脱壳"><a href="#自动脱壳" class="headerlink" title="自动脱壳"></a>自动脱壳</h4><p>​    自动静态脱壳解压缩或者解密一个可执行文件，但是仅仅只针对某个壳。PE Explorer提供了一些默认安装的静态脱壳插件，支持NSPack、UPack、UPX。</p>
<p>​    自动动态脱壳程序运行可执行文件，并让脱壳存根脱出原始的可执行文件。自动的脱壳程序必须确定脱壳存根的结束位置，原始文件的开始位置。但是目前并没有非常好用的公开的自动动态脱壳程序。</p>
<h4 id="手动脱壳"><a href="#手动脱壳" class="headerlink" title="手动脱壳"></a>手动脱壳</h4><ul>
<li><p>找到加壳算法，然后编写程序逆向运行它。</p>
</li>
<li><p>运行托克程序，让脱壳存根帮你工作。（让它从内存中转储出进程，然后再手动修正PE头部）</p>
<h5 id="用UPX的壳尝试一下OllyDbg脱壳"><a href="#用UPX的壳尝试一下OllyDbg脱壳" class="headerlink" title="用UPX的壳尝试一下OllyDbg脱壳"></a>用UPX的壳尝试一下OllyDbg脱壳</h5><h5 id="重构导入表"><a href="#重构导入表" class="headerlink" title="重构导入表"></a>重构导入表</h5><p>​    当OllyDump重构导入表失败时，可以使用导入重构器（ImpRec）。</p>
<p>操作系统如何填充IAT：</p>
<p>​      1:定位导入表</p>
<p>​      2:解析第一个IID(IMAGE_IMPORT_DESCRIPTOR)项,根据IID中的第4个字段定位DLL的名称</p>
<p>​      3:根据IID项的第5个字段DLL对应的IAT项的起始地址</p>
<p>​      4:根据IAT中的指针定位到相应API函数名称字符串</p>
<p>​      5:通过GetProcAddress获取API函数的地址并填充到IAT中</p>
<p>​      6:当定位到的IAT项为零的时候表示该DLL的API函数地址获取完毕了,接着继续解析第二个IID,重复上面的步骤。</p>
<p>1)定位导入表</p>
<p> <img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/wps5B8D.tmp.jpg" alt="img"></p>
<p>2)定位到导入表的起始地址</p>
<p> <img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/wps5B8E.tmp.jpg" alt="img"></p>
<p>3)根据第一个IID项中的第四个字段得到DLL名称字符串的指针,这里指向的是USER32.DLL</p>
<p> <img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/wps5B8F.tmp.jpg" alt="img"></p>
<p>根据第五个字段的内容定位到IAT项的起始地址,这里是403184,我们定位到该地址处。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/wps5B90.tmp.jpg" alt="img"> </p>
<p>这里我们可以看到已经被填充了正确的API函数的入口地址,跟我们dump出来的结果一样,我们再来看看相应的可执行文件偏移处的内容是什么。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/wps5B91.tmp.jpg" alt="img"> </p>
<p>这里我们可以看到第一个API函数的名称位于4032CC地址处,我们定位到该地址处。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/wps5BA1.tmp.jpg" alt="img"> </p>
<p>第一个API函数是KillTimer,我们在OD中看到的KillTimer的入口地址是操作系统调用GetProcAddress获取到的。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/wps5BA2.tmp.jpg" alt="img"> </p>
<p>这里我们可以看到KillTimer的入口地址为77D18C42。该地址将被填充到IAT相应单元中去覆盖原来的值。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/wps5BA3.tmp.jpg" alt="img"> </p>
<p>这里是IAT中的第一元素。</p>
<p>我们再来看下一个元素,向后偏移4就是,来看一看该API函数名称字符串的指针是多少。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/wps5BA4.tmp.jpg" alt="img"> </p>
<p>定位到可执行文件的相应偏移处:</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/wps5BA5.tmp.jpg" alt="img"> </p>
<p>32D8即4032D8,来看看该API函数的名称是什么,这里由于该指针不为零,说明该API函数还是位于USER32.DLL中的。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/wps5BA6.tmp.jpg" alt="img"> </p>
<p>这里我们可以看到第二个API函数是GetSystemMetrics,通过该函数名称可以通过GetProcAddress获取到其函数地址然后填充到IAT中。接下来按照以上步骤依次获取USER32.DLL中的其他的函数地址,直到遇到的IAT项为零为止。我们来看一看可执行文件中结束项位于哪里。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/wps5BA7.tmp.jpg" alt="img"> </p>
<p>我们可以看到当IAT中元素为零的时候表明USER32.DLL就搜索完毕了,</p>
<h5 id="手动修复导入表"><a href="#手动修复导入表" class="headerlink" title="手动修复导入表"></a>手动修复导入表</h5><p>​    前面的工具是搜索内存中的导入函数来重构导入表，但是也有失败的时候。先了解一下导入表如何工作的。导入表在内存中实际有两个表，<u>一个是函数名称或者序号列表，其中包含记载器或脱壳存根需要的函数名称或者序号；第二个表是所有导入函数的地址列表。</u>实际上运行的时候只需要第二个，所以加壳程序可以通过移除名字列表阻止分析。这时候就需要手动重构。</p>
<p>​    在反汇编中遇到导入函数时，逐个进行修复是最简单的策略，比如下图为例，IDA中DWORD处的值明显位于加载程序的地址范围之外，使用OD打开文件，将光标移动到该处查看内容，OD标注为WriteFile,所以我们可以将其标注。</p>
<p>​    另外一种方法是需要运行脱壳程序，如果发现了导入函数表就看可手动重构原始的导入表，也可以写个脚本来帮助输入这些信息，缺点是复杂又费时。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/image-20211201103634458.png" alt="image-20211201103634458"></p>
<h5 id="查找OEP"><a href="#查找OEP" class="headerlink" title="查找OEP"></a>查找OEP</h5><p>​    自动工具查找OEP,最常使用的是OllyDump。通常脱壳存根与可执行文件不在一个节中，使用step-over或者step-into的方法，当程序跳转到另外一个节中运行时，OllyDbg可以探测到这种转移，并在那里进行中断。call函数就是用来调用其他节的代码，这种方法旨在防止OllyDbg错误标注这些调用OEP的曹祖破，step-over方法将跳过所有call指令。但是如果该call没有返回，那么OllyDbg就会定位到OEP。<u>因此一些恶意代码经常包含一些没有返回的call，以此来干扰分析。</u></p>
<p>​    所以实际情况要结合step-over和step-into方法。</p>
<p>​    <strong>手动查找OEP</strong></p>
<p>​    <strong>1.<strong>最简单的就是查找尾部跳转指令（</strong>一串无效字节指令前的最后一条有效指令</strong>），填充这些字节的目的是为了保证节的字节对齐。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/image-20211130161428842.png" alt="image-20211130161428842"></p>
<p>​    图中非常明显的标志是：位于尾部但是<u>链接到了一个很远的位置</u>（<strong>正常情况为几百个字节以内</strong>），并且<u>一般情况下跳转指令之后会有一个返回，但是图中全是一些无意义代码</u>。</p>
<p>​    在IDA中，<u>如果是一个尾部跳转会标注为<strong>红色</strong></u>。</p>
<p>​    在脱壳存根开始运行时，<u>尾部跳转的地址不包含有效指令，但是一旦被运行就肯定包含有效指令。</u></p>
<p>​    <strong>2.<strong>在栈上设置读断点。反汇编中的大部分函数，包括脱壳存根都是以push开头，首先在栈中记录第一个入栈的内存地址，然后在这个栈位置设置一个读断点，只有在脱壳完成的情况下，才能获取原始push的堆栈地址。所以在pop指令获取那个地址的时候，就会命中断点。（</strong>通常尾部跳转紧跟pop</strong>）</p>
<p>​    **3.**在代码中每个循环后面设置断点（通过扫描代码来识别循环，并且在每个循环之后设置断点）</p>
<p>​    **4.**在GetprocAddress函数设置断点。</p>
<p>​    **5.**在被原始程序调用且继续向后工作的函数上设置断点。因为壳通常相同，因此可以在它调用的一个函数上设置断点，来发现OEP。比如壳通常很早就调用了GetVersion以及GetCommandlineA函数，所以可以在这些函数调用时中断程序。<u>于GUI程序，GetModuleHandleA通常是第一个被调用的函数。</u></p>
<p>​    **6.**使用OllyDbg的Run Trace。Run Trace提供一些额外的断点选项，这使得能在较大范围的内存地址上 设置断点。很多加壳程序都会留下原始文件的.text节，OEP总是位于原始文件的该节中，一般是这个节中第一个被调用的指令，Run Trace可以让你设置这样的一个断点，无论什么时候执行.text节中的指令，此段点都能被触发。</p>
<h3 id="常见的壳"><a href="#常见的壳" class="headerlink" title="常见的壳"></a>常见的壳</h3><h4 id="UPX"><a href="#UPX" class="headerlink" title="UPX"></a>UPX</h4><p>​    这个壳开源免费并且易于使用，但是它不会对分析人员造成阻碍，所以很多恶意代码看似使用了UPX，但是实际上使用其他的壳或者修改过的UPX，这个时候可以根据前面描述的策略查找OEP，也可以通过OllyDump的Section Hop功能来查找OEP,或者直接仔细检查脱壳存根，直到找到尾部跳转为止，然后使用OllyDump转储文件，并重构导入表，成功脱壳。</p>
<h4 id="PECompact"><a href="#PECompact" class="headerlink" title="PECompact"></a>PECompact</h4><p>​    是一个商业的壳，它有一个插件框架，允许第三方工具集成进去，因此恶意程序进场使用该第三方工具，使得脱壳变得更困难。该加壳方法的脱壳与谦和相似，程序会产生几个异常，所以需要设置OD将异常传回程序（options-Debugging options-Exceptions）。可以通过查找尾部跳转失灵来查找OEP。</p>
<h4 id="ASPack"><a href="#ASPack" class="headerlink" title="ASPack"></a>ASPack</h4><p>​    使用了自我修改代码，让设置断点和分析它变得困难。在程序上设置断点，可以让程序立即终止，但是可以在栈地址行设置硬件断点完成手动脱壳，但是因为该壳很流行，所以网上有很多自动脱壳程序。</p>
<p>​    手动脱壳时，首先打开脱壳存根的代码，在代码开始部分，会看到一个PUSHA指令。确定用来存在寄存器的栈地址，然后在这些栈地址设置硬件断点，调用POPAD指令时，就会触发，然后会在离尾部跳转不远的地方找到OEP。</p>
<h4 id="Petite"><a href="#Petite" class="headerlink" title="Petite"></a>Petite</h4><p>​    使用了单步异常，但是可以像前面说的将异常传回程序，与ASPack相同，使用栈上的硬件断点来查找OEP是最佳策略。另外，它保持从原始导入表的每个库中至少导出一个函数，这在没有脱壳的情况下，很容易确定恶意程序使用了那些dll。</p>
<h4 id="WinUpack"><a href="#WinUpack" class="headerlink" title="WinUpack"></a>WinUpack</h4><p>​    一个有着GUI终端的壳，设计目的在于优化压缩而不是安全。该壳有一个命令行版本叫做UPack，有专门针对该两种壳的自动脱壳器。</p>
<p>​    识别尾部跳转有一个技巧，大多数脱壳存根都小于0x4000个字节，因此跳转的大小大于或者等于0x4000一般是跳转到OEP（针对书中例子），<u>脱壳存根通常有很多条件跳转并且在函数中间返回</u>，但是OEP周围的代码应该不会有这些不寻常的元素。</p>
<p>​    另一种针对Upack的策略是在函数GetModuleHandleA（GUI）或者函数GetCommandlineA(命令行)上设置断点。在windows中，这些函数在调用Oep不久后就会被调用，一旦触发断点就向后搜索代码查找OEP。</p>
<p>​    WinUpack有时会使用一个OD不能正确解析的头部，使其崩溃，这时候需要首先使用WinDbg.</p>
<h4 id="Themida"><a href="#Themida" class="headerlink" title="Themida"></a>Themida</h4><p>​    一个非常复杂的壳，包含阻止使用vmware、调试器，以及Procmon分析的功能。此外还有一个内核模块，运行在内核中的代码限制很少，而且分析程序通常运行在用户空间中，所以分析会受到很多限制。<u>自动化工具成功与否与加壳版本有关。</u></p>
<p>​    如果自动化工具无法脱壳，那么一种较好的方法是用procDump工具从内存中转储不在进行调试的进程。该工具的最大优点是在不停止进程或者调试进程的情况下，转储进程中的内存。这个过程并不能完全恢复可执行文件，但是能让我们在代码上运行strings工具并做一些分析。</p>
<h3 id="加壳DLL"><a href="#加壳DLL" class="headerlink" title="加壳DLL"></a>加壳DLL</h3><p>​    加壳Dll列出的开始地址是脱壳存根中的一个地址，位于DllMain中，而不是主函数中。DllMain函数在OC终端他运行之前被调用，中段发生的时候，脱壳存根已经运行，这将很难找到OEP。解决这个问题，我们可以打开PE文件，定位到IMAGE_FILE_HEADER节的特征标志域，将该节0x2000处的比特位从1修改为0，文件从dll变为exe.</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2021/10/14/paper/2020%E9%BB%91%E5%B8%BDDetecting%20Access%20Token%20Manipulate%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/14/paper/2020%E9%BB%91%E5%B8%BDDetecting%20Access%20Token%20Manipulate%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">2020黑帽Detecting Access Token Manipulate学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-14 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-14T00:00:00+08:00">2021-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-22 15:49:57" itemprop="dateModified" datetime="2021-12-22T15:49:57+08:00">2021-12-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/paper-reading/" itemprop="url" rel="index"><span itemprop="name">paper reading</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇文章主要目的是帮助安全从业人员理解：Windows下访问令牌是怎么工作的；攻击者是如何利用合法的Windows功能来横向移动并损害整个ActiveDirectory域信；他们检测和响应其环境中的访问令牌操作的能力。</p>
<h3 id="Windows-Security-Internals"><a href="#Windows-Security-Internals" class="headerlink" title="Windows Security Internals"></a>Windows Security Internals</h3><h4 id="Logon-Sessions-and-Access-Tokens"><a href="#Logon-Sessions-and-Access-Tokens" class="headerlink" title="Logon Sessions and Access Tokens"></a>Logon Sessions and Access Tokens</h4><p>简单的说，用户登陆到windows系统之后，不管该用户是本地登陆的，还是远程登陆，系统都会为这个用户分配一个新的**会话ID(SID)**。也就是说会话与用户的登录是相关连的，没有用户登录就不存在会话。因此，会话的含义是指用户登录之后的一种运行的环境。会话管理器(\Windows\System32\Smss.exe)是系统中第一个创建的用户态模式进程，负责完成执行体和内核的初始化工作的内核模式系统线程在最后阶段创建了实际的Smss进程。</p>
<p>会话(session)是由进程和其他的系统对象(比如窗口站、桌面和窗口)构成的，它们代表了一个用户的工作站登录会话。会话具体是由如下几个部分组成的：</p>
<p>   \1. 每个会话包含一个单独的win32k.sys</p>
<p>   \2. 专门的换页池区域</p>
<p>   \3. 私有windows子系统和登陆进程的拷贝</p>
<p>   \4. 系统空间中被映射的空间,被称为会话空间的区域</p>
<p>现在会话同进程做一个比较，发现他们之间有一些相似之处：</p>
<p>   \1. 都提供一个执行的环境</p>
<p>   \2. 都有一个私有空间</p>
<p>   进程是为了内部的执行的线程提供一个空间和环境，而会话则是为内部所有的进程提供一个执行的空间和环境。当用户登陆到系统中之后，用户下所有的进程都属于这个会话空间，在每个进程的PEB当中就有SessionID。Windows创建的第一个会话被称为会话0，是系统用户SYSTEM的会话通常称为会话0，服务就是运行在此会话中。而令牌就像是一个标识符，标识该账号的一切应用和操作。</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/desktop/SecAuthZ/access-tokens"><strong>访问令牌</strong></a>是用来描述进程或线程安全上下文的对象，令牌所包含的信息是与该 user 账户相关的进程或线程的身份和权限信息。当 user 登录时，系统通过将 user 输入的密码与储存在安全数据库中的密码进行对比。若密码正确，系统此时会为 user 生成一个访问令牌。之后，该 user 执行的每个进程都会拥有一个该访问令牌的副本。每个线程默认直接继承进程的token，线程还可以通过模拟，改变自己的token，让自己拥有别的用户的token。</p>
<p>令牌产生过程：使用凭据(用户密码)进行认证；</p>
<p>登录Session创建；</p>
<p>Windows返回用户sid和用户组sid；</p>
<p>LSA(Local Security Authority)创建一个Token；</p>
<p>依据该token创建进程、线程(如果CreaetProcess时自己指定了 Token, LSA会用该Token， 否则就继承父进程Token进行运行)</p>
<p>首先了解下令牌的四个模拟级别，分别是：Anonymous，Identification，Impersonation，Delegation</p>
<p>Anonymous：服务器无法模拟或识别客户端。</p>
<p>Identification：服务器可以获取客户端的身份和特权，但不能模拟客户端。</p>
<p>Impersonation：服务器可以在本地系统上模拟客户端的安全上下文。</p>
<p>Delegation：服务器可以在远程系统上模拟客户端的安全上下文。</p>
<p>所以当令牌具有Impersonation和Delegation级别的时候才可以进行模拟。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/wpsD52E.tmp.jpg" alt="img"><br>    言而总之，只要我们有SeAssignPrimaryToken或者SeImpersonate权限，就可以通过模拟Primary令牌来提升权限，而Primary令牌可以通过DuplicateTokenEx调用一个Impersonation令牌来转换。</p>
<p>所以一个模拟令牌的过程大概是：OpenProcess(获取目标进程上下文)-&gt;OpenProcessToken(获得进程访问令牌的句柄)–&gt;DuplicateTokenEx(创建一个主/模拟令牌)–&gt;CreateProcessWithTokenW(创建进程)</p>
<h4 id="How-Attackers-Abuse-Access-Token"><a href="#How-Attackers-Abuse-Access-Token" class="headerlink" title="How Attackers Abuse Access Token"></a>How Attackers Abuse Access Token</h4><p>攻击者可以使用内置的Windows API函数从现有进程复制访问令牌，这就是所谓的令牌窃取。然后可以将这些令牌应用于现有进程（即Token Impersonation/Theft）或用于生成新进程（即Create Process with Token）。攻击者必须已经处于特权用户上下文（即管理员）中才能窃取令牌。然而，攻击者通常使用令牌窃取将其安全上下文从管理员级别提升到系统级别。然后，如果帐户在远程系统上具有适当的权限，则攻击者可以使用令牌向远程系统进行身份验证，作为该令牌的帐户。</p>
<p>在ATT&amp;CK框架中，对于令牌操作有五种技术介绍：</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/wpsD53E.tmp.jpg" alt="img"> </p>
<h4 id="Token-Impersonation-Theft"><a href="#Token-Impersonation-Theft" class="headerlink" title="Token Impersonation/Theft"></a>Token Impersonation/Theft</h4><p>攻击者可以使用DuplicateToken（Ex）创建一个新的访问令牌来复制现有令牌。然后，该令牌可与ImpersonalLoggedOnUser一起使用，以允许调用线程模拟登录用户的安全上下文，或与SetThreadToken一起将模拟令牌分配给线程。</p>
<p><strong>检测：</strong></p>
<p>如果攻击者使用标准命令行shell，分析人员可以通过审核命令行活动来检测令牌操纵。具体来说，分析人员应该寻找runas命令的使用。默认情况下，Windows中未启用详细的命令行日志记录。</p>
<p>分析人员还可以监视Windows API（如DuplicateToken（Ex）、ImpersonalLoggeDonUser和SetThreadToken）的使用情况，并将活动与其他可疑行为关联起来，以减少由于用户和管理员正常的良性使用而导致的误报。 </p>
<h4 id="Create-Process-with-Token"><a href="#Create-Process-with-Token" class="headerlink" title="Create Process with Token"></a>Create Process with Token</h4><p>攻击者可能会使用重复的令牌创建一个新进程，以升级权限并绕过访问控制。攻击者可以使用DuplicateToken（Ex）复制所需的访问令牌，并将其与CreateProcessWithTokenW一起使用，以创建在模拟用户的安全上下文下运行的新进程。这对于在不同用户的安全上下文下创建新进程非常有用。</p>
<p><strong>检测：</strong></p>
<p>如果攻击者使用标准命令行shell，同上。</p>
<p>如果攻击者使用直接调用Windows令牌API的有效负载，分析人员只能通过仔细分析用户网络活动、检查正在运行的进程以及与其他端点和网络行为的关联来检测令牌操纵。 </p>
<p>分析人员还可以监视Windows API，同上。</p>
<h4 id="Make-and-Impersonate-Token"><a href="#Make-and-Impersonate-Token" class="headerlink" title="Make and Impersonate Token"></a>Make and Impersonate Token</h4><p> 攻击者可以制作和模拟令牌以提升权限并绕过访问控制。如果攻击者拥有用户名和密码，但用户未登录系统，则攻击者可以使用LogonUser功能为用户创建登录会话。该函数将返回新会话的访问令牌的副本，攻击者可以使用SetThreadToken将令牌分配给线程。</p>
<p><strong>检测：</strong></p>
<p>同上</p>
<h4 id="Parent-PID-Spoofing"><a href="#Parent-PID-Spoofing" class="headerlink" title="Parent PID Spoofing"></a>Parent PID Spoofing</h4><p>攻击者可以欺骗新进程的父进程标识符（PPID），以逃避进程监视防御或提升权限。除非明确指定，否则新进程通常直接从其父进程或调用进程派生。显式分配新进程的PPID的一种方法是通过CreateProcess API调用，该调用支持定义要使用的PPID的参数。此功能由Windows功能（如用户帐户控制（UAC））使用，以便在系统生成请求的提升进程后正确设置PPID（通常通过svchost.exe或approve.exe）而不是当前用户上下文。</p>
<p>攻击者可能会利用这些机制来逃避防御，例如阻止直接从Office文档生成的进程，以及针对异常/潜在恶意父子进程关系的分析，例如将PowerShell/Rundll32的PPID欺骗为explorer.exe，而不是将Office文档作为Spearphishing Attachment的一部分。此欺骗可以通过Visual Basic在恶意Office文档或任何可以执行本机API的代码中执行。</p>
<p>显式分配PPID还可以启用提升的权限，赋予父进程适当的访问权限。例如，特权用户上下文（即管理员）中的攻击者可能会生成一个新进程，并将父进程分配为作为系统运行的进程（如lsass.exe），导致新进程通过继承的访问令牌提升。</p>
<p><strong>检测：</strong></p>
<p>查找存储PPID信息的各个字段之间的不一致性，例如通过Windows事件跟踪（ETW）收集的数据中的EventHeader ProcessId、Windows事件日志中的创建者进程ID/名称以及ProcessId和ParentProcessID（也由ETW和其他实用程序（如任务管理器和Process Explorer）生成）。ETW提供的EventHeader ProcessId标识实际的父进程。</p>
<p>监视和分析对CreateProcess/CreateProcessA的API调用，特别是来自用户/潜在恶意进程的API调用，并使用显式分配PPID的参数（例如：进程创建标志0x8XXX，表示正在使用扩展启动信息创建进程）。恶意使用CreateProcess/CreateProcessA也可能通过调用UpdateProctThreadAttribute进行，这可能是更新进程创建属性所必需的。这可能会从正常UAC提升行为中产生误报，因此如果可能，请与系统基线/对正常系统活动的理解进行比较。</p>
<h4 id="SID-History-Injection"><a href="#SID-History-Injection" class="headerlink" title="SID-History Injection"></a>SID-History Injection</h4><p>对手可以使用SID历史记录注入来升级权限和绕过访问控制。Windows安全标识符（SID）是标识用户或组帐户的唯一值。Windows security在安全描述符和访问令牌中都使用SID。帐户可以在SID-History Active Directory属性中保存其他SID，从而允许在域之间进行可互操作的帐户迁移（例如，SID-History中的所有值都包含在访问令牌中）。</p>
<p>使用域管理员（或同等）权限，可以将获取的或已知的SID值插入到SID历史记录中，以启用对任意用户/组（如企业管理员）的模拟。此操作可能会导致通过横向移动技术（如远程服务、SMB/Windows管理员共享或Windows远程管理）提升对本地资源的访问和/或访问无法访问的域。</p>
<p><strong>检测：</strong></p>
<p>使用PowerShell Get-ADUser 命令行工具检查用户SID历史记录属性中的数据，尤其是具有来自同一域的SID历史记录值的用户。还可以监视域控制器上的帐户管理事件，以查看SID历史记录的成功更改和失败更改。</p>
<p>监视对DsAddSidHistory函数的Windows API调用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2021/10/11/reverse/Maze/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/11/reverse/Maze/" class="post-title-link" itemprop="url">buuctf_Maze</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-11 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-11T00:00:00+08:00">2021-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-22 10:23:35" itemprop="dateModified" datetime="2021-12-22T10:23:35+08:00">2021-12-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/buuctf/" itemprop="url" rel="index"><span itemprop="name">buuctf</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>558</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Maze"><a href="#Maze" class="headerlink" title="Maze"></a>Maze</h4><p>1.首先PEid查壳，查到是UPX的壳</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse5/image-20211011192051606.png" alt="image-20211011192051606"></p>
<p>2.UPX脱壳，之前在网上找脱壳工具，但是其实UPX是开源的，在github上下载后，在cmd下执行upx -d yourfile.exe就可以脱壳，拖进IDA是下面的样子，发现f5不能查看伪代码，再看左边的函数栏，没有main函数。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse5/image-20211011195316028.png" alt="image-20211011195316028"></p>
<p>网上搜索后发现是加了<strong>花程序</strong></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse5/image-20211011195716680.png" alt="image-20211011195716680"></p>
<p>查看上图的jnz跳转到了下一行代码。相当于没有跳转，接下来的call调用的一个不是地址的地址，网上的方法是将jnz指令nop掉（<u>nop指令也就是控指令，执行的时候不做任何事，有时候可用于短接某些触点或用nop指令将不要的指令覆盖掉</u>）</p>
<p>3.先将jnz指令nop掉（Edit-&gt;Patch program-&gt;Assemble），因为call后面很有可能事有用的数据，所以用d先转换为数据,jnz后面的也是花指令，所以应该把该数据包的高字节部分也nop掉，但是IDA总是不成功，所以用OD,修改后右键复制到可执行文件，然后右键保存</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse5/image-20211011201009496.png" alt="image-20211011201009496"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse5/image-20211011203812041.png" alt="image-20211011203812041"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse5/image-20211011203847749.png" alt="image-20211011203847749"></p>
<p>4.拖进IDA反汇编,这个代码逻辑比较简单，wsad其实就是玩游戏的上下左右，</p>
<p>初始dword_408078=7,dword_40807c = 0,需要经过十四次移动修改两个变量为5和-4，按照迷宫题目的经验应该有地图或者字符。提取出来自己排列一下</p>
<p>flag{ssaaasaassdddw}</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse5/image-20211012094241147.png" alt="image-20211012094241147"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse5/image-20211012154856963.png" alt="image-20211012154856963"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse5/image-20211012154814391.png" alt="image-20211012154814391"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2021/10/11/paper/2020%E9%BB%91%E5%B8%BDDemystifying%20Modern%20Windows%20Rootkits%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/11/paper/2020%E9%BB%91%E5%B8%BDDemystifying%20Modern%20Windows%20Rootkits%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">2020黑帽Demystifying Modern Windows Rootkits学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-11 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-11T00:00:00+08:00">2021-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-22 15:57:00" itemprop="dateModified" datetime="2021-12-22T15:57:00+08:00">2021-12-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/paper-reading/" itemprop="url" rel="index"><span itemprop="name">paper reading</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>1.加载一个rootkit

2.与rootkit通信

3.采用合法的网络通信

4.作者写的一个示例rootkit以及其背后的设计选择

5.执行来自内核的命令

6.掩盖你的rootkit的文件系统踪迹的技巧
</code></pre>
<p>Rootkit是一种特殊的恶意软件，它的功能是在安装目标上隐藏自身及指定的文件、进程和网络连接等信息，比较多见到的是Rootkit一般都和木马、后门等其他恶意程序结合使用。Rootkit通过加载特殊的驱动，修改系统内核，进而达到隐藏信息的目的。</p>
<h3 id="Loading-a-Rootkit"><a href="#Loading-a-Rootkit" class="headerlink" title="Loading a Rootkit"></a>Loading a Rootkit</h3><p>1.利用合法的驱动。有很多脆弱的驱动，利用逆向知识，找到一个驱动的0day漏洞是很容易的。并且只需要几句原语即可提升权限，找到一个脆弱的驱动相对来说是简单的，因为兼容性的问题很难被检测。</p>
<p>缺点：跨操作系统版本的兼容性的主要问题取决于所拥有的原语；最有可能的是稳定性问题；最后一件事是你的恶意软件使得受害者蓝屏。</p>
<p>2.买证书。买一个合法的证书就没有稳定性的问题了，但是可能会揭露自己的身份以及会被拉进黑名单。</p>
<p>3.利用已经泄露的证书。这种方式相比购买证书来说更安全，但是在未来可能被检测，并且根据证书发布时间是有操作系统版本限制的。</p>
<h3 id="Communicating-with-a-Rootkit"><a href="#Communicating-with-a-Rootkit" class="headerlink" title="Communicating with a Rootkit"></a>Communicating with a Rootkit</h3><p>1.发给C2服务器。防火墙可以阻止或标记对未知/可疑IP地址或端口的传出请求，先进的网络检查可以捕捉到一些试图“融入噪音”的外渗技术。</p>
<p>2.打开一个端口。一些恶意软件通过C2直接连接到受害者主机来控制它。这样设置相对简单。但是可能会被防火墙发现，并且很难融入噪声。</p>
<p>3.应用程序Hooking技术。更高级的恶意软件可能会选择hook一个特定的应用程序的通信作为一个通信通道。这样就很难被检测，特别是如果用的是合法的协议，但是这样不是特别灵活，机器可能没有暴露出该服务。</p>
<p>我们想要的是有限的检测向量，各种环境下的灵活性，假设受害主机会有一些已经揭露出来的服务，入站和出站访问可能被监控。那么第三种方法非常符合我们的需求，除了灵活性。现在要考虑的是如何不依赖一个应用程序。</p>
<p>如果不直接hook一个应用程序，那么我们hook像wireshark这样的工具的网络通信；在恶意数据包中放置一个特殊的指示器（一个”magic”常数）；将这些恶意数据包发送到受害者机器上的合法端口；搜索这个常数的数据包，以将数据传递给我们的恶意软件.</p>
<h3 id="Hooking-the-User-Mode-Network-Stack"><a href="#Hooking-the-User-Mode-Network-Stack" class="headerlink" title="Hooking the User-Mode Network Stack"></a>Hooking the User-Mode Network Stack</h3><h4 id="hook-Windows-Winsock-driver"><a href="#hook-Windows-Winsock-driver" class="headerlink" title="hook Windows Winsock driver"></a>hook Windows Winsock driver</h4><p>在用户模式下windows上的许多服务都可以被发现，但是如何全面地获取这些流量是一个问题。与winsock相关的网络是由Afd.sys处理的，mswsock.dll用NtDeviceIoControlFiles实现与Afd.sys驱动的通信。逆向分析在mswsock.dll中的一些函数显示大量的通信是由IOCTLs完成的，如果我们可以拦截到这些请求，我们可以窥探所收到的数据。</p>
<p>\1. 在拦截之前要知道Irps是怎么走的，当对一个设备调用文件句柄上的NtDeviceIoControlFile函数时，内核如何确定要调用什么函数？</p>
<p>首先通过IoGetRelatedDeviceObject检索与Afd驱动程序相关联的设备(检索FILE_OBJECT结构中的DeviceObject成员)，然后判断驱动是否支持FastIo（在进行基于IRP 为基础的接口调用前, IO MANAGER 会尝试使用FAST IO 接口来加速各种IO 操作），如果支持那么就调用DriverObject-&gt;FastIoDispatch，如果不支持，那么就分配并填写Irp，然后调用IoCallDriver来发送Irp，对于IoCallDriver，内核将通过在DRIVER_OBJECT结构的MajorFunction数组中查找Irp内部指定的“Major function Code”来确定调用哪个函数</p>
<p>\2. 这里有拦截Irps的两种常见方法。替换掉驱动对象中你想hook的主函数；直接对调度处理程序执行代码hook。</p>
<p>\3. 要选择hooking最好的方法，要考虑的问题（可能有的检测向量有多少种，方法如何可用，检测这种方法昂贵吗）</p>
<p><strong>Hook驱动对象</strong>：memory artifacts；对于稳定性，通过用互锁交换替换单个函数，这种方法应该是稳定的。对于兼容性，驱动程序对象有很好的文档记录，并且易于找到；但是检测起很便宜，所有的防病毒软件都需要枚举已加载的驱动程序，并检查主要功能是否在驱动程序的范围内。</p>
<p><strong>Hook驱动程序的调度函数</strong>：memory artifacts；除非函数被导出，否则需要自己找到函数，由于补丁保护程序，并不是所有的驱动程序都与此方法兼容，HVCI不兼容的；检测也比较便宜。</p>
<p><strong>Hook文件对象：</strong>没有被文档化；稳定；检测成本相对昂贵，反病毒软件必须复制我们的连接过程，并枚举文件对象，以确定设备/驱动程序对象是否被交换。。</p>
<p><strong>Hook文件对象</strong></p>
<pre><code>1.创建我们自己的设备对象和驱动程序对象。 

2.修补驱动程序对象的副本。 

3.用我们自己的设备替换我们文件对象的DeviceObject指针
</code></pre>
<p><strong>首先</strong>我们需要获得Afd设备的文件对象，我们可以通过<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/sysinfo/zwquerysysteminformation">ZwQuerySystemInformation</a>函数，特别是使用SystemHandleInformation信息类来查询系统上的每个打开句柄。此信息类将为每个句柄返回以下结构：</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/wps2D3A.tmp.jpg" alt="img"> </p>
<p>有了这些信息我们需要判断句柄是否是Afd设备的。首先通过比较ObjectTypeNumber成员与已知的文件对象类型索引来判断该句柄是否是一个文件对象的，然后我们再将FILE_OBJECT结构的DeviceObject成员与一致的Afd设备比较。</p>
<p><strong>然后</strong>我们需要创建我们自己的假的驱动或者设备对象。Windows内核使用ObCreateObject函数来创建对象，内核大概是为了允许其他Windows驱动创建他们自己的对象，导出了该函数。</p>
<p>最后我们需要hook我们的假的驱动对象，可以用前面提到过的方法，将DRIVER_OBJECT结构中的MajorFunctions数组部分替换为我们的hook函数，（要注意我们要hook的是我们自己创建的驱动对象，而不是真正的驱动对象），</p>
<p>最后一步就是将FILE_OBJECT的DeviceObject成员替换成我们自己的设备。</p>
<p>现在文件对象被Hook了，对IoGetRelatedDeviceObject的任何调用都将返回我们的假设备，IoCallDriver将使用该设备调用我们的补丁MajorFunctions数组。</p>
<p>剩下的工作：检查我们是都正在hook被调用的MajorFunction，如果是，则调用为该主函数传递原始设备对象和原始调度函数的hook函数；确保当MajorFunction是IRP_MJ_CLEANUP时保存了原始的DeviceObject。</p>
<h3 id="How-the-Spectre-Rootkit-Abuses-the-User-Mode-Network-Stack"><a href="#How-the-Spectre-Rootkit-Abuses-the-User-Mode-Network-Stack" class="headerlink" title="How the Spectre Rootkit Abuses the User-Mode Network Stack"></a>How the Spectre Rootkit Abuses the User-Mode Network Stack</h3><h4 id="Abusing-the-Network"><a href="#Abusing-the-Network" class="headerlink" title="Abusing the Network"></a>Abusing the Network</h4><p>有了前一步的hook，现在我们已经可以拦截Afd驱动的Irps了。并且我们可以拦截所有用户模式的网络流量，通过任何套接字发送和接收我们自己的数据。</p>
<h4 id="Packet-Structure"><a href="#Packet-Structure" class="headerlink" title="Packet Structure"></a>Packet Structure</h4><p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/wps2D4A.tmp.jpg" alt="img"> </p>
<h4 id="Processing"><a href="#Processing" class="headerlink" title="Processing"></a>Processing</h4><p>收到数据包后先对数据包的magic constant部分进行判断。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/wps2D4B.tmp.jpg" alt="img"> </p>
<p>在发出包之前，我们需要创建一个完整的数据包</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/wps2D4C.tmp.jpg" alt="img"> </p>
<h4 id="Packet-Handlers"><a href="#Packet-Handlers" class="headerlink" title="Packet Handlers"></a>Packet Handlers</h4><p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/wps2D4D.tmp.jpg" alt="img"> </p>
<p>其他数据包处理程序继承这个基类。在上面的类中需要注意的两个关键问题是，调度器不仅会在处理程序的构造函数中传递指向自身的指针，而且实际的数据包将被传递给数据包处理程序的ProcessPacket函数。</p>
<p>一旦数据包被填充完，process handler会采取以下步骤</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/wps2D4E.tmp.jpg" alt="img"> </p>
<p>通过将一个指针传递给相关的包处理程序，该包处理程序可以递归地处理一个新的包。示例XorPacketHandler：</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/wps2D4F.tmp.jpg" alt="img"> </p>
<p>此XOR_PACKET实际上并不执行恶意操作。相反，它充当了一个封装的数据包。当Xor软件包处理程序收到一个数据包时，它将使用XorKey消除XorContent；递归地将XorContent分派为一个新的数据包。</p>
<p>该模型允许您创建无限的封装层。</p>
<h4 id="Executing-the-Commands"><a href="#Executing-the-Commands" class="headerlink" title="Executing the Commands"></a>Executing the Commands</h4><p>首先我们需要了解从用户模式上下文执行命令的过程</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/wps2D50.tmp.jpg" alt="img"> </p>
<p>关于内核模式，让我们从创建获取输出所需的管道开始，下面是创建管道在后台所做的事情。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/wps2D51.tmp.jpg" alt="img"> </p>
<p>现在我们有了管道，我们需要创建实际的流程。我们将使用ZwCreateUserProcess，因为这是kernelbase.dll使用自己来创建进程的方法。</p>
<p>我们需要从从进程的属性列表开始，我们必须设置的最重要的属性是PsAttributeImageName。这将指定新进程的映像文件名。</p>
<p>接下来我们需要为进程填充RTL_USER_PROCESS_PARAMETERS结构，主要填充参数有窗口标志和输出到我们的管道的句柄，当前目录、命令行参数、进程映像路径和默认的桌面名称。</p>
<p>然后我们就可以用ZwCreateUserProcess开启进程了，一旦进程退出，类似于我们在用户模式下所做的事情，我们可以调用ZwReadFile来从未命名的管道中读取输出。</p>
<h3 id="Hiding-a-Rootkit"><a href="#Hiding-a-Rootkit" class="headerlink" title="Hiding a Rootkit"></a>Hiding a Rootkit</h3><h4 id="MiniFilter"><a href="#MiniFilter" class="headerlink" title="MiniFilter"></a>MiniFilter</h4><p>微过滤驱动通过过滤管理驱动进行注册来实现拦截特定文件I/O.</p>
<p>Minifilter可以用于掩盖我们的根工具包在文件系统上的存在。它可以将某一文件的所有文件访问权限定向到另一个文件。我们可以使用此功能将对驱动程序文件的访问重定向到另一个合法的驱动程序。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/wps2D52.tmp.jpg" alt="img"> </p>
<p>利用MiniFilter最简单的方法就是自己成为一个MiniFilter,这个方法的检测向量主要是注册表和内存痕迹，不用担心稳定性和实用性，但是检测比较便宜，除了注册表工件之外，注册为MiniFillter的驱动程序也可以通过FltEnumerateFilters等API轻松枚举。</p>
<p>第二个方法是Hook一个MIniFilter，有三种方式，第一种是代码Hook现有的过滤器的回调；第二种是在受害驱动程序使用FLT_REFISTRATION结构体获得你自己的回调之前重写该结构；第三种是DKOM（直接<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1">内核对象</a>操作技术）一个现有的过滤器实例，并用您的替换原始回调。第一种方式虽然简单，但是有很多缺点。对于第三种方式，这是一种半文档化的方法，可以通过FltEnumerateFilters和FltEnumerateInstances这两个API枚举过滤器和实例，为某个操作调用的函数在FLT_INSTANCE结构中的CallBackNodes数组中指定。这种方式会有内存痕迹，对于稳定性来说，虽然获得一个FLT_INSTANCE结构是文档化的，但是FLT_INSTANCE结构它自己不是文档化的，并且检测并不昂贵，反病毒软件需要偶尔枚举注册的过滤器在CallBackNodes数组中的钩子及其实例。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/wps2D53.tmp.jpg" alt="img"> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2021/10/10/sample/Dissecting%20APT21%20samples%20using%20a%20step-by-step%20approach/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/10/sample/Dissecting%20APT21%20samples%20using%20a%20step-by-step%20approach/" class="post-title-link" itemprop="url">Dissecting APT21 samples using a step-by-step approach</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-10 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-10T00:00:00+08:00">2021-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-22 14:56:51" itemprop="dateModified" datetime="2021-12-22T14:56:51+08:00">2021-12-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">样本分析</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在这篇博文中，详细分析了与名为 APT21 的 APT（高级持续威胁）攻击者相关联的恶意文件（称为“Travelnet”的后门）。 </p>
<h3 id="Travelnet"><a href="#Travelnet" class="headerlink" title="Travelnet"></a>Travelnet</h3><p>第一个文件是用于将恶意 DLL（NetTraveler 木马）注册为服务的投放程序。 该木马的主要目的是收集有关环境的信息，例如用户名、主机名、主机的 IP 地址、Windows 操作系统版本、CPU 的不同配置、有关内存消耗的信息、进程列表。 </p>
<p>恶意进程对磁盘以及 USB 驱动器和网络共享上的.doc/.docx/.xls/.xlsx/.txt/.rtf/.pdf 文件感兴趣，以便渗漏它们。在整个感染过程中，会创建多个.ini 配置文件，并且恶意软件还能够在受感染的机器上下载和执行其他文件。数据使用基于Lempel-Ziv的自定义算法进行压缩，并使用修改后的 Base64 算法进行编码，然后再将其泄露到命令和控制服务器。</p>
<h3 id="1-Dropper"><a href="#1-Dropper" class="headerlink" title="1.Dropper"></a>1.Dropper</h3><p>恶意软件执行的第一步包括创建名为“立即安装服务”的互斥锁（注意空格）。互斥锁用于避免已感染的计算机再次感染</p>
<pre><code>API:CreateMutexA
</code></pre>
<p>创建一个配置文件config_t.dat，配置文件由WritePrivateProfileStringA填充</p>
<pre><code>API:CreateFileA

    WritePrivateProfileStringA
</code></pre>
<p>在恶意代码的精确位置发现加密字节，加密包含了XOR操作，解密结束后发现是URL（C2服务器）</p>
<p>注意在文件0x334偏移处有一字节表示恶意软件是否用代理，如果是0，配置文件中UP=0,如果是1，UP=1，并且还有PS (proxy address), PP (proxy port), PU (proxy user), PW (proxy password), PF (unknown)</p>
<p>RegQueryValueExA该函数用来搜索与“HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows NT\CurrentVersion\Svchost”相关联的netsvcs(svchost.exe)的类型和数据</p>
<pre><code>API:RegQueryValueExA
</code></pre>
<p>恶意文件枚举主机上所有可用的服务，将其与硬编码列表中的进行比较，第一个系统上没有的服务便被用来当作恶意目的。策略：枚举所有服务相对应的键值，查看服务是否被安装。第一个没被安装的服务是FastUserSwitchingCompatibility, RegOpenKeyExA 用于检查服务是否存在。</p>
<p>与该服务相关联的dll将被删除，然后一个同名服务将被创建冒充为合法服务，服务的二进制路径为%SystemRoot%\System32\svchost.exe-k netsvcs，可以在网址<a target="_blank" rel="noopener" href="https://lolbas-project.github.io/%E6%9F%A5%E7%9C%8B%E5%88%B0%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%90%88%E6%B3%95%E8%BF%9B%E7%A8%8B%E5%92%8Cdll%E3%80%82">https://lolbas-project.github.io/查看到更多的合法进程和dll。</a></p>
<pre><code>API:RegOpenKeyExA

    DeleteFileA

    CreateServiceA
</code></pre>
<p>在该服务下方一个新的键值parameters被创建，这个键值被用来将恶意dll注册为一个服务.</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample4/wpsEE81.tmp.png">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample4/wpsEE81.tmp.png</a>) </p>
<p>进程创建一个temp.bat的空文件作为初始可执行文件，该文件的目的是通过添加ServiceDll条目，将前面恶意程序删除后重新创建的dll注册为服务。因为文件时重新创建的，所以为了不引起怀疑，<strong>修改时间戳是一种规避技术。</strong></p>
<p>现在这个dll中都是恶意代码，甚至路径看起来都是合法的。<strong>将DLL文件注册为服务是一种持久性机制。</strong>使用StartServiceA启动新创建的服务，并将执行流传递给DLL导出函数ServiceMain：</p>
<pre><code>API:RegCreateKeyA

    WriteFileA

    StartServiceA
</code></pre>
<h3 id="2-DLL-File"><a href="#2-DLL-File" class="headerlink" title="2.DLL File"></a>2.DLL File</h3><p>恶意软件执行的第一个步骤之一是调用GetProcessWindowsStation，该API返回当前窗口的句柄，然后使用OpenWindowsStationA打开交互式窗口Winsta0。进程使用setProcessWindowsStation函数将指定的窗口Winsta0分配给调用进程，该窗口是唯一的交互式窗口（服务应该是交互式的）。与之前一样，这个进程也会创建一个互斥锁，如果存在，将会退出而不重新感染主机。</p>
<pre><code>API:GetProcessWindowsStation

    OpenWindowsStationA

    setProcessWindowsStation

    CreateMutexA
</code></pre>
<p>它从由第一个进程创建的配置文件config_t.dat中检索几个元素：WebPage、DownCmdTime、UploadRate、AutoCheck、UP和CheckedSuccess（此时不存在，因此函数返回0）。使用GetPrivateProfileString和GetPrivateProfileInt提取所有值。</p>
<pre><code>API:GetPrivateProfileString

    GetPrivateProfileInt
</code></pre>
<p>进程会创建一个与执行文件同名的log文件，该文件会枚举C:\ProgramFile(x86) 下的路径，并将输出复制到新创建的文件中</p>
<pre><code>API:CreateFileA
</code></pre>
<p>恶意软件正在查找名为“C:\Users&lt;Username&gt;\AppData\Local\Microsoft\Windows\History\History.IE5\index.dat”的文件，该文件包含Internet浏览历史活动，包括基于Internet的搜索和打开的文件.故恶意软件打开注册键Shell Folders并提取History值，以及从Internet Explorer键中提取Version值，获得的信息附加到log文件中（包括操作系统版本）</p>
<pre><code>API:RegOpenKeyExA

    RegQueryValueExA

    GetVersionExA
</code></pre>
<p>网络通信中使用的用户代理始终设置为“Mozilla/4.0（compatible; MSIE 6.0）”。还有一个Accept 请求HTTP标头。该进程尝试连接到<a target="_blank" rel="noopener" href="http://www.microsoft.com/info/privacy_security.htm">http://www.microsoft.com/info/privacy_security.htm</a> （此URL过去可用）以验证是否存在网络连接，如果成功，也会把相应的信息输出到log文件。</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample4/wpsEE82.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample4/wpsEE82.tmp.jpg</a>) </p>
<pre><code>API:InternetOpenA

    HttpOpenRequestA
</code></pre>
<p>如果连接不成功，进程会找到explorer.exe并试图打开。基本上，攻击者的目的是<strong>通过调用OpenProcessToken来窃取explorer.exe进程令牌，以打开与explorer.exe关联的访问令牌，然后使用ImpersonateLoggedOnUser函数模拟用户的安全上下文</strong>。</p>
<pre><code>API:Process32First 

    Process32Next

    OpenProcess

    OpenProcessToken

    ImpersonateLoggedOnUser
</code></pre>
<p>该进程使用RegOpenKeyExA打开“HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Internet Settings”注册表项，然后提取ProxyEnable值以查看计算机是否使用代理服务器，并且提取ProxyServer(网络上代理服务器的主机名/IP)和ProxyOverride(绕过代理服务器的主机名/IP)。收集到这些信息后，再次连接同样地URL，成功后会将信息输出到log文件。</p>
<pre><code>API:RegOpenKeyExA
</code></pre>
<p>如果该方法奏效，恶意程序会修改config_t.dat文件中地值，如果失败就会将失败信息记录在log文件，一共会尝试四次方法。如果所有方法都失败了，感染就会停止，并且会执行一些自我删除操作。</p>
<p>如果有一个方法奏效，那么恶意软件会休眠一分钟，然后创建一个线程1，再休眠十秒创建一个线程2</p>
<h4 id="2-1-Thread1"><a href="#2-1-Thread1" class="headerlink" title="2.1 Thread1"></a>2.1 Thread1</h4><p>首先，线程检索与“C:\”目录关联的卷序列号（“A2C9-AD2F”）。该序列号将用作与C2服务器通信时的主机id。此外，它还查找计算机的NETBIOS名称，与当前线程关联的用户名，检索计算机的主机名，使用gethostbyname/inet\n函数打印计算机的IP地址。枚举可用的磁盘驱动器，它感兴趣的是类型3。获取系统物理和虚拟内存，除此以外还获取了其他的键值信息，并将目前为止提取地信息存储在system_t.dll中，以便对其进行过滤。</p>
<p>下一步是<strong>创建管道，用作进程间通信机制，创建一个新的进程“ipconfig/all”,输出将通过管道传输回原始流程。</strong></p>
<pre><code>API:getVolumeInformation

    GetComputerNameA

    GetUserNameA

    gethostname

    GetLogicalDrivers

    GetDriverTypeA

    GlobalMemoryStatus

    CreatePipe

    CreateProcessA

    ......
</code></pre>
<p>恶意软件使用GetPrivateProfileInt函数检查config_t.dat中的UP值。根据卡巴斯基报告，system_t.dll文件的内容将使用基于Lempel-Ziv的自定义算法进行压缩，并使用修改后的Base64算法进行编码。</p>
<p>编码后地数据通过一个向vipmailru[.]com（C2服务器）的GET请求进行过滤。如果服务器返回成功，那么就过滤成功，恶意程序会删除system_t.dll文件，进程会执行另一个GET请求（参数包含action = getcmd），请求的结果有相应的开头和结束的格式，在开头结束中间的数据会被保存在stat_t.ini。进程会再执行一个GET请求（参数包含action = gotcmd）</p>
<p>如前所述，如果一切正常，则文件需要包含“Success”字符串的HTTP响应。进程正在删除一个名为“C:\Windows\SysWOW64\dnlist.ini”的文件，该文件目前不存在。该文件将创建，并使用以下数据填充该文件：</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample4/wpsEE83.tmp.png">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample4/wpsEE83.tmp.png</a>) </p>
<p>删除文件stat_t.ini，然后调用GetACP，该API返回操作系统的当前Windows ANSI代码页标识符。因为在dnlist.ini中ScanAll的值为True，所以恶意软件扫描所有可用的磁盘驱动器，然后将它们的类型与3（固定驱动器）或4（远程驱动器）进行比较。枚举所有文件以及路径，路径记录命名为dn，文件命名为fn，如下图，保存在enumfs.ini。这样针对c:\的操作是递归的，并应用于每个目录。枚举完成后发送给服务器。</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample4/wpsEE84.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample4/wpsEE84.tmp.jpg</a>) </p>
<pre><code>API:GetLogicalDrivers

    GetDriverTypeA
</code></pre>
<p>恶意进程试图打开目前不存在的uenumfs.ini，然后枚举在“C:\User<Username>\AppData\Local\Temp\ntvba00.tmp\”中找到的文件。此特定目录将由Thread2创建，并包含已选择要导出到C2服务器的所有文件。现在该进程再次使用参数“action=getdata”联系 C2 服务器。 它需要以下响应之一：“A2C9AD2F:UNINSTALL”、“A2C9AD2F:UPDATE”、“A2C9AD2F:RESET”或“A2C9AD2F:UPLOAD”（注意“A2C9AD2F”是之前提取的卷序列号）</p>
<p><strong>Case1：UNINSTALL</strong></p>
<p>删除相应键值，并且删掉enumfs.ini、dnlist.ini、udidx.ini、uenumfs.ini、stat_t.ini文件，C2服务器通过执行带有“action=updated”参数的GET请求得知操作已完成。</p>
<p><strong>Case2：UPDATE</strong></p>
<p>删除上述的同样的键值以及文件，使用“action=datasize”参数向C2服务器发出GET请求，如果一切正常,HTTP响应应包括“Success:”.恶意软件会下载一个update.exe的文件。</p>
<p>下载文件的字节与“MZ”（Windows中可执行文件、DLL文件的格式）进行比较，并且它还查找特定偏移量处的“PE”字符串。下载的文件保存为“C:\Windows\install.exe”，并由恶意进程运行。然后执行同样的GET请求表示操作已完成。</p>
<p><strong>Case3：RESET</strong></p>
<p>同样删除ini文件，然后执行同样的GET请求表示操作已完成。</p>
<p><strong>Case4：UPLOAD</strong></p>
<p>此情况与UPDATE相同，不同之处在于未删除任何文件/注册表项。</p>
<p>在执行流通过所有案例后，流程休眠60秒，然后返回到循环中。</p>
<h4 id="2-2-Thread2"><a href="#2-2-Thread2" class="headerlink" title="2.2 Thread2"></a>2.2 Thread2</h4><p>主要是一些窗口的操作，恶意软件对参数为DBT_DEVICEARRIVAL（0x8000）的WM_DEVICECHANGE（0x219）消息感兴趣，<strong>这意味着有插入了新的USB驱动器或系统上安装了网络共享文件夹这样的事件</strong>。</p>
<p>从dnlist.ini解析的USearch和UTypeLimit值应设置为True，dnlist.ini中的UAuto值也应设置为False（这可能表明是否应自动过滤目标文件）。攻击者还对Types参数（目标扩展）感兴趣，稍后我们将了解原因。其想法是<strong>扫描插入的每个设备以及主机上安装的网络共享，并在uenumfs.ini文件中创建一个“文件系统”结构（就像在Thread1中所做的那样）</strong></p>
<p>与第一种情况一样，此搜索将递归地应用于驱动器上找到的每个目录。该进程创建一个“C:\Users&lt;Username&gt;\AppData\Local\Temp\ntvba00.tmp\”目录，其属性设置为hidden。还将创建以下文件：“C:\Windows\SysWOW64\uenumfs.ini”（其内容将类似于enumfs.ini）。进程还会比较文件的后缀，并且为符合文件格式的文件计算一个HASH值（文件名和最后修改时间）。文件会被复制到tmp的文件夹下，并以新的文件名命名（hidden file–year-month-day-hour-minute-5f7a78e7927532ba2a930ec8d47e252a）</p>
<p>该进程将创建“C:\Windows\SysWOW64\udidx.ini”文件，并将添加所有按照前面说明计算的哈希，新文件的最后修改时间戳设置为从初始文件提取的值。</p>
<p>最后，该文件使用DefWindowProcA API来确保应用程序不处理的窗口消息具有默认处理功能。</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a target="_blank" rel="noopener" href="https://cybergeeks.tech/dissecting-apt21-samples-using-a-step-by-step-approach/">https://cybergeeks.tech/dissecting-apt21-samples-using-a-step-by-step-approach/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2021/09/15/wkp/Chapter%206%20kernel%20Mechanisms/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/15/wkp/Chapter%206%20kernel%20Mechanisms/" class="post-title-link" itemprop="url">Chapter 6 kernel Mechanisms</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-15 00:00:00" itemprop="dateCreated datePublished" datetime="2021-09-15T00:00:00+08:00">2021-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-22 12:56:32" itemprop="dateModified" datetime="2021-12-22T12:56:32+08:00">2021-12-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">驱动开发</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="中断请求级别（IRQL）"><a href="#中断请求级别（IRQL）" class="headerlink" title="中断请求级别（IRQL）"></a>中断请求级别（IRQL）</h3><p>前面提到了线程和线程的优先级，当想要执行的线程比可用的处理器更多时，就会考虑到这些优先级。同时，硬件设备需要通知系统有什么事情需要注意。一个简单的例子是由磁盘驱动器执行的I/O操作。一旦操作完成，磁盘驱动器将通过请求中断来通知完成。此中断连接到中断控制器硬件，该硬件随后将请求发送到处理器进行处理。下一个问题是，哪个线程应该执行关联的中断服务例程(ISR)？</p>
<p>每个硬件中断都与一个优先级相关，称为中断请求级(IRQL)。每个处理器的上下文都有自己的IRQL，就像任何寄存器一样。IRQL应该像任何其他CPU寄存器一样被处理。</p>
<p>其基本规则是，处理器要执行具有最高IRQL的代码。例如，如果一个CPU的IRQL在某个点为零，并且会出现一个相关IRQL为5的中断；将其状态（上下文）保存在当前线程的内核堆栈中，将其IRQL提升到5，然后执行与中断关联的ISR；一旦ISR完成，IRQL将降到它以前的级别，恢复之前执行的代码，就好像中断不存在一样。当ISR正在执行时，其他IRQL为5或更少的中断不能中断该处理器。但是，如果新中断的IRQL高于5，CPU将再次保存其状态，将IRQL提升到新级别，执行与第二个中断相关的第二个ISR，完成后，将回落到IRQL5，恢复其状态并继续执行原始ISR。本质上，只是暂时提高与IRQL相等或较低的IRQL块代码。中断发生时事件的基本序列。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/wkp6/wps697F.tmp.jpg" alt="img"> </p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/wkp6/wps6980.tmp.jpg" alt="img"> </p>
<p>上面两个图描述的场景种，所有ISR的执行都是由首先被中断的同一线程完成的。Windows没有一个特殊的线程来处理中断；它们都由当时在被中断的处理器上运行的任何线程来处理。当处理器的IRQL为2或更高时，上下文切换是不可能的，所以在这些ISR执行时，其他线程无法偷偷溜进来。</p>
<p>下面有一些重要的IRQL:</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/wkp6/wps6991.tmp.jpg" alt="img"> </p>
<p>其中Device IRQL用于硬件中断的一系列级别（x64/ARM/ARM64为3至11，x86为3至26）。最高级别HIGH_LEVEL被处理链表操作的一些API所使用。实际值分别为15（x64/ARM/ARM64）和31（x86）。</p>
<p>当处理器的IRQL被提高到2或更高时，都会对执行代码施加某些限制：</p>
<p>访问非物理内存中的内存是致命的，会导致系统崩溃。这意味着从非分页池访问数据总是安全的，而从分页池或用户提供的缓冲区访问数据则不安全，应该避免。</p>
<p>等待任何调度程序内核对象（例如互斥锁或事件）会导致系统崩溃，除非等待超时为零，这仍然是允许的。</p>
<h4 id="提升或降低IRQL"><a href="#提升或降低IRQL" class="headerlink" title="提升或降低IRQL"></a>提升或降低IRQL</h4><p>在内核模式下，IRQL可以用KeRaiseIrql函数来提高，然后用KeLowerIrql来降低。下面是一个代码片段，它将IRQL提升到DISPATCH_LEVEL（2），然后在这个IRQL上执行一些指令后将其降低回来。(**note:**如果您提高了IRQL，请确保您在相同的函数中降低了它。此外，确保KeRaiseIrql实际上提高了IRQL，KeLowerIrql实际上降低了它；否则，系统就会崩溃。)</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/wkp6/wps6992.tmp.jpg" alt="img"> </p>
<h4 id="线程优先级vsIRQL"><a href="#线程优先级vsIRQL" class="headerlink" title="线程优先级vsIRQL"></a>线程优先级vsIRQL</h4><p>IRQL是一个处理器的一个属性。优先级是一个线程的一个属性。线程优先级仅在IRQL&lt;2上有意义。一旦一个正在执行的线程将IRQL提高到2或更高，它的优先级就不再意味着任何东西。理论上它将继续执行，直到它将IRQL降低到2以下。</p>
<h4 id="延迟过程调用"><a href="#延迟过程调用" class="headerlink" title="延迟过程调用"></a>延迟过程调用</h4><p>延迟过程调用(DPC)是[Windows](<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Microsoft">https://baike.baidu.com/item/Microsoft</a> Windows/3304184)的机制，允许高优先级任务如中断处理程序延迟所需的低优先级任务稍后执行。这使得<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/310766">设备驱动程序</a>与其他低层事件消费者更快地执行其处理的高优先级部分，调度非关键的附件处理稍后以较低优先级执行。</p>
<p>用一个实例说明一下</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/wkp6/wps6993.tmp.jpg" alt="img"> </p>
<p>用户模式线程将打开一个文件的句柄，并使用ReadFile函数执行读取操作。由于该线程可以进行异步调用，因此它几乎会立即恢复控制，并可以执行其他工作。接收此请求的驱动程序调用文件系统驱动程序(例如NTFS)，它可以调用它下面的其他驱动程序，直到请求到达磁盘驱动程序，该驱动程序在实际的磁盘硬件上启动操作。</p>
<p>当硬件完成读取操作时，它会发出一个中断。这将导致与该中断相关联的ISR在Device IRQL上执行（请注意，处理该请求的线程是任意的，因为该中断是异步到达的）。一个典型的ISR会访问设备的硬件，以获得操作的结果。它的最后操作应该是完成最初的请求。</p>
<p>完成请求是通过调用IoCompleteRequest。但是有一个问题是该函数只能在IRQL&lt;= DISPATCH_LEVEL(2)的情况下被调用，这一位置ISR不能调用该函数，那么ISR做什么呢？</p>
<p>允许ISR尽快调用IoCompleteRequest（以及其他具有类似限制的函数）的机制是<strong>延迟过程调用(DPC)。DPC是一个用于封装函数的对象，封装的函数函数在IRQL DISPATCH_LEVEL调用。</strong>在这个IRQL中，允许调用IoCompleteRequest。</p>
<p>DPC是通过DPC对象实现的。当设备驱动程序或其他内核态程序发出DPC请求时，操作系统内核创建DPC对象，投寄到DPC队列尾部。当Windows操作系统的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IRQL">IRQL</a>降低到Dispatch/DPC级，操作系统检查DPC队列，逐个执行挂起的DPC，直至队列为空或者发生IRQL更高的中断。</p>
<p>注册了ISR的驱动程序提前准备了一个DPC(从非分页池分配KDPC结构，并使用回调函数KeInitializeDpc初始化它)；然后，当调用ISR时，就在退出该函数之前，ISR请求DPC通过KeInsertQueueDpc排队来尽快执行它。当DPC函数执行时，它会调用IoCompleteRequest。所以DPC作为一种妥协——它运行在IRQL DISPATCH_LEVEL(2)上，这意味着不会发生调度，没有分页内存访问，等等。</p>
<p>Note:默认情况下，KeInsertQueueDpc将DPC排队到当前处理器的DPC队列。<strong>当ISR返回时</strong>，在IRQL可以降回到零之前，将检查在处理器的队列中是否存在DPC。如果有，处理器下降到IRQLDISPATCH_LEVEL（2），然后以FirstInFirstOut(FIFO)的方式处理队列中的DPC，调用各自的函数，直到队列为空。只有这样，处理器的IRQL才能降至零，并恢复执行在中断到达时被干扰的原始代码。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/wkp6/wps6994.tmp.jpg" alt="img"> </p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/wkp6/wps6995.tmp.png" alt="img"> </p>
<h4 id="异步过程调用"><a href="#异步过程调用" class="headerlink" title="异步过程调用"></a>异步过程调用</h4><p>APCs也是封装要调用的函数的数据结构，但是与DPC相反，APC的目标是特定的线程，因此只有该线程才能执行该函数。这意味着每个线程都有一个与其关联的APC队列。</p>
<p>有几种类型的APC:</p>
<p>用户模式APCs:只有当线程进入可警报状态时，这些操作才会在IRQLPASSIVE_LEVEL的用户模式下执行。这通常是通过调用一个API来实现的，如SleepEx,WaitForSingleObjectEx, WaitForMultipleObjectsEx和类似的API。可以将这些函数的最后一个参数设置为TRUE，以使线程处于可警报状态（等待状态）。在这种状态下，它会查看它的APC队列，如果不是空的，则APC执行，直到队列为空。</p>
<p>正常的内核模式APCs:这些操作在IRQL PASSIVE_LEVEL的内核模式下执行，抢占用户模式代码和用户模式APCs。</p>
<p>特殊的内核APCs：这些操作在IRQLAPC_LEVEL（1）的内核模式下执行，并抢占用户模式代码、普通内核APCs和用户模式APCs。输入/输出系统使用这些APCs来完成输入/输出操作。</p>
<h5 id="Critical-Regions-and-Guarded-Regions"><a href="#Critical-Regions-and-Guarded-Regions" class="headerlink" title="Critical Regions and Guarded Regions"></a>Critical Regions and Guarded Regions</h5><p>Critical Region阻止用户模式和正常的内核APC执行（特殊的内核APC仍然可以执行）。线程通过KeEnterCriticalRegion\KeLeaveCriticalRegion进入\离开一个关键区域。内核中的一些函数需要在一个关键区域内，特别是在使用执行资源时（请参阅本章后面的“执行资源”一节）。</p>
<p>Guarded Region可阻止所有APCs的执行。线程通过KeEnterGuardedRegion\KeLeaveGuardedRegion进入\离开一个保护区域。两个函数调用数量必须相同。</p>
<p>note:将IRQL提高到APC_LEVEL将禁用所有apc的交付。</p>
<h3 id="结构化异常处理（SEH）"><a href="#结构化异常处理（SEH）" class="headerlink" title="结构化异常处理（SEH）"></a>结构化异常处理（SEH）</h3><p>异常与中断有些相似，主要的区别是异常是同步的，并且在技术上具有可重复性。如果发生异常，内核会捕获此异常，并允许如有可能的代码处理异常。这种机制称为**结构化异常处理(SEH)**，可用于用户模式代码和内核模式代码。</p>
<p>内核异常处理程序是基于**中断调度表(IDT)**调用的，该表还支持中断向量和ISR之间的映射。</p>
<p>常见的异常：</p>
<p>Division by zero (0) ;</p>
<p>Breakpoint (3):内核透明地处理它，将控制件传递给附加的调试器;</p>
<p>Invalid opcode (6):如果CPU遇到未知指令，则会引发此故障;</p>
<p>Pagefault(14):如果用于将虚拟地址转换为物理地址的页面表条目将有效位设置为零，这表示(就CPU而言)该页面没有驻留在物理内存中，则CPU会引发此故障。</p>
<p>由于以前的CPU故障，内核还引发了其他一些异常。例如，如果引发了页面故障，则内存管理器的页面故障处理程序将尝试找到未驻留在RAM中的页面—如果该页面根本不存在，则内存管理器将引发访问冲突异常—一旦引发异常，内核将为处理程序搜索发生异常的函数（除了它透明处理的一些异常，如断点（3））—如果没有找到，它将向上搜索<strong>调用堆栈</strong>，直到找到这样的处理程序—如果调用堆栈已耗尽，则系统将会崩溃。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/wkp6/wps6996.tmp.jpg" alt="img"> </p>
<h4 id="try-except"><a href="#try-except" class="headerlink" title="__try/__except"></a>__try/__except</h4><p>下图是关于第四章的读取用户模式缓冲区的部分，如果因为缓冲区没有数据这样的错误，造成系统崩溃就不好了。Except中的EXCEPTION_EXECUTE_HANDLER表明任何一场都会被处理，也可以调用GetExceptionCode函数查看实际的异常，如果不能，可以告诉内核继续寻找调用堆栈上的处理程序：</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/wkp6/wps6997.tmp.jpg" alt="img"> </p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/wkp6/wps6998.tmp.jpg" alt="img"> </p>
<p>非法访问是只有当被禁止访问的地址在用户空间中时才能被捕获。如果它位于内核空间中，那么它将不会被捕获，并且仍然会导致系统崩溃。这应该是有意义的，因为已经发生了一些不好的事情，而且内核不会让驱动程序侥幸逃脱惩罚。另一方面，用户模式地址不受驱动程序的控制，因此可以捕获和处理这种异常。</p>
<p>驱动程序（和用户模式代码）也可以使用SEH机制来抛出自定义异常。内核提供了泛型函数ExRaiseStatus，以引发任何异常和一些特定的函数如ExRaiseAccessViolation。</p>
<h4 id="try-finally"><a href="#try-finally" class="headerlink" title="__try/__finally"></a>__try/__finally</h4><p>这是关于确保某些代码无论如何都能执行——代码是干净地退出还是由于异常而中途退出。SEH的异常结束处理模型主要由try-finally语句来完成。终止处理就是保证应用程序在一段被保护的代码发生中断后（无论是异常还是其他）还能够执行清理工作，清理工作包括关闭文件、清理内存等。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/wkp6/wps6999.tmp.jpg" alt="img"> </p>
<p>如上面的例子，如果在分配和释放之间由return语句或者有异常，那么资源将不会被释放，这个时候就需要用到__try/__finally，确保能执行释放操作。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/wkp6/wps699A.tmp.jpg" alt="img"> </p>
<p>这样的话即使__try结构中有return语句，也会在__finally区块调用完再返回。如果发生异常，__finally块首先运行，然后内核在调用堆栈中搜索处理程序。</p>
<h4 id="用c-RAII替代-try-finally"><a href="#用c-RAII替代-try-finally" class="headerlink" title="用c++ RAII替代__try/__finally"></a>用c++ RAII替代__try/__finally</h4><p>RAII（资源获取就是初始化），是C++语言的一种管理资源、避免泄漏的惯用法。C++标准保证任何情况下，已构造的对象最终会销毁，即它的析构函数最终会被调用。</p>
<h4 id="系统崩溃"><a href="#系统崩溃" class="headerlink" title="系统崩溃"></a>系统崩溃</h4><p>我们已经知道，如果在内核模式下发生未处理的异常，系统就会崩溃，通常是“死亡蓝屏”。在本节中，我们将讨论当系统崩溃时会发生什么，以及如何处理它。</p>
<p>BSOD是一种保护机制，如果泵应该被信任的内核代码做了一些无法预料的坏事，那么停止一切，避免一些重要的文件或者注册表项损坏，是最安全的方法。</p>
<p>如果系统崩溃，则可以将事件条目写入事件日志。<strong>最重要的设置是生成转储文件。</strong>转储文件会捕获崩溃时的系统状态，因此以后可以通过将转储文件加载到调试器中来进行分析。转储不是在崩溃时写入目标文件的，而是写入第一页文件的。只有当系统重新启动内核时，当系统注意到页面文件中存在转储信息时，它才会将数据复制到目标文件中。其原因与在系统崩溃时，将某些东西写入一个新文件可能太危险有关；系统可能不够稳定。最好的办法是将数据写入已经以任何方式打开的页面文件。缺点是，页面文件必须足够大，才能包含转储，否则将不会写入转储文件。内存转储主要有：小内存转储、内核内存转储、完整内存转储</p>
<p>、自动内存转储、灵活内存转储（win10+：这类似于一个完整的内存转储，除了如果崩溃的系统托管客户虚拟机，它们当时使用的内存不会被捕获。这有助于减少可能托管许多虚拟机的服务器系统上的转储文件大小。）</p>
<h5 id="崩溃dump信息"><a href="#崩溃dump信息" class="headerlink" title="崩溃dump信息"></a>崩溃dump信息</h5><p>一旦您有了崩溃转储，您可以通过选择文件/打开转储文件并导航到该文件，在WinDbg中打开它。</p>
<h5 id="分析一个dump文件"><a href="#分析一个dump文件" class="headerlink" title="分析一个dump文件"></a>分析一个dump文件</h5><p>~ns命令用来切换处理器，!running列出崩溃时在所有处理器上运行的线程,添加-t作为一个选项，将显示每个线程的调用堆栈。</p>
<p>!stacks命令列出了所有线程的所有线程堆栈。一个更有用的变体是一个搜索字符串，它只列出了包含该字符串的模块或函数出现的线程。这允许在整个系统中定位驱动程序的代码（因为它在崩溃时可能还没有运行，但它在某些线程的调用堆栈上）。</p>
<h4 id="系统挂起"><a href="#系统挂起" class="headerlink" title="系统挂起"></a>系统挂起</h4><p>系统崩溃是通常被调查的最常见的转储类型。但是，您可能需要使用另一种类型的转储文件：一个挂起的系统。一个挂起的系统是一个无响应的或接近无响应的系统。事情似乎在某种程度上被停止或被锁定——系统不会崩溃，所以我们要处理的第一个问题是如何转储系统？</p>
<p>Note：转储文件包含某些系统状态，它不必与崩溃或任何其他坏状态相关。有一些工具（包括内核调试器）可以随时生成转储文件。</p>
<h5 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h5><p>一个比较好的例子是一个驱动用链接列表去收集数据列表，因为该驱动程序可以被来自一个或多个进程中的多个线程的多个客户端调用，所以对于数据的访问操作涉及到了线程之间的同步互锁操作。</p>
<h5 id="互锁操作"><a href="#互锁操作" class="headerlink" title="互锁操作"></a>互锁操作</h5><p>互锁函数集提供了利用硬件原子执行的方便操作，这意味着不涉及软件对象。如果使用这些函数可以完成工作，那么应该使用它们，因为它们可以尽可能有效。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/wkp6/wps699B.tmp.jpg" alt="img"> </p>
<h5 id="调度对象"><a href="#调度对象" class="headerlink" title="调度对象"></a>调度对象</h5><p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/wkp6/wps699C.tmp.jpg" alt="img"> </p>
<p>Objects：指定要等待的对象。请注意，这些函数适用于对象，而不是句柄。如果您有一个句柄（可能由用户模式提供），请调用对象对象句柄以获取指向该对象的指针。</p>
<p>WaitReason：等待原因的列表很长，但是驱动程序通常应该将其设置为Executive，除非它因为用户请求而等待，如果是这样，请指定UserRequest。</p>
<p>WaitMode：大多数驱动程序应该指定KernelMode。</p>
<p>Alertable：指示线程是否处于可警报状态。可警报状态允许传递用户模式异步过程调用(APC)。如果等待模式为用户模式，则可以交付用户模式apc。大多数驱动程序都应该指定false。</p>
<p>Timeout：指定要等待的时间。如果指定了NULL，等待是无限的，只要对象成为信号。</p>
<p>Count：要等待运行的对象数。</p>
<p>Object[]：要等待的对象指针数组。</p>
<p>WaitType：指定是等待所有对象同时发出信号(WaitAll)还是仅等待一个对象(WaitAny)。</p>
<p>WaitBlockArray：内部用于管理等待操作的结构数组。如果对象的数量是&lt;=THREAD_WAIT_OBJECTS（当前为3），那么这是可选的——内核将使用每个线程中存在的内置数组。如果对象数量较高，驱动程序必须从非分页池中分配正确的结构大小，并在等待结束后解除它们。</p>
<p>KeWaitForSingleObject返回值：</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/wkp6/wps699D.tmp.jpg" alt="img"> </p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/wkp6/wps699E.tmp.jpg" alt="img"> </p>
<h5 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h5><p>互斥锁是许多可以随时访问共享资源的一个线程中的一个典型问题的经典对象。互斥锁在空闲时就会发出信号。一旦线程调用等待函数并满足等待，互斥锁就会变成无信号，线程就会成为互斥锁的所有者。</p>
<p>Note： 如果线程是互斥的所有者，它是唯一可以释放互斥的线程。</p>
<p>互斥锁可以通过同一线程多次获取。第二次尝试会自动成功，因为该线程是互斥锁的当前所有者。这也意味着线程需要以它所获得的相同的次数来释放互斥锁；只有这样，互斥锁才会再次获得自由（发出信号）。</p>
<p>使用互斥锁需要从非页面池中分配一个KMUTEX结构。</p>
<p>KeInitializeMutex必须调用一次初始化mutex；</p>
<p>等待函数之一传递已分配的KMUTEX结构的地址；</p>
<p>KeReleaseMutex：当作为互斥锁的所有者的一个线程想要释放它时，就会调用它。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/wkp6/wps69AF.tmp.jpg" alt="img"> </p>
<p>因为无论什么时候释放互斥锁都很重要，所以最好使用__tay/__finally，更方便的方式是c++的RAII。</p>
<h5 id="Fast-Mutex"><a href="#Fast-Mutex" class="headerlink" title="Fast Mutex"></a>Fast Mutex</h5><p>快速互斥体是典型的互斥锁的替代品，提供更好的性能。它不是一个调度对象，所以它有自己的获取和释放互斥锁的API。<strong>只能用于内核模式。</strong>与常规的互斥锁相比，它具有以下特征：</p>
<p>不能递归地获取一个Fast Mutex，这样做会导致死锁；</p>
<p>当获得Fast Mutex时，CPU IRQL被提升到APC_LEVEL（1），这将阻止任何APC传递到该线程；</p>
<p>Fast Mutex只能无限期地等待-没有办法指定超时。</p>
<p>Fast Mutex比常规Mutex速度稍快。<strong>事实上，大多数需要互斥锁的驱动程序使用</strong>Fast Mutex<strong>，除非有令人信服的理由使用常规</strong>Mutex.</p>
<p>结构体：FAST_MUTEX，函数：ExInitializeFastMutex、ExAcquireFastMutex、ExAcquireFastMutexUnsafe、ExReleaseFastMutex、ExReleaseFastMutexUnsafe。</p>
<h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>通常KeInitializeSemaphore初始化为最大值，当值大于零时，信号量为有信号。</p>
<h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><p>事件主要分为两种：需要手动重置的以及自动重置的。</p>
<p>通知事件（手动重置）—设置此事件时，将释放任意数量的等待线程，并且事件状态保持设置（信号），直到明确重置。</p>
<p>同步事件（自动重置）—设置此事件时，最多释放一个线程（无论有多少线程等待事件），一旦释放，事件将自动返回重置（无信号）状态。</p>
<p>操作和用户模式雷同，不过函数需要加Ke前缀。</p>
<h5 id="执行资源"><a href="#执行资源" class="headerlink" title="执行资源"></a>执行资源</h5><p>互斥锁虽然保证的资源不被破坏，但是是以牺牲并发性为代价，遇上只需要进行读取的线程操作，这样效率就降低了很多。</p>
<p>内核提供了另一个面向此场景的同步原语，称为单个写入器、多个阅读器。此对象是<strong>执行资源</strong>，它是另一个特殊对象，它不是调度程序对象。</p>
<p>结构：ERESOURCE</p>
<p>函数：ExInitializeResourceLite、ExAcquireResourceExclusiveLite、ExAcquireResourceSharedLite、ExReleaseResourceLite</p>
<p>要用acquire以及release函数需要禁用正常的内核APCs。Acquire之前可以调用KeEnterCtriticalRegion，释放之后可以用KeLeaveCtriticalRegion.</p>
<h5 id="High-IRQL-同步"><a href="#High-IRQL-同步" class="headerlink" title="High IRQL 同步"></a>High IRQL 同步</h5><p>线程在有些情况下是不能等待的，特别是，当处理器的IRQL是DISPATCH_LEVEL(2或者更高)。</p>
<p>当只有一个CPU时，可以如下图操作，但是现实情况往往不止一个CPU</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/wkp6/wps69B0.tmp.jpg" alt="img"> </p>
<p>如果一个CPU的IRQL提高到2，如果一个DPC需要执行，它可能会干扰另一个IRQL可能为零的CPU。在这种情况下，这两个函数可能同时执行，访问共享资源。</p>
<p>为了解决上述问题，需要像互斥锁这样的东西，但它可以在处理器之间同步，而不是线程。这是因为当CPU的IRQL为2或更高时，线程本身就会失去了意义，因为调度程序不能在该CPU上工作。这种对象实际上确实存在，即 Spin Lock。</p>
<h5 id="Spin-Lock"><a href="#Spin-Lock" class="headerlink" title="Spin Lock"></a>Spin Lock</h5><p>自旋锁是内存中的一个简单位，它通过API提供原子测试和修改操作。当一个CPU试图获得一个旋转锁，但它目前并未被释放，CPU继续在旋转锁上旋转，忙着等待它被另一个CPU释放(记住，使线程进入等待状态不能在IRQL DISPATCH_LEVEL或更高的地方完成)。</p>
<p>在前面说的场景中，需要分配和初始化一个自旋锁。每个需要访问共享数据的函数都需要将IRQL提高到2（如果还没有），获取自旋锁，对共享数据执行工作，最后释放自旋锁并降低IRQL（如果适用；不适用于DPC）。</p>
<p>结构：KSPIN_LOCK</p>
<p>函数：KeInitializeSpinLock</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/wkp6/wps69B1.tmp.jpg" alt="img"> </p>
<p>获取自旋锁总是一个分两步进行的过程：首先，将IRQL提高到适当的级别，这是任何试图同步访问共享资源的函数的最高级别。在前面的示例中，此关联的IRQL为2。第二，获取旋转锁。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/wkp6/wps69B2.tmp.jpg" alt="img"> </p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/wkp6/wps69B3.tmp.jpg" alt="img"> </p>
<h5 id="Work-Items"><a href="#Work-Items" class="headerlink" title="Work Items"></a>Work Items</h5><p>work items是用来描述系统线程池的函数的术语。驱动程序可以分配和初始化工作项，指向驱动程序希望执行的函数，然后工作项可以排队到池中。这与DPC非常相似，主要的区别是工作项总是在IRQLPASSIVE_LEVEL上执行，这意味着该机制可以用于从在IRQL2上运行的函数在IRQL0上执行操作。例如，如果DPC例程需要执行IRQL2中不允许的操作（例如打开文件），那么它可以使用工作项来执行这些操作。</p>
<p>内核提供了两个函数允许驱动创建线程：PsCreateSystemThread、</p>
<p>IoCreateSystemThread。</p>
<p>函数IoAllocateWorkItem初始化工作项，函数会返回一个指向不透明的IO_WORKITEM指针。完成后必须用IoFreeWorkItem释放。</p>
<p>如果需要动态地分配相应大小的IO_WORITEM，使用IoSizeofWorkItem，然后调用IoInitializeWorkItem，完成后用IoUninitializeWorkItem.</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/wkp6/wps69B4.tmp.jpg" alt="img"> </p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/wkp6/wps69B5.tmp.jpg" alt="img"> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2021/09/09/reverse/joker1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/09/reverse/joker1/" class="post-title-link" itemprop="url">buuctf_joker</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-09 00:00:00" itemprop="dateCreated datePublished" datetime="2021-09-09T00:00:00+08:00">2021-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-22 10:23:04" itemprop="dateModified" datetime="2021-12-22T10:23:04+08:00">2021-12-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/buuctf/" itemprop="url" rel="index"><span itemprop="name">buuctf</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="joker1"><a href="#joker1" class="headerlink" title="joker1"></a>joker1</h4><p>没有加壳</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse4/image-20210909150331784.png" alt="image-20210909150331784"></p>
<p><code>F5</code>发现不能反汇编（确定不是IDA的问题，网上说是堆栈市镇偏移出错，选项-常规-点击堆栈指针，快捷键alt+k,值改为0【PS:堆栈不平衡笔记在最后】</p>
<p>在最后一个AC处修改位0</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse4/image-20210909162139584.png" alt="image-20210909162139584"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse4/image-20210909162010697.png" alt="image-20210909162010697"></p>
<p>反汇编后伪代码如下，首先是输入长度为24，然后主要函数为<code>wrong</code> <code>omg</code> <code>encrypt</code>三个函数</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse4/image-20210909162739475.png" alt="image-20210909162739475"></p>
<p><code>wrong</code>是加密</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse4/image-20210909163728424.png" alt="image-20210909163728424"></p>
<p><code>omg</code>是比较<code>wrong</code>加密结果和unk_4030C0地址的值是否相同</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse4/image-20210909164135177.png" alt="image-20210909164135177"></p>
<p>写个脚本,得出来的flag{fak3_alw35_sp_me!!}是个假的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import string</span><br><span class="line">s=[102, 107, 99, 100, 127, 97, 103, 100, 59, 86, 107, 97, 123, 38, 59, 80, 99, 95, 77, 90, 113, 12, 55, 102]</span><br><span class="line">out=[]</span><br><span class="line">for i in range(0,24):</span><br><span class="line">    if i&amp;1 :</span><br><span class="line">        s[i]+=i</span><br><span class="line">        out.append(s[i])</span><br><span class="line">    else:</span><br><span class="line">        s[i]^=i</span><br><span class="line">        out.append(s[i])</span><br><span class="line">for i in out:</span><br><span class="line">    print(chr(i),end=&#x27;&#x27;)</span><br></pre></td></tr></table></figure>

<p>注意一下还有一个<code>Encrypt</code>函数，这个函数也是不能反汇编的</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse4/image-20210909172356488.png" alt="image-20210909172356488"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse4/image-20210909172621478.png" alt="image-20210909172621478"></p>
<p>动态OD调试试试，进加密函数看看</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse4/image-20210909182844710.png" alt="image-20210909182844710"></p>
<p>（或者OllyDump脱壳）IDA动态调试,看到原来的data数据变成了汇编代码，从encrypt函数的起始地址0x401500开始选取，选取所有没有编译的text段数据，按c，点击force</p>
<p><a target="_blank" rel="noopener" href="https://www.leadroyal.cn/p/370/">https://www.leadroyal.cn/p/370/</a></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse4/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21jbXV5YW5nYQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>然后在0x401500处右击创建函数，现在就能看到encrpty函数里的内容了,大概就是将带入的数据与Buffer进行异或操作，然后得到unk_403040地址上的值</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse4/image-20210909192327017.png" alt="image-20210909192327017"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import string</span><br><span class="line"></span><br><span class="line">result=[0xe,0xd,0x9,0x6,0x13,0x5,0x58,0x56,0x3e,0x6,0xc,0x3c,0x1f,0x57,0x14,0x6b,0x57,0x59,0xd]</span><br><span class="line">flag=&quot;&quot;</span><br><span class="line">haha=&quot;hahahaha_do_you_find_me?&quot;</span><br><span class="line">for i in range(19):</span><br><span class="line">    flag+=chr(ord(haha[i])^(result[i]))</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure>

<p>flag不全</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse4/image-20210909193101144.png" alt="image-20210909193101144"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse4/image-20210909193617976.png" alt="image-20210909193617976"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/CSNN2019/article/details/115328038">https://blog.csdn.net/CSNN2019/article/details/115328038</a></p>
<h4 id="堆栈不平衡"><a href="#堆栈不平衡" class="headerlink" title="堆栈不平衡"></a>堆栈不平衡</h4><p>IDA f5无法反汇编，出现如图错误一般是因为程序代码有一些干扰代码，比如用push + n条指令 + retn来实际跳转，而IDA会以为是retn是函数要结束，结果分析后发现调用栈不平衡</p>
<p>简单来说就是调用函数后。使用完堆栈esp要回到ebp的位置（大概这么理解</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse4/image-20210909153157763.png" alt="image-20210909153157763"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse4/image-20210909155612149.png" alt="image-20210909155612149"></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/saintlas/p/7093561.html">https://www.cnblogs.com/saintlas/p/7093561.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZouFeIYu"
      src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
  <p class="site-author-name" itemprop="name">ZouFeIYu</p>
  <div class="site-description" itemprop="description">reading, coding, travelling</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/erkeai" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;erkeai" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:563783592@qq.com" title="E-Mail → mailto:563783592@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-feather"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZouFeIYu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">88k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:20</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
