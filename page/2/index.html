<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16.ico">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"erkeai.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="reading, coding, travelling">
<meta property="og:type" content="website">
<meta property="og:title" content="hazel&#39;blog">
<meta property="og:url" content="https://erkeai.github.io/page/2/index.html">
<meta property="og:site_name" content="hazel&#39;blog">
<meta property="og:description" content="reading, coding, travelling">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ZouFeIYu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://erkeai.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>hazel'blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hazel'blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">82</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">81</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2022/04/07/pwn/tamuctf_pwn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/07/pwn/tamuctf_pwn/" class="post-title-link" itemprop="url">tamuctf_pwn</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-07 00:00:00 / 修改时间：20:23:42" itemprop="dateCreated datePublished" datetime="2022-04-07T00:00:00+08:00">2022-04-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pwn/" itemprop="url" rel="index"><span itemprop="name">pwn</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="pwn1"><a href="#pwn1" class="headerlink" title="pwn1"></a>pwn1</h3><p>​       看一下程序基本情况如下，动态链接的32位程序，只有canary保护没有打开。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407150427052.png" alt="image-20220407150427052"></p>
<p>​        <img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407150257274.png" alt="image-20220407150257274"></p>
<p>​        IDA看一下程序，可以看到明显<code>gets</code>函数处存在栈溢出，并且当v5等于某个值的时候，就执行<code>print_flag</code>函数输出flag。右键那个值-&gt;hexadecimal，可以看到该值十六进制为0xDEA110CB，也就是当v5为该值，就会输出flag，所以只需要栈溢出覆盖v5的值为0xDEA110CB，不需要自己找<code>system(&#39;/bin/sh&#39;)</code></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407151610311.png" alt="image-20220407151610311"></p>
<p>​        计算一下偏移变量s到变量v5的偏移距离，由IDA得s=ebp-3Bh、v5=ebp-10h，两者偏移距离为2Bh</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407152707564.png" alt="image-20220407152707564"></p>
<h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h4><p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407153452051.png" alt="image-20220407153452051"></p>
<p>因为服务器啥的已经没开了，所以只能纸上谈兵hh，但是这道题确实也就比较简单。</p>
<h3 id="pwn2"><a href="#pwn2" class="headerlink" title="pwn2"></a>pwn2</h3><p>​        先看一下该文件的详细信息，发现依旧只有canary没打开。是动态链接的32位程序。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407153944825.png" alt="image-20220407153944825"></p>
<p>IDA看一下程序，可以看到<code>gets</code>函数存在明显的栈溢出漏洞，字符串和函数中都没有看到<code>system</code>和<code>bin/sh</code>的身影，并且下面有一个函数<code>select_func</code></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407155104364.png" alt="image-20220407155104364"></p>
<p>看一下代码逻辑，发现拷贝了0x1F个字符到目标字符串，如果目标字符串等于<code>one</code>时候，将<code>one</code>赋值给v3,然后调用<code>v3()</code></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407155317532.png" alt="image-20220407155317532"></p>
<p>看函数列表，存在<code>one()``two()</code>函数以及<code>print_flag()</code>，函数地址分别为0x00000754，0x000006AD，0x000006D8。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407160314057.png" alt="image-20220407160314057"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407162416467.png" alt="image-20220407162416467"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407162438986.png" alt="image-20220407162438986"></p>
<p>我们现在需要做的就是跳转到<code>print_flag</code>函数，gets函数可以赋值31个字节给dest变量，dest与v3之间相差30个字节，可以溢出一个字节，v3初始值为two，two又与print_flag函数相差一个字节，所以溢出的一个字节就可以将v3的初始值修改为print_flag函数地址。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407163600996.png" alt="image-20220407163600996"></p>
<h4 id="payload-1"><a href="#payload-1" class="headerlink" title="payload"></a>payload</h4><p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407164012235.png" alt="image-20220407164012235"></p>
<h3 id="pwn3"><a href="#pwn3" class="headerlink" title="pwn3"></a>pwn3</h3><p>​        惯例看一下程序情况，发现只开了RELRO以及PIE，并且有RWX段。推测可能是自己写shellcode的题目。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407164138366.png" alt="image-20220407164138366"></p>
<p>​        IDA打开看一下，主要点进<code>echo</code>函数看一下，发现存在<code>gets</code>函数栈溢出漏洞<strong>（注意题目本身就泄露出了s的地址）</strong></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407164648542.png" alt="image-20220407164648542"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407164725968.png" alt="image-20220407164725968"></p>
<p>​        s的地址为ebp-12Ah，画个图看一下。s与EBP之间相差298个字节，s规定的数据为294字节大小，所以溢出够298+4个字节后将获取到的s地址覆盖掉函数返回地址、使程序跳转至s处执行shellcode。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407171136775.png" alt="image-20220407171136775"></p>
<h4 id="payload-2"><a href="#payload-2" class="headerlink" title="payload"></a>payload</h4><p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407172044765.png" alt="image-20220407172044765"></p>
<h3 id="pwn4"><a href="#pwn4" class="headerlink" title="pwn4"></a>pwn4</h3><p>​        发现只开启了NX保护</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407172747624.png" alt="image-20220407172747624"></p>
<p>​    IDA查看字符串和函数，可以看到有‘/bin/sh’和<code>system</code>函数，/bin/sh字符串，地址为0x0804A034</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407190256774.png" alt="image-20220407190256774"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407190433644.png" alt="image-20220407190433644"></p>
<p>​        主函数循环执行<code>laas</code>函数，该函数中可以看到gets函数存在明显栈溢出漏洞，如果在s字符串中没有找到ASCII码为47的字符<code>/</code>，那么就传入s参数执行<code>run_cmd</code>函数</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407190659867.png" alt="image-20220407190659867"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407190733634.png" alt="image-20220407190733634"></p>
<p>​        在run_cmd()函数未进行任何过滤直接调用system()函数执行系统命令（虽然可以直接<code>sendline(&#39;/bin/cat flag.txt&#39;)</code>，但是这道题还是走一下常规pwn思路）：</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407190901388.png" alt="image-20220407190901388"></p>
<p>看下call system()的地址，为0x080485AD，字符串s地址为ebp-21h：</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407191305838.png" alt="image-20220407191305838"></p>
<h4 id="payload-3"><a href="#payload-3" class="headerlink" title="payload"></a>payload</h4><p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407193706392.png" alt="image-20220407193706392"></p>
<p>还有一种写法，下面就是利用system的地址，而不是cal了system的地址</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407193829235.png" alt="image-20220407193829235"></p>
<h3 id="pwn5"><a href="#pwn5" class="headerlink" title="pwn5"></a>pwn5</h3><p>​        查看程序基本情况，发现是静态链接的，那就和libc无关了，并且只开了NX</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407194026908.png" alt="image-20220407194026908"></p>
<p>​        IDA发现其实逻辑啥的和pwn4一样，不过下图圈起来这里变成了7（这里也可以直接用<code>;$0</code>,还有一种利用vi命令及:shell的骚姿势，输入<code>;vi</code>再输入<code>:shell</code>即可执行shell）</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407194549935.png" alt="image-20220407194549935"></p>
<p>​        也可以找到‘/bin/sh’字符串和<code>system</code>函数。地址分别为0x080BC140和0x0804EE30,s地址为ebp-0Dh</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407194754387.png" alt="image-20220407194754387"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407194825643.png" alt="image-20220407194825643"></p>
<p>看到别人写的是有exit函数地址，但是感觉替换成其他四个字节的数据也可以（实践了一下确实可以）</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220407201448443.png" alt="image-20220407201448443"></p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://www.mi1k7ea.com/2019/03/08/TAMUctf-Pwn-writeup/">TAMUCTF-PWN</a> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2022/04/06/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E5%A4%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/06/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E5%A4%A9/" class="post-title-link" itemprop="url">代码随想录第二十一天</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-06 00:00:00" itemprop="dateCreated datePublished" datetime="2022-04-06T00:00:00+08:00">2022-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-07 10:07:20" itemprop="dateModified" datetime="2022-04-07T10:07:20+08:00">2022-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>784</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="字符串-反转字符串"><a href="#字符串-反转字符串" class="headerlink" title="字符串-反转字符串"></a>字符串-反转字符串</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-string/">题目链接</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fast = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &gt; slow)&#123;    <span class="comment">//fast != slow会出错,当字符串是偶数的时候会出事，fast与slow永远不会相等</span></span><br><span class="line">            <span class="keyword">char</span> tmp = s[slow];</span><br><span class="line">            s[slow] = s[fast];</span><br><span class="line">            s[fast] = tmp;</span><br><span class="line">            fast--;</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以直接用swap</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>()/<span class="number">2</span>; i++, j--) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 该方法已经不需要判断奇偶数，经测试后时间空间复杂度比用 for i in range(right//2)更低</span></span><br><span class="line">        <span class="comment"># 推荐该写法，更加通俗易懂</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            s[left], s[right] = s[right], s[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2022/04/05/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%A4%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/05/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%A4%A9/" class="post-title-link" itemprop="url">代码随想录第二十天</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-05 00:00:00 / 修改时间：17:02:15" itemprop="dateCreated datePublished" datetime="2022-04-05T00:00:00+08:00">2022-04-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="哈希表-四数之和"><a href="#哈希表-四数之和" class="headerlink" title="哈希表-四数之和"></a>哈希表-四数之和</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/4sum/">题目链接</a></p>
<p>这道题采用双指针的方法，首先顺序依次是i，j，left，right。和三数之和是一样的操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> left = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                   <span class="comment">// if(nums[i] + nums[j] + nums[left] + nums[right] &gt; target)right--;//会溢出</span></span><br><span class="line">                    <span class="keyword">if</span>(nums[i] + nums[j] &gt; target - (nums[left] + nums[right]))</span><br><span class="line">                        right--;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[j] &lt; target - (nums[left] + nums[right]))</span><br><span class="line">                        left++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        result.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;nums[i], nums[j], nums[left], nums[right]&#125;);</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">    </span><br><span class="line">    nums.sort()</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]: <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> k &gt; i + <span class="number">1</span> <span class="keyword">and</span> nums[k] == nums[k-<span class="number">1</span>]: <span class="keyword">continue</span></span><br><span class="line">            p = k + <span class="number">1</span></span><br><span class="line">            q = n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> p &lt; q:</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[k] + nums[p] + nums[q] &gt; target: q -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i] + nums[k] + nums[p] + nums[q] &lt; target: p += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([nums[i], nums[k], nums[p], nums[q]])</span><br><span class="line">                    <span class="keyword">while</span> p &lt; q <span class="keyword">and</span> nums[p] == nums[p + <span class="number">1</span>]: p += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> p &lt; q <span class="keyword">and</span> nums[q] == nums[q - <span class="number">1</span>]: q -= <span class="number">1</span></span><br><span class="line">                    p += <span class="number">1</span></span><br><span class="line">                    q -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2022/04/04/paper/A%20Systematical%20and%20longitudinal%20study%20of%20evasive%20behaviors%20in%20windows%20malware/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/04/paper/A%20Systematical%20and%20longitudinal%20study%20of%20evasive%20behaviors%20in%20windows%20malware/" class="post-title-link" itemprop="url">A Systematical and longitudinal study of evasive behaviors in windows malware</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-04 00:00:00" itemprop="dateCreated datePublished" datetime="2022-04-04T00:00:00+08:00">2022-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-06 17:13:37" itemprop="dateModified" datetime="2022-04-06T17:13:37+08:00">2022-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/paper-reading/" itemprop="url" rel="index"><span itemprop="name">paper reading</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>​        该文研究了恶意软件的规避行为。论文收集了92种恶意软件用来检测和以及阻止检测的规避技术，并做了系统化，提供了一种根据这些技术的语义和特征进行分类的分类方法。实现了一个对x86二进制文件进行逃避分析的框架，分析了2010年至2019年期间的45,375个恶意软件样本，并采取将这种分析与合法的主流windoiws程序进行比较的方法，来研究规避行为的内在特征。还研究了恶意软件家族与所采用的规避技术之间的相关性。并且论文确定了特定于恶意代码的技术，而不是恶意代码与合法软件都会使用的技术。</p>
<p>​        论文实验结果体现了规避技术的使用以及随着时间的演变，发现规避行为十年间，在数量上仅仅增加了12%，但是在技术上已经有显著的提高。最后论文研究了如何应对新型规避技术的部署。</p>
<h3 id="规避技术分类法"><a href="#规避技术分类法" class="headerlink" title="规避技术分类法"></a>规避技术分类法</h3><p>​        该文根据在操作系统上执行的动作的语义来进行分类。基于先前提出的系统化，该文还开发了由16个语义等价组组成的分类法。有内存指纹、异常处理、CPU指纹、表描述符、陷阱、时间、暂缓、人类交互、注册表、系统环境、WMI、进程环境、文件系统、枚举进程、枚举服务、枚举驱动。 通过静态分析每个二进制程序，计算了实现92个规避技术所需的基本块、指令和函数调用的数量。</p>
<h3 id="分析框架"><a href="#分析框架" class="headerlink" title="分析框架"></a>分析框架</h3><p>​        可以实现四个级别的检测：指令（监控每个执行指令）、API hook（hook一些感兴趣的Windows API）、系统调用（hook感兴趣的系统调用）、内存访问（监视对特定内存区域的访问）。系统会在逃避前后进行hook,这两个hook都会采用日志记录规避行为。</p>
<p>​        系统根据级别分为了四个模块，并且还增加了一个库追踪器模块，用来记录规避技术和相关库的调用堆栈。</p>
<h3 id="规避行为分析"><a href="#规避行为分析" class="headerlink" title="规避行为分析"></a>规避行为分析</h3><p>​        该部分根据五个问题展开</p>
<p>1.恶意软件最常见的规避技术是什么？</p>
<p>​        时间和暂缓技术是使用最多的，搜索特定的驱动程序很少被用到，并且实验数据并未观察到对WMI的使用。恶意软件家族也会寻找关键字，其中“vbox”、“sandbox”和“虚拟virtualbox”是最常用的关键字。</p>
<p>2.恶意软件家族和采用的规避行为技术之间有什么联系吗？</p>
<p>​        事实上，恶意软件样本通常是由工具构建的。恶意软件的作者通常开发可以很容易地用来生成新的样本的工具。该文建立了一个随机森林分类器；分类器的输入是一个布尔变量数组，表示样本中每种技术的使用情况；分类器的输出是族标签。我们为123个家族（所有至少有50个样本的家族）建立了123个分类器。每个分类器的输出采用分层抽样进行3倍交叉验证训练。对于每个分类器，计算了f1-score，这是一个评估分类器性能的指标，并考虑了所有的混淆矩阵。</p>
<p>3.在过去的10年里，每个家庭和每个类别所采用的规避技术的数量是否发生了变化？</p>
<p>​        该部分研究了每种技术的使用周期，规避技术的使用量，单个样本所使用的规避技术的最大数量，恶意样本规避的四大目标占比。</p>
<p>4.采用恶意软件规避技术如何影响安全社区，反之亦然？</p>
<p>​        如果该技术已经被广泛采用/已知，在报告发布后，我们注意到在随后的几年中它们的使用有轻微和暂时的下降。相反，如果该技术几乎很少被使用或者被知道，在报告发布后的接下来的几年里，它的采用迅速增加。一旦一种技术被广泛使用，相关报告的数量就会显著增加。</p>
<p>5.合法的软件是否也采用了规避技术？</p>
<p>​        合法的程序也会采用规避技术，但是并不是很常见。特别是，只有少数技术被普遍采用，这表明这种技术并不主要用于真正的规避目的。</p>
<p>​        基于良性软件分析，对每个技术进行了分类：</p>
<p>​        被恶意软件使用的规避技术。这是在良性软件样本中从未观察到的逃避行为，或者手动验证了它在良性软件样本中被用作一种逃避机制。</p>
<p>​        被用于良性软件的规避技术。这是在超过1%的良性软件样本中观察到的规避行为，或者手动验证没有被用作逃避行为。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2022/04/01/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AC%AC%E5%8D%81%E4%B9%9D%E5%A4%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/01/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AC%AC%E5%8D%81%E4%B9%9D%E5%A4%A9/" class="post-title-link" itemprop="url">代码随想录第十九天</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-01 00:00:00 / 修改时间：11:13:01" itemprop="dateCreated datePublished" datetime="2022-04-01T00:00:00+08:00">2022-04-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="哈希表-三数之和"><a href="#哈希表-三数之和" class="headerlink" title="哈希表-三数之和"></a>哈希表-三数之和</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/">题目链接</a></p>
<p>这道题采用双指针的方法，首先顺序依次是i，left，right。按照每个i下标处的值一次寻找排序后数组中满足条件的left和right下标位置的值（注意去重）。第一个i处理完成后，i递增，如果此时发现由重复的数也需要去重，这样可以寻找出所有满足条件的数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]) right--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left<span class="number">-1</span>]) left++;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;     </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            left = i + <span class="number">1</span></span><br><span class="line">            right = n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                total = nums[i] + nums[left] + nums[right]</span><br><span class="line">                <span class="keyword">if</span> total &gt; <span class="number">0</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right + <span class="number">1</span>]: right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> total &lt; <span class="number">0</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left - <span class="number">1</span>]: left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans.append([nums[i], nums[left], nums[right]])</span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]: left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]: right -= <span class="number">1</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span> </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2022/04/01/pwn/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/01/pwn/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/" class="post-title-link" itemprop="url">栈溢出攻击以及基本ROP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-01 00:00:00" itemprop="dateCreated datePublished" datetime="2022-04-01T00:00:00+08:00">2022-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-11 19:50:46" itemprop="dateModified" datetime="2022-04-11T19:50:46+08:00">2022-04-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pwn/" itemprop="url" rel="index"><span itemprop="name">pwn</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="栈溢出攻击基础知识"><a href="#栈溢出攻击基础知识" class="headerlink" title="栈溢出攻击基础知识"></a>栈溢出攻击基础知识</h2><p>​        栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。关于栈溢出攻击，可以看一下下面的图。  </p>
<p>​        缓冲区可以理解为一段可读写的内存区域。代码段存放的是程序的机器码和只读数据。数据段存储的是静态数据和用户的全局变量。堆存储程序运行时分配的变量，大小不固定，由内存地址低向高增长。栈存放函数调用时的临时信息结构，由内存地址高向低增长。入栈（PUSH）时，栈顶变小。出栈（POP）时，栈顶变大。</p>
<p>​        除了代码段和数据区域，其他的内存区域都能作为缓冲区，因此缓冲区溢出的位置可能在数据段、也可能在堆栈段。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220401142938542.png" alt="image-20220401142938542"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220401143120042.png" alt="image-20220401143120042"></p>
<h3 id="linux安全机制"><a href="#linux安全机制" class="headerlink" title="linux安全机制"></a>linux安全机制</h3><ul>
<li>canary(GS)：在栈靠近栈底某个位置设置初值，当函数结束时会检查这个栈上的值是否和存进去的值一致，防止栈溢出的一种保护</li>
<li>relro：主要用来保护重定位表段对应数据区域，默认可写。分为两种，Partial RELRO：got表不可写，got.plt可写。Full RELRO：got表，got.plt不可写</li>
<li>PIE(ALSR)：程序开启了PIE保护的话，在每次加载程序时都改变加载的基地址，不会影响指令间的相对地址</li>
<li>NX(DEP)：数据执行保护，指不允许数据页(默认的堆页、各种堆栈页以及内存池页)执行代码</li>
</ul>
<h2 id="基本ROP"><a href="#基本ROP" class="headerlink" title="基本ROP"></a>基本ROP</h2><p>​        直接向栈或者堆上直接注入代码的方式已经难以发挥效果，提出的主要的绕过保护的方法就是ROP（面向返回的编程），主要思想是在<strong>栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong>所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p>
<p>利用条件如下：</p>
<pre><code>        * 程序存在溢出，并且可以控制返回地址。
        * 可以找到满足条件的gadgets以及其地址。
</code></pre>
<h3 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h3><p>ret2text 即控制程序执行程序本身已有的的代码 (.text)。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)。</p>
<p>1.先查看一下该elf文件，可以看到是32位elf文件见，并且是动态连接的。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220401155738902.png" alt="image-20220401155738902"></p>
<p>查看一下程序的保护机制，可以看到是32位的程序且仅仅开启了栈不可执行保护NX</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220401202249910.png" alt="image-20220401202249910"></p>
<h4 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h4><p>IDA看一下，可以看到主函数使用了<code>gets</code>函数，显然这个是可以利用的栈溢出漏洞。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220401165554355.png" alt="image-20220401165554355"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220401203317416.png" alt="image-20220401203317416"></p>
<p>查看字符串，双击进去看到是<code>secure</code>函数调用，这也就是gadgets，即反弹shell地址：0x0804863A</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220401165837291.png" alt="image-20220401165837291"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220401174052664.png" alt="image-20220401174052664"></p>
<h4 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload"></a>构造payload</h4><p>​        构造之前，需要计算能够控制得内存起始地址距离main()函数返回地址得字节数。在<code>gets</code>函数那个图中的call前面两行，说明了参数的地址是esp+0x1c，通过动态调试，我们也可以发现这一点。</p>
<p>​        在0x080486AE处下断点调试</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220402094553917.png" alt="image-20220402094553917"></p>
<p>​        ESP为<code>ffffd130</code>，其中存放的内容为<code>ffffd14c</code>，即输入的内容s的地址为<code>ESP+1c= ffffd14c</code>，而EBP为<code>ffffd1b8</code>，则s到EBP的偏移为<code>|ffffd1b8- ffffd14c|=6c</code>，所以s相对与返回地址的偏移为0x6c+4=0x70。</p>
<h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h4><p>​        我们的目标就是控制这个ret，由前面分析知，可以利用.text代码段区域中的<code>system(“/bin/sh”)</code>代码，该代码段即为可被ROP利用的Gadget，地址为<code>0x0804863a</code>，将其覆盖到函数返回地址处，前面再padding 70h个字节码即可。（图中应该是sendline，懒得重新截图了）</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220402101815404.png" alt="image-20220402101815404"></p>
<p>成功getshell：</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220402103300478.png" alt="image-20220402103300478"></p>
<h3 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h3><p>​        ret2shellcode也就是控制程序执行shellcode(<strong>修改函数返回地址，让其指向溢出数据中的一段指令</strong>)。要想执行 shellcode，需要shellcode所在的区域具有可执行权限。该方法关键点：</p>
<ul>
<li>溢出点附近有可执行权限，以便让填充的shellcode能够被执行；</li>
<li>有类似于jmp esp这样的gadget，使得程序能够跳转到shellcode中。</li>
</ul>
<p>​        前提条件：该技术的前提是需要操作系统关闭内存布局随机化以及需要程序调用栈有可执行权限。</p>
<h4 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h4><p>​    可以看到是动态链接的32位程序，没有开启任何保护，并且具有可读、可写、可执行段。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220402193552695.png" alt="image-20220402193552695"></p>
<p>​        IDA打开查看，依然是基本的栈溢出漏洞，不过这次将对应字符串复制到了buf2处</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220402193819764.png" alt="image-20220402193819764"></p>
<p>​        buf2处于bss段（这次查看字符串，并没有之前所利用的system(“/bin/sh”)了）</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220402193948368.png" alt="image-20220402193948368"></p>
<p>​        先输入命令<code>b main</code>和<code>r</code>，然后输入vmmap查看映射状况，可以看到第三行，buf2所在的bss段具有可读可写可执行权限</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220402194512179.png" alt="image-20220402194512179"></p>
<h4 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h4><p>​        可以和ret2text一样利用gdb下断点来计算偏移地址，也可以用GDB pattern字符串计算偏移量，先用<code>pattern_create</code>创建计算溢出偏移量的字符串，在输入的时候输入就可以了。（<strong>EIP指向CPU即将要执行的指令，SIGSEGV是当一个进程执行了一个无效的内存引用，或发生段错误时发送给它的信号</strong>）</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220402200053543.png" alt="image-20220402200053543"></p>
<p>​        <code>pattern_offset</code>计算出偏移量。也就是0x70</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220402200631556.png" alt="image-20220402200631556"></p>
<h4 id="payload-1"><a href="#payload-1" class="headerlink" title="payload"></a>payload</h4><p>​        <code>asm()</code>接收一个字符串作为参数，得到汇编码的机器代码。shellcraft模块是shellcode的模块，包含一些生成shellcode的函数。其中的子模块声明架构，比如<code>shellcraft.arm</code> 是ARM架构的，<code>shellcraft.amd64</code>是AMD64架构，<code>shellcraft.i386</code>是Intel 80386架构的，以及有一个<code>shellcraft.common</code>是所有架构通用的。</p>
<p>​        而这里的<code>shellcraft.sh()</code>则是执行/bin/sh的shellcode了。<code>shellcode.ljust()</code>这段代码就是要讲shellcode不足112长度的地方用a来填充。<strong>注意红框部分，圈起来的地方需要<code>b&#39;A&#39;</code>，不然会报错。</strong><br><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220402202232199.png" alt="image-20220402202232199"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220402202212510.png" alt="image-20220402202212510"></p>
<h3 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h3><p>​        ret2syscall即控制程序执行系统调用，获取shell。需要满足两个条件：</p>
<pre><code>    程序中有分别用于控制eax，ebx，ecx，edx的gadgets；
    程序中有int 0x80指令，用于触发系统调用。
</code></pre>
<p>​        一般利用如下系统调用来获取shell：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(<span class="string">&quot;/bin/sh&quot;</span>,NULL,NULL)</span><br></pre></td></tr></table></figure>

<p>​        当遇到32位程序时，需要使得：</p>
<ul>
<li>系统调用号，即 eax 应该为 0xb（0xb 为 execve 对应的系统调用号）</li>
<li>第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。</li>
<li>第二个参数，即 ecx 应该为 0</li>
<li>第三个参数，即 edx 应该为 0</li>
</ul>
<h4 id="Linux系统调用的实现"><a href="#Linux系统调用的实现" class="headerlink" title="Linux系统调用的实现"></a>Linux系统调用的实现</h4><p>Linux 的系统调用通过 int 80h 实现，用系统调用号来区分入口函数。在 Linux 中，<code>0x80</code>中断处理程序是内核，用于其他程序对内核进行系统调用。操作系统实现系统调用的基本过程是：</p>
<ul>
<li>应用程序调用库函数（API）；</li>
<li>API 将系统调用号存入 EAX，然后通过中断调用使系统进入内核态；</li>
<li>内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；</li>
<li>系统调用完成相应功能，将返回值存入 EAX，返回到中断处理函数；</li>
<li>中断处理函数返回到 API 中；</li>
<li>API 将 EAX 返回给应用程序。</li>
</ul>
<p>应用程序的调用过程是：</p>
<ul>
<li>把系统调用的编号存入 EAX；</li>
<li>把函数参数存入其它通用寄存器；</li>
<li>触发 0x80 号中断（int 0x80）。</li>
</ul>
<h4 id="静态分析-1"><a href="#静态分析-1" class="headerlink" title="静态分析"></a>静态分析</h4><p>​        发现文件是32位的静态链接文件，并且只打开了NX保护</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220404125137686.png" alt="image-20220404125137686"></p>
<p>​        IDA打开看到，<code>gets</code>函数存在栈溢出风险，</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220404125637358.png" alt="image-20220404125637358"></p>
<p>​        如何控制寄存器的值呢？这里就需要使用 gadgets。比如说，现在栈顶是 10，那么如果此时执行了 pop eax，那么现在 eax 的值就为 10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。具体寻找 gadgets 的方法，我们可以使用 ropgadgets 这个工具。</p>
<p>​        寻找pop eax~edx+ret寄存器的指令，记下符合条件的地址分别为0x080bb196和0x0806eb90：</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220404134647641.png" alt="image-20220404134647641"></p>
<p>​        类似于之前的做法，我们可以获得 v4 相对于 ebp 的偏移为 108。所以我们需要覆盖的返回地址相对于 v4 的偏移为 112。此次，由于我们不能直接利用程序中的某一段代码或者自己填写代码来获得 shell，所以我们利用程序中的 gadgets 来获得 shell，而对应的 shell 获取则是利用系统调用。</p>
<p>​        我们还需要获得 /bin/sh 字符串对应的地址，还有 int 0x80 的地址。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220404142901925.png" alt="image-20220404142901925"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220404142942346.png" alt="image-20220404142942346"></p>
<h4 id="payload-2"><a href="#payload-2" class="headerlink" title="payload"></a>payload</h4><p>payload构造如下，要在将返回地址指向int 0x80,在返回之前要将四个寄存器赋值完成，所以最终payload构成是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = padding+pop_eax+”0xb”+pop_edx_ecx_ebx+0+0+”/bin/sh”+int 0x80</span><br></pre></td></tr></table></figure>

<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220404141904456.png" alt="image-20220404141904456"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220404142841848.png" alt="image-20220404142841848"></p>
<h3 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h3><p>​        libc是Standard C library的简称，它是符合ANSI C标准的一个函数库。libc库提供C语言中所使用的宏，类型定义，字符串操作函数，数学计算函数以及输入输出函数等。简而言之，每个使用了标准库函数的Linux程序，都会加载libc，以便能够真正调用这些库函数。在Ubuntu中，libc的实现是libc.so.6（32位）或libc-2.xx.so（64位），不同的Ubuntu系统，xx是不一样的，例如Ubuntu 16.04的64位libc实现是libc-2.23.so。</p>
<p>​        这种攻击方式主要是针对 <strong>动态链接(Dynamic linking)</strong> 编译的程序，因为正常情况下是无法在程序中找到像 <strong>system() 、execve()</strong> 这种系统级函数(<u>如果程序中直接包含了这种函数就可以直接控制返回地址指向他们，而不用通过这种麻烦的方式</u>,，比如<strong>ret2text</strong>)。因为程序是动态链接生成的，所以在程序运行时会调用 <strong>libc.so (程序被装载时，动态链接器会将程序所有所需的动态链接库加载至进程空间，libc.so 就是其中最基本的一个)<strong>，</strong>libc.so</strong> 是 linux 下 C 语言库中的运行库<strong>glibc</strong> 的动态链接版，并且 <strong>libc</strong>.<strong>so</strong> 中包含了大量的可以利用的函数，包括 <strong>system() 、execve()</strong> 等系统级函数，我们可以通过找到这些函数在内存中的地址覆盖掉返回地址来获得当前进程的控制权。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220405155936033.png" alt="image-20220405155936033"></p>
<p>​        就像Windows里面对DLL的调用一样，如果一个Linux程序想要隐式调用libc库函数，就需要在程序的“导入表”中填写该函数的相关信息，包括函数名。当然，Linux是没有“导入表”这个概念的，取而代之的是.plt表和.got表，对比Windows，它们就像INT表和IAT表。前者是编译后就已经写好的，里面并不包含真正的目标函数地址；后者是在运行时确定的，包含真正的目标函数地址。</p>
<p>​        <strong>为什么要多用一个PLT表？</strong>原因是为了程序的运行效率，GOT表的初始值都指向PLT对应的某个片段中，而对应的PLT片段中包含能够解析函数地址的函数。（提高效率的原因就在这里）</p>
<p>​        外部函数的内存地址存储在 GOT 而非 PLT 表内，PLT 存储的入口点又指向 GOT 的对应条目，那么程序为什么选择 PLT 而非 GOT 作为调用的入口点呢？GOT 表的初始值都指向 PLT 表对应条目中的某个片段，这个片段的作用是调用一个<strong>函数地址解析函数</strong>。当程序需要调用某个外部函数时，首先到 PLT 表内寻找对应的入口点，跳转到 GOT 表中。如果这是第一次调用这个函数，程序会通过 GOT 表再次跳转回 PLT 表，运行地址解析程序来确定函数的确切地址，并用其覆盖掉 GOT 表的初始值，之后再执行函数调用。当再次调用这个函数时，程序仍然首先通过 PLT 表跳转到 GOT 表，此时 GOT 表已经存有获取函数的内存地址，所以会直接跳转到函数所在地址执行函数。整个过程如下面两张图所示。</p>
<p>​        <img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220406155849976.png" alt="image-20220406155849976"></p>
<p>再次调用的时候如下：</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220406155917813.png" alt="image-20220406155917813"></p>
<p>​        ret2libc，即控制执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。</p>
<h4 id="静态分析-2"><a href="#静态分析-2" class="headerlink" title="静态分析"></a>静态分析</h4><p>​        首先看一下程序基本情况，发现是动态链接的并且只开启了NX保护</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220405151835554.png" alt="image-20220405151835554"></p>
<p>​        IDA查看</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220405152932134.png" alt="image-20220405152932134"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220405153116989.png" alt="image-20220405153116989"></p>
<p>​        可知“/bin/sh”字符串所在地址为0x08048720。</p>
<p>​        因为要从libc中寻找利用函数，则可以在ida直接查看plt中是否有<code>system()</code>函数，发现是存在有的且地址为<code>0x08048460</code>,其内容只是一条jmp指令，跳转到.got表的地址中去。</p>
<p>​        而.got表又是程序运行起来之后动态填充的，因此，我们在进行pwn时，只需返回到.plt表中的对应函数地址处，就能够让系统“帮忙”调用目标函数了。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220405153323375.png" alt="image-20220405153323375"></p>
<p>​        至于用户输入的变量v4距函数返回地址的偏移地址的计算如之前所示，结果是一样的为0x70。</p>
<h4 id="payload-3"><a href="#payload-3" class="headerlink" title="payload"></a>payload</h4><p>​        这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以’bbbb’ 作为虚假的地址，其后参数对应的参数内容。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220405163142087.png" alt="image-20220405163142087"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220405163611287.png" alt="image-20220405163611287"></p>
<h4 id="只有system-无‘bin-sh’"><a href="#只有system-无‘bin-sh’" class="headerlink" title="只有system(),无‘bin/sh’"></a>只有system(),无‘bin/sh’</h4><p>​        此次需要我们自己来读取字符串，所以我们需要两个 gadgets，第一个控制程序读取字符串，第二个控制程序执行 system(“/bin/sh”)。</p>
<p>​        可以在plt中看到有gets()函数，即可以将该gets()函数地址用来踩掉原本程序函数的返回地址，然后通过输入的方式将“/bin/sh”输入进去。换句话说，整个过程分成了两部分，第一部分是将“/bin/sh”读入到内存中；第二部分是执行system()获取shell。</p>
<p>​        可知get()函数地址为08048460。查看gets()函数，其需要一个可读可写的指针参数，且会返回值</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220406104719572.png" alt="image-20220406104719572"></p>
<p>​        寻找一块可读可写的buffer区，通常会寻找.bss段，使用IDA查看可看到存在buf2[100]数组，并且调用命令<code>vmmap</code>可以看到该.bss段可读可写。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220406104605394.png" alt="image-20220406104605394"></p>
<p>​        因为在<code>gets()</code>函数完成后需要调用<code>system()</code>函数需要保持堆栈平衡，所以在调用完gets()函数后提升堆栈，这就需要<code>add esp, 4</code>这样的指令但是程序中并没有这样的指令。更换思路，通过使用<code>pop xxx</code>指令也可以完成同样的功能，在程序中找到了<code>pop ebx，ret</code>指令。通过ROPgadget工具查看，发现存在一条符合条件的指令，地址为<code>0x0804841d</code></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220406104929107.png" alt="image-20220406104929107"></p>
<p>payload构造如下</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220406112911760.png" alt="image-20220406112911760"></p>
<h4 id="无system-无‘bin-sh’"><a href="#无system-无‘bin-sh’" class="headerlink" title="无system(),无‘bin/sh’"></a>无system(),无‘bin/sh’</h4><p>​        通常情况下，并没有这么好的条件让我们能够直接调用system。我们需要想办法通过已知函数地址，去推测system函数的地址。</p>
<p>​        由于一个ELF文件在生成完成后，它的不同函数之间的偏移地址是不会改变的，或者说，<strong>每一个函数与文件起始地址之间的偏移是不会改变的</strong>。所以我们可以通过<strong>泄露libc中某个被调用过的函数的地址来获取libc版本，获取libc中各个偏移地址值</strong>，然后通过某个函数的真实地址计算出system()和/bin/bash的真实地址。</p>
<p>​        对于system()函数，其属于libc，在libc.so动态链接库中的函数之间相对偏移是固定的。我们由泄露的某个函数的GOT表地址可以计算出偏移地址<strong>（A真实地址-A的偏移地址 = B真实地址-B的偏移地址 = 基地址）</strong>，从而可以得到system()函数的真实地址（当然也可以直接调用pwntools的libc.address得到libc的真实地址，然后再直接查找即可找到真实的system()函数地址）。        </p>
<h5 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h5><p>​        红色箭头为第一次溢出调用，通过gets()栈溢出至函数返回地址处将其覆盖为puts的plt地址，将puts的GOT表地址泄露输出出来，再返回到_start()函数重新执行程序；蓝色箭头为程序第二次执行时的溢出调用，重新通过gets()输入内容栈溢出至函数返回地址处，覆盖该地址为libc中找到的system()地址（libc地址由泄露的puts函数地址计算得出），从而getshell：</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220406140129118.png" alt="image-20220406140129118"></p>
<ul>
<li>将puts()的plt地址覆盖到函数返回地址处，通过puts()泄露某个已执行过的函数的GOT地址，并且返回地址设置为_start()或main()，以便于重新执行一遍程序</li>
<li>通过recv(4)接收puts()输出泄露的某个已执行过的函数的GOT地址，再以此来计算libc中地址与真实地址的偏移量；或者通过泄露的某个已执行过的函数的GOT地址，直接使用pwntools的<code>libc.address=func_got-libc.symbols[‘func’]</code>的形式直接获取libc的真实地址，从而直接通过<code>system_addr=libc.symbols[‘system’]</code>的方式直接获取该函数真实地址</li>
<li>程序再次执行时填充padding，在函数返回地址处覆盖为libc中system()函数的真实地址，其中参数为libc中”/bin/sh”字符串的真实地址。</li>
</ul>
<p>​        上面提到的泄漏方式，则是读取got表中的值。而反推libc版本的工作，已经有大佬通过编写<a target="_blank" rel="noopener" href="https://github.com/lieanu/LibcSearcher">LibcSearcher</a>帮忙完成了。</p>
<p>​        整个利用过程总体而言分为三步：</p>
<p>​            （1）  第一次ROP，打印出某个已知函数got表的值；</p>
<p>​            （2）  读取打印的这个值，并解析成地址，然后利用这个地址通过LibcSearcher去反推libc版本，进而利用已知偏移获取到libc基址；</p>
<p>​            （3）  解析ELF文件，获取目标函数（包括system）的偏移，加上基址就是目标函数实际地址，将获取到的地址填入溢出点完成exploit。</p>
<h4 id="payload-4"><a href="#payload-4" class="headerlink" title="payload"></a>payload</h4><p>​        在第一次栈溢出puts()的plt地址覆盖函数返回地址时，puts()的返回地址可以设置为_start()或main()函数地址。</p>
<p><strong>_start()和main()的区别</strong></p>
<p>​        简单地说，main()函数是用户代码的入口，是对用户而言的；而<code>_start()</code>函数是系统代码的入口，是程序真正的入口.我们可以看下本题的<code>_start()</code>函数内容，其包含<code>main()</code>和<code>__libc_start_main()</code>函数的调用，也就是说，它才是程序真正的入口：</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220406142427454.png" alt="image-20220406142427454"></p>
<p><strong>返回地址为_start()函数</strong></p>
<p>这里的示例只展示了两个可利用的函数puts()和__libc_start_main()。</p>
<p><strong>泄露puts()函数地址</strong></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220406152131967.png" alt="image-20220406152131967"></p>
<p><strong>泄露__libc_start_main 地址</strong></p>
<ul>
<li>泄露 __libc_start_main 地址（<strong>这个地址就是libc文件的基址</strong>）</li>
<li>获取 libc 版本</li>
<li>获取 system 地址与 /bin/sh 的地址</li>
<li>再次执行源程序</li>
<li>触发栈溢出执行 system(‘/bin/sh’)</li>
</ul>
<p>注意返回地址为start()</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220406155128449.png" alt="image-20220406155128449"></p>
<p>看了别人的博客发现，当将先将_start()换成main()，payload2的B字符的偏移量不变，运行脚本会报错，添加GDB调试交互发现溢出多了8个B</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220406155326463.png" alt="image-20220406155326463"></p>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>为了更好理解，在网上找到了这个图，栈溢出利用的时候按照1234的顺序来写payload，先构造main()函数，造成溢出，然后构造puts()函数。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220406105537868.png" alt="image-20220406105537868"></p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://www.mi1k7ea.com/2019/03/03/%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B9%8Bret2shellcode/">栈溢出之ret系列</a>、<a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/">CTF-Wiki</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2022/04/01/pwn/%E5%A0%86%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/01/pwn/%E5%A0%86%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB/" class="post-title-link" itemprop="url">堆溢出攻击</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-01 00:00:00" itemprop="dateCreated datePublished" datetime="2022-04-01T00:00:00+08:00">2022-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-15 17:21:11" itemprop="dateModified" datetime="2022-04-15T17:21:11+08:00">2022-04-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pwn/" itemprop="url" rel="index"><span itemprop="name">pwn</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数，因而导致了数据溢出，并覆盖到<strong>物理相邻的高地址</strong>的下一个堆块。但是其与栈溢出所不同的是，堆上并不存在返回地址等可以让攻击者直接控制执行流程的数据，因此我们一般无法直接通过堆溢出来控制 EIP 。</p>
<h3 id="Linux内存布局"><a href="#Linux内存布局" class="headerlink" title="Linux内存布局"></a>Linux内存布局</h3><p>先提一下windows的内存布局</p>
<img src="C:\Users\16434\AppData\Roaming\Typora\typora-user-images\image-20220414195634518.png" alt="image-20220414195634518" style="zoom:80%;" />

<p>linux 64位下内存布局如下，这种内存布局方式沿用的32位模式下内存的经典布局，但是栈和mmap的映射区域不再是从一个固定的地方开始，每次启动时的值都不一样。这样一来，使得使用缓冲区溢出攻击变得更加困难。（32位中，程序能够访问的最后地址是0xbfffffff(3G)的位置，3G以上的位置是给内核使用的，应用程序不能直接访问。）</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220414195748633.png" alt="image-20220414195748633"></p>
<h4 id="heap操作的相关函数"><a href="#heap操作的相关函数" class="headerlink" title="heap操作的相关函数"></a>heap操作的相关函数</h4><p>​        <code>brk()</code>是系统调用、<code>sbrk()</code>是库函数。c语言的动态内存分配基本函数是<code>malloc()</code>，在linux上的实现是：<code>malloc()</code>函数调用库函数<code>sbrk()</code>，<code>sbrk()</code>的实质是调用<code>brk()</code>函数。<code>brk()</code>是一个简单的系统调用，只是简单的改变<code>mm_struct</code>结构体的成员变量<code>brk</code>的值。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220414201147203.png" alt="image-20220414201147203"></p>
<h4 id="Mmap映射区域操作的相关函数"><a href="#Mmap映射区域操作的相关函数" class="headerlink" title="Mmap映射区域操作的相关函数"></a>Mmap映射区域操作的相关函数</h4><p>​        <code>malloc</code> 会使用<code>mmap</code>来创建独立的匿名映射段。匿名映射的目的主要是可以申请以 0 填充的内存，并且这块内存仅被调用进程所使用。<code>mmap()</code>函数将一个文件或者其他对象映射进内存。文件被映射到多个页上，如果文件大小不是所有页大小之和，最后一个页不被使用的空间将会清零。<code>munmap()</code>执行相反的操作，删除特定地址区域的对象映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">mmap</span><span class="params">(<span class="keyword">void</span> * start,<span class="keyword">size_t</span> length,<span class="keyword">int</span> prot,<span class="keyword">int</span> flags,<span class="keyword">int</span> fd,<span class="keyword">off_t</span> offset)</span></span></span><br></pre></td></tr></table></figure>

<p>​            start — 映射区的开始地址。</p>
<p>​            length — 映射区的长度。</p>
<p>​            prot — 期望的内存保护标志。</p>
<p>​            flags — 指定映射对象的类型，映射选项和映射页是否可以共享。</p>
<p>​            fd — 有效的文件描述符。</p>
<p>​            offset — 被映射对象内容的起点。</p>
<p>​        <code>mmap()</code>系统调用使得进程之间通过映射同一个普通文件实现共享内存。但是并不是完全为了用于共享内存而设计的。它本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作。</p>
<p>​        普通文件被映射到进程地址空间后，<strong>进程可以像访问普通内存一样对文件进行访问</strong>，不必再调用read()，write()等操作。mmap并不分配空间, 只是将文件映射到调用进程的地址空间里（但是会占掉你的 virutal memory）, 然后你就可以用memcpy等操作写文件, 而不用write()了。写完后，内存中的内容并不会立即更新到文件中，而是有一段时间的延迟，你可以调用<code>msync()</code>来显式同步一下, 这样你所写的内容就能立即保存到文件里了。不过通过<code>mmap</code>来写文件这种方式没办法增加文件的长度, 因为要映射的长度在调用<code>mmap()</code>的时候就决定了。</p>
<h3 id="堆基础知识"><a href="#堆基础知识" class="headerlink" title="堆基础知识"></a>堆基础知识</h3><p>​        先补充一下堆的基础知识，如下图。堆的结构是由“堆表”以及“堆块”构成这，其中“堆表”主要作用是用来索引堆块的位置。其中，堆表主要是有两种：空闲双向链表（Freelist）,快速单向链表（Lookaside）（注意：堆表仅仅是用来索引空闲态的堆块，即未被使用的堆块）“堆块”就是用来提供程序员申请堆空间的。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220401143714225.png" alt="image-20220401143714225"></p>
<p>​        未使用下的堆块与使用状态下的堆块差别在于，堆首部分添加了8字节的指针对，该指针就是用来链路堆表当中的。</p>
<p>​        堆表中需要关注的是空表索引区，由128项指针数组组成，这对指针用来将空闲堆组织成双向链表。根据堆块大小的不同，存放的指针数组也不同。每项链接的堆块大小均比其前一项链接的堆块增大8字节。<strong>值得注意的是free[0]链接的是大于等于1024字节的堆块。</strong></p>
<p>​    下图是空闲双向链表，当释放相邻内存堆块后会发生合并现象，该点区别于快速单向链表，快速单向链表每项只有四个节点</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220401144733642.png" alt="image-20220401144733642"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220401145728125.png" alt="image-20220401145728125"></p>
<p>​        linux早期的堆分配，为了安全性，一个线程使用堆时，会进行加锁。然而，与此同时，加锁会导致其它线程无法使用堆，降低了内存分配和回收的高效性。同时，如果在多线程使用时，没能正确控制，也可能影响内存分配和回收的正确性。后来在此基础上进行改进使其可以支持多线程，这个堆分配器就是 ptmalloc 。目前 Linux 标准发行版中使用的堆分配器是 glibc 中的堆分配器：ptmalloc2。ptmalloc2 主要是通过 malloc/free 函数来分配和释放内存块。</p>
<p>​        需要注意的是，在内存分配与使用的过程中，Linux 有这样的一个基本内存管理思想-<strong>-内存延迟分配，只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong>。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。</p>
<h3 id="内存分配与回收"><a href="#内存分配与回收" class="headerlink" title="内存分配与回收"></a>内存分配与回收</h3><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220414205604264.png" alt="image-20220414205604264" style="zoom:67%;" />

<p>先说上面面三个概念，三者概念的解释如下：</p>
<ul>
<li>arena：通过sbrk或mmap系统调用为线程分配的堆区，按线程的类型可以分为2类：<ul>
<li>main arena：主线程建立的arena；</li>
<li>thread arena：子线程建立的arena；</li>
</ul>
</li>
<li>chunk：逻辑上划分的一小块内存，根据作用不同分为4类：<ul>
<li>Allocated chunk：即分配给用户且未释放的内存块；</li>
<li><strong>Free chunk</strong>：即用户已经释放的内存块；</li>
<li>Top chunk：顶块, 位于所有块之后, 保存着未分配的所有内存；</li>
<li>Last Remainder chunk</li>
</ul>
</li>
<li>bin：一个用以保存Free chunk链表的表头信息的指针数组，按所悬挂链表的类型可以分为4类:<ul>
<li>Fast bin：chunk 的指针数组 , 每个元素是一 条单向链表的头部 , 且同一条链表中块的大小相同，主要保存大小 <strong>32 至 128 字节的块</strong>；</li>
<li>Unsorted bin：与 Small Bins 和 Large Bins 类似是双向循环链表 , 只有一个 bin, 其中保存的块大小不定，用于收集刚刚被 free 或从大的块中分裂剩下的块；</li>
<li>Small bin：chunk 的指针数组 , 每个元素是一条双向循环链表的头部 , 且同一条链表中块的大小相同，主要保存大小 <strong>32 至 1024 字节</strong>的块；</li>
<li>Large bin：每个元素是一条双向循环链表的头部 , 但同一条链表中块的大小不一定相同 , 按照从大到小的顺序排列 , 每个 bin 保存一定大小范围的块。主要保存大小 <strong>1024 字节以上</strong>的块。</li>
</ul>
</li>
</ul>
<p>在这里读者仅需明白arena的等级大于bin的等级大于(free)chunk的等级即可，即A&gt;B&gt;C。</p>
<h4 id="main-arena中的内存申请"><a href="#main-arena中的内存申请" class="headerlink" title="main arena中的内存申请"></a>main arena中的内存申请</h4><p>与 thread 不同的是，main_arena 并不在申请的 heap 中，而是一个全局变量，在 libc.so 的数据段。</p>
<img src="C:\Users\16434\AppData\Roaming\Typora\typora-user-images\image-20220414210612718.png" alt="image-20220414210612718" style="zoom: 67%;" />

<h4 id="thread-arena中的申请"><a href="#thread-arena中的申请" class="headerlink" title="thread arena中的申请"></a>thread arena中的申请</h4><img src="C:\Users\16434\AppData\Roaming\Typora\typora-user-images\image-20220414210545187.png" alt="image-20220414210545187" style="zoom: 67%;" />

<h4 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h4><p>在程序的执行过程中，我们称由 malloc 申请的内存为 chunk 。这块内存在 ptmalloc 内部用 malloc_chunk 结构体来表示。当程序申请的 chunk 被 free 后，会被加入到相应的空闲管理列表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用户最小申请的内存大小必须是 2 * SIZE_SZ 的最小整数倍。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220415095330146.png" alt="image-20220415095330146"></p>
<p>​        上图是在使用中的chunk 。</p>
<p>​    &lt;1&gt;chunk指针指向chunk开始的地址；mem指针指向用户内存块开始的地址。</p>
<p>​    &lt;2&gt; p=0时，表示前一个chunk为空闲，prev_size才有效。</p>
<p>​    &lt;3&gt; p=1时，表示前一个chunk正在使用，prev_size无效。 p主要用于内存块的合并操作。</p>
<p>​    &lt;4&gt; ptmalloc分配的第一个块总是将p设为1,以防止程序引用到不存在的区域。</p>
<p>​    &lt;5&gt; M=1 为mmap映射区域分配；M=0为heap区域分配。</p>
<p>​    &lt;6&gt; A=1 为非主分区分配；A=0 为主分区分配。</p>
<img src="C:\Users\16434\AppData\Roaming\Typora\typora-user-images\image-20220415095927924.png" alt="image-20220415095927924" style="zoom:80%;" />

<p>上图是一个空闲的chunk</p>
<p>   &lt;1&gt; 空闲的chunk会被放置到空闲的链表bins上。当用户申请内存malloc的时候，会先去查找空闲链表bins上是否有合适的内存。</p>
<p>​    &lt;2&gt; fp和bp分别指向前一个和后一个空闲链表上的chunk</p>
<p>​    &lt;3&gt;fp_nextsize和bp_nextsize分别指向前一个空闲chunk和后一个空闲chunk的大小，主要用于在空闲链表上快速查找合适大小的chunk。</p>
<p>​    &lt;4&gt;fp、bp、fp_nextsize、bp_nextsize的值都会存在原本的用户区域，这样就不需要专门为每个chunk准备单独的内存存储指针了。</p>
<p>​        当一个 chunk 处于使用状态时，它的下一个 chunk 的 prev_size 域无效，所以下一个 chunk 的该部分也可以被当前 chunk 使用。<strong>这就是 chunk 中的空间复用。</strong></p>
<h4 id="空闲chunk容器"><a href="#空闲chunk容器" class="headerlink" title="空闲chunk容器"></a>空闲chunk容器</h4><h5 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h5><p>​        用户释放掉的内存并不是马上就归还给操作系统，ptmalloc会统一管理heap和mmap映射区中的空闲的chunk，当用户进行下一次请求分配时，ptmalloc会试图从空闲的内存中挑选一块给用户，这样可以避免频繁的系统调用，降低了内存分配的开销。ptmalloc将大小相似的chunk用双向循环链表连接起来，这样的一个链表称为bin。ptmalloc中一共维护了128个bin，并使用一个数组来存储这些bin（数组实际存储的是指针）。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220415100832075.png" alt="image-20220415100832075"></p>
<p>​        并不是所有的 chunk 被释放后就 立即被放到 bin 中。ptmalloc 为了提高分配的速度，会把一些小的的 chunk 先放到一个叫做 fast bins 的容器内。</p>
<h3 id="分配算法概述"><a href="#分配算法概述" class="headerlink" title="分配算法概述"></a>分配算法概述</h3><img src="C:\Users\16434\AppData\Roaming\Typora\typora-user-images\image-20220415144235424.png" alt="image-20220415144235424" style="zoom: 80%;" />

<p>主分配区分配顺序依次为：</p>
<p>fast bins <strong>–&gt;</strong> small bins <strong>–&gt;</strong>  合并fast bins并把chunk加入unsorted bins，找unsorted bins </p>
<p><strong>–&gt;</strong> 把unsorted bins加入到large bins，找large bins <strong>–&gt;</strong>  top chunk <strong>–&gt;</strong> 增加heap大小或mmap分配</p>
<h3 id="回收算法概述"><a href="#回收算法概述" class="headerlink" title="回收算法概述"></a>回收算法概述</h3><img src="C:\Users\16434\AppData\Roaming\Typora\typora-user-images\image-20220415104726171.png" alt="image-20220415104726171" style="zoom: 67%;" />

<p>free()函数接受一个指向分配区域的指针作为参数，释放指针指向需要释放的chunk。</p>
<p>（1）free()函数首先需要获取分配区的锁来保证线程安全。</p>
<p>（2）判断传入的指针是否为0，如果为0，则什么都不做，直接return。否则转下一步。</p>
<p>（3）判断所需释放的chunk是否为mmaped chunk，如果是，则调用munmap()释放解除空间映射，该空间不再有效。</p>
<p>（4）判断chunk的大小和所处的位置，若chunk_size&lt;= max_fast，并且chunk并不处于heap的顶部，也就是说不与top chunk相邻，则转到下一步，否则转到第6步。</p>
<p>（5）将chunk放到fast bins中，chunk放入到fast bins中时，并不修改该chunk使用状态位P,也不与相邻的chunk进行合并。只是放进去。这一步做完之后释放就结束了，程序从free()函数中返回。</p>
<p>（6）判断前一个chunk是否正在使用中，如果前一个块也是空闲块，则合并。并转下一步。</p>
<p>（7）判断当前释放的chunk的下一个块是否为top chunk，如果是，则转第9步，否则转下一步。</p>
<p>（8）判断下一个chunk是否处于使用中，如果下一个chunk也是空闲的，则合并，并将合并后的chunk放到unsorted bin中。注意，这里在合并过程中，要更新chunk的大小，以反映合并后的chunk的大小。并转到第10步。</p>
<p>（9）如果执行到这一步，说明释放了一个与top chunk相邻的chunk。则无论它有多大，都将它和top chunk合并，并更新top chunk的大小等信息。转下一步。</p>
<p>（10）判断合并后的chunk的大小是否会大于max_fast（默认是64kb），如果是的话，则会触发进行fast bins的合并操作，fast bins中的chunk将被遍历，并与相邻的chunk进行合并，合并后的chunk会被放到unsorted bin中。fast bins将变为空，操作完成后进入到下一步。</p>
<p>（11）判断 top chunk的大小是否大于mmap收缩阀值（默认是128kb），如果是的话，对于主分配区，则会试图归还top chunk中的一部分给操作系统。但是最先分配的128KB空间是不会归还给操作系统的，ptmalloc会一直管理这部分内存，用来响应用户的分配请求。如果是非主分配区，会进行sub_heap收缩，将top chunk的一部分返回给操作系统，如果 top chunk是整个sub_heap，会将整个sub_heap归还给操作系统。做完这一步后，释放结束，从free()函数退出。</p>
<p><strong>对于Ubuntu 16.04而言，较小的chunk被free掉后，只是被放入fast bins中，其余什么也不做（见上述第5步）；对于Ubuntu 18.04而言，较小的chunk被free掉后，会被放入tcache bins中，</strong>       </p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220415111145345.png" alt="image-20220415111145345"></p>
<p>​                        </p>
<p>但无论是被放入fast bins还是tcache bins中，chunk的标志位都不会发生变化：</p>
<p>利用该特性，可以在free掉某个内存块后，重新申请处于fast bins或tcache bins中的内存块，并对其进行读写操作，从而达到漏洞利用的目的。</p>
<h3 id="堆相关数据结构"><a href="#堆相关数据结构" class="headerlink" title="堆相关数据结构"></a>堆相关数据结构</h3><h4 id="微观结构"><a href="#微观结构" class="headerlink" title="微观结构"></a>微观结构</h4><h5 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h5><p>​        </p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2022/03/31/wkp/Chapter7%20the%20IO%20Request%20Packet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/31/wkp/Chapter7%20the%20IO%20Request%20Packet/" class="post-title-link" itemprop="url">Chapter 7 the I/O Request Packet</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-31 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-31T00:00:00+08:00">2022-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-02 16:23:54" itemprop="dateModified" datetime="2022-04-02T16:23:54+08:00">2022-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">驱动开发</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="IRP介绍"><a href="#IRP介绍" class="headerlink" title="IRP介绍"></a>IRP介绍</h3><p>​    IRP的全名是I/O Request Package，即输入输出请求包，它是Windows内核中的一种非常重要的数据结构。上层应用程序与底层驱动程序通信时，应用程序会发出I/O请求，操作系统将相应的I/O请求转换成相应的IRP，不同的IRP会根据类型被分派到不同的派遣例程中进行处理。</p>
<p>​      IRP有两个基本的属性，即<strong>MajorFunction</strong>和<strong>MinorFunction</strong>，分别记录IRP的主类型和子类型。操作系统根据MajorFunction决定将IRP分发到哪个派遣例程，然后派遣例程根据MinorFunction进行细分处理。没有设置派遣函数的IRP，默认与<strong>IopInvalidDeviceRequest</strong>函数关联。</p>
<p>​      首先一个IRP在被分配时，调用者必须指定要分配多少个<strong>IO_STACK_LOCATION</strong>，这些结构直接在内存中伴随着IRP，其数量是设备堆栈中设备对象的数量。驱动程序会创建一个个设备对象，并将这些设备对象叠成一个垂直结构，叫做设备栈。IRP会被操作系统发送到设备栈顶层，如果顶层的设备对象的派遣函数结束了IRP的请求，那么这次I/O请求结束，如果没有，那么操作系统将IRP转发到设备栈的下一层设备处理，直到找到能够结束这个IRP请求的派遣函数的设备。</p>
<p>​      因此，一个IRP请求可能被转发多次，为了记录IRP在每层设备中做的操作，IRP会有个<strong>IO_STACK_LOCATION</strong>数组<u>（数组中的每个堆栈单元都对应一个将处理该IRP的驱动程序，另外还有一个堆栈单元供IRP的创建者使用。堆栈单元中包含该IRP的类型代码和参数信息以及完成函数的地址）</u>，数组的元素个数应该大于IRP穿过的设备数目， 当一个驱动程序接收到一个IRP时，将会获得一个指向IRP结构的指针，对于本层设备对应的<strong>IO_STACK_LOCATION</strong>,可以通过<code>IoGetCurrentIrpStackLocation</code>函数得到。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220304144523080.png" alt="image-20220304144523080"></p>
<h3 id="WDM与NT驱动程序"><a href="#WDM与NT驱动程序" class="headerlink" title="WDM与NT驱动程序"></a>WDM与NT驱动程序</h3><p>​     NT命名设备对象的名称形式为<code>\Device\DeviceName</code>, WDM驱动并不直接命名设备对象，系统规定了一个统一的命名方案，以确保设备名称不会在驱动程序之间发生冲突。WDM驱动程序命名方案：</p>
<ul>
<li>设备的 PDO 被命名。总线驱动程序为其枚举的设备请求命名 PDO。总线驱动程序在创建设备对象时指定 FILE_AUTOGENERATED_DEVICE_NAME 设备特性。</li>
<li>FDO 和FiDO 未命名。创建设备对象时，函数和过滤器驱动程序不请求名称。</li>
</ul>
<p>共有三种 WDM 设备对象：</p>
<ol>
<li>物理设备对象 (PDO) – 表示总线上的设备到<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/bus-drivers">总线驱动程序</a>，该设备对象表示在该总线上的该插槽中有某个设备。</li>
<li>功能设备对象 (FDO) – 代表<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/function-drivers">功能驱动程序</a>的设备，通常由硬件的供应商提供。</li>
<li>过滤设备对象（FiDO）——代表<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/filter-drivers">过滤器驱动程序</a>的设备。</li>
</ol>
<p>​    驱动程序通过创建设备对象 (<strong>IoCreateDevice</strong>）并将其附加到设备堆栈 （<strong>IoAttachDeviceToDeviceStack</strong> ）将自己添加到处理设备 I/O 的驱动程序堆栈中。<strong>IoAttachDeviceToDeviceStack</strong>确定设备堆栈的当前顶部并将新设备对象附加到设备堆栈的顶部。</p>
<h3 id="设备节点和设备堆栈"><a href="#设备节点和设备堆栈" class="headerlink" title="设备节点和设备堆栈"></a>设备节点和设备堆栈</h3><p>​    大多数发送到设备驱动程序的请求都打包在IRP中。通常，当向设备发送 I/O 请求时，多个驱动程序会帮助处理该请求。这些驱动程序中的每一个都与一个设备对象相关联，并且这些设备对象被安排在一个堆栈中。设备对象及其相关驱动程序的序列称为设备堆栈。每个设备由一个设备节点表示，每个设备节点都有一个设备栈。</p>
<p>​     即插即用管理器将一个设备节点与每个新创建的 PDO 相关联，并查看注册表以确定哪些驱动程序需要成为该节点的设备堆栈的一部分。设备堆栈必须有一个（并且只有一个）<strong>功能驱动程序</strong>，并且可以选择有一个或多个<strong>过滤器驱动程序</strong>。</p>
<p>​     功能驱动程序是设备栈的主要驱动程序，负责处理读取、写入和设备控制请求。过滤器驱动程序在处理读取、写入和设备控制请求时起到辅助作用。在加载每个函数和过滤器驱动程序时，它会创建一个设备对象并将自己附加到设备堆栈。由功能驱动程序创建的设备对象称为<strong>功能设备对象</strong>（FDO），过滤驱动创建的设备对象称为<strong>过滤设备对象</strong>（Filter DO）。</p>
<p>​       PDO 始终是设备堆栈中的底部设备对象。这是由设备堆栈的构造方式造成的。首先创建 PDO，当附加设备对象附加到堆栈时，它们将附加到现有堆栈的顶部。</p>
<p>​      在某些情况下，设备除了其内核模式设备堆栈外，还具有用户模式设备堆栈。用户模式驱动程序通常基于用户模式驱动程序框架 (UMDF)，它是Windows 驱动程序框架提供的驱动程序模型之一。<strong>在 UMDF 中，驱动程序是用户模式的 DLL，设备对象是实现 IWDFDevice 接口的 COM 对象</strong>。UMDF 设备堆栈中的设备对象称为<strong>WDF 设备对象</strong>(WDF DO)。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220331104749931.png" alt="image-20220331104749931"></p>
<p><code>IO_STACK_LOCATION</code>结构如下</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220331155121884.png" alt="image-20220331155121884"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_STACK_LOCATION</span> &#123;</span></span><br><span class="line">    UCHAR  MajorFunction;</span><br><span class="line">    UCHAR  MinorFunction;</span><br><span class="line">    UCHAR  Flags;</span><br><span class="line">    UCHAR  Control;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                PIO_SECURITY_CONTEXT SecurityContext;</span><br><span class="line">                ULONG Options;</span><br><span class="line">                USHORT POINTER_ALIGNMENT FileAttributes;</span><br><span class="line">                USHORT ShareAccess;</span><br><span class="line">                ULONG POINTER_ALIGNMENT EaLength;</span><br><span class="line">            &#125; Create;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                ULONG Length;</span><br><span class="line">                ULONG POINTER_ALIGNMENT Key;</span><br><span class="line">                LARGE_INTEGER ByteOffset;</span><br><span class="line">            &#125; Read;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                ULONG Length;</span><br><span class="line">                ULONG POINTER_ALIGNMENT Key;</span><br><span class="line">                LARGE_INTEGER ByteOffset;</span><br><span class="line">            &#125; Write;</span><br><span class="line">            ... ...</span><br><span class="line">        &#125; Parameters;</span><br><span class="line">    PDEVICE_OBJECT  DeviceObject;</span><br><span class="line">    PFILE_OBJECT  FileObject;</span><br><span class="line">    PIO_COMPLETION_ROUTINE CompletionRoutine;</span><br><span class="line">    PVOID Context;</span><br><span class="line">&#125; IO_STACK_LOCATION, *PIO_STACK_LOCATION;</span><br><span class="line"></span><br><span class="line">kd&gt; dt nt!_IO_STACK_LOCATION</span><br><span class="line">   +<span class="number">0x000</span> MajorFunction    : UChar</span><br><span class="line">   +<span class="number">0x001</span> MinorFunction    : UChar</span><br><span class="line">   +<span class="number">0x002</span> Flags            : UChar</span><br><span class="line">   +<span class="number">0x003</span> Control          : UChar</span><br><span class="line">   +<span class="number">0x004</span> Parameters       : &lt;unnamed-tag&gt;</span><br><span class="line">   +<span class="number">0x014</span> DeviceObject     : Ptr32 _DEVICE_OBJECT</span><br><span class="line">   +<span class="number">0x018</span> FileObject       : Ptr32 _FILE_OBJECT</span><br><span class="line">   +<span class="number">0x01c</span> CompletionRoutine : Ptr32     <span class="keyword">long</span> </span><br><span class="line">   +<span class="number">0x020</span> Context          : Ptr32 Void</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个结构的主要成员意义为：</p>
<ul>
<li><strong>MajorFunction(UCHAR) <strong>： 是该IRP的主功能码。这个代码应该为类似</strong>IRP_MJ_READ</strong>一样的值，并与驱动程序对象中<strong>MajorFunction</strong>表的某个派遣函数指针相对应。如果该代码存在于某个特殊驱动程序的I/O堆栈单元中，它有可能一开始是，例如<strong>IRP_MJ_READ</strong>，而后被驱动程序转换成其它代码，并沿着驱动程序堆栈发送到低层驱动程序。</li>
<li><strong>MinorFunction(UCHAR)</strong> ： 是该IRP的副功能码。它进一步指出该IRP属于哪个主功能类。例如，<strong>IRP_MJ_PNP</strong>请求就有约一打的副功能码，如<strong>IRP_MN_START_DEVICE</strong>、<strong>IRP_MN_REMOVE_DEVICE</strong>。</li>
<li><strong>Parameters(union)</strong> ： 是几个子结构的联合，每个请求类型都有自己专用的参数，而每个子结构就是一种参数。这些子结构包括**Create(IRP_MJ_CREATE请求)、Read(IRP_MJ_READ请求)、StartDevice(IRP_MJ_PNP的IRP_MN_START_DEVICE子类型)**，等等。</li>
<li><strong>DeviceObject(PDEVICE_OBJECT)</strong> ：是与该堆栈单元对应的设备对象的地址。该域由<strong>IoCallDriver</strong>函数负责填写。</li>
<li><strong>FileObject(PFILE_OBJECT)</strong> ： 是内核文件对象的地址，IRP的目标就是这个文件对象。驱动程序通常在处理清除请求(<strong>IRP_MJ_CLEANUP</strong>)时使用FileObject指针，以区分队列中与该文件对象无关的IRP。</li>
<li><strong>CompletionRoutine(PIO_COMPLETION_ROUTINE) <strong>： 是一个I/O完成例程的地址，该地址是由与这个堆栈单元对应的驱动程序的更上一层驱动程序设置的。绝对不要直接设置这个域，应该调用</strong>IoSetCompletionRoutine</strong>函数，该函数知道如何参考下一层驱动程序的堆栈单元。设备堆栈的最低一级驱动程序并不需要完成例程，因为它们必须直接完成请求。然而，请求的发起者有时确实需要一个完成例程，但通常没有自己的堆栈单元。这就是为什么每一级驱动程序都使用下一级驱动程序的堆栈单元保存自己完成例程指针的原因。</li>
<li><strong>Context(PVOID)</strong> ： 是一个任意的与上下文相关的值，将作为参数传递给完成例程。</li>
</ul>
<h3 id="IRP操作流程"><a href="#IRP操作流程" class="headerlink" title="IRP操作流程"></a>IRP操作流程</h3><p>​      通常大多数IRP是由I/O管理器创建的，该管理器初始化IRP结构和第一个I/O堆栈位置，然后它将IRP的指针传递到最上层。驱动程序在其适当的调度例程中接收到IRP。例如，如果这是一个ReadIRP，那么该驱动程序将从其驱动程序对象中调用其其主函数数组的IRP_MJ_READ索引。此时，驱动程序在处理IRP时可以有几个选项：</p>
<p>​        1.将请求向下传递。如果这个驱动设备并不是设备节点的最后一个设备，当对该请求不感兴趣时，可以将其向下传递。这是由接收到不感兴趣的请求的过滤器驱动完成的，为了不损害设备的功能，驱动将该请求向下传递。需要调用<code>IoCallDriver</code>，<code>IoCallDriver</code>会调用<code>IoGetNextIrpStackLocation</code>下移设备栈的指针，因此我们需要对设备栈做如下之一的操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IoCopyCurrentIrpStackLocationToNext( Irp ) &#123; \</span></span><br><span class="line"><span class="meta">    PIO_STACK_LOCATION irpSp; \</span></span><br><span class="line"><span class="meta">    PIO_STACK_LOCATION nextIrpSp; \</span></span><br><span class="line"><span class="meta">    irpSp = IoGetCurrentIrpStackLocation( (Irp) ); \</span></span><br><span class="line"><span class="meta">    nextIrpSp = IoGetNextIrpStackLocation( (Irp) ); \</span></span><br><span class="line"><span class="meta">    RtlCopyMemory( nextIrpSp, irpSp, FIELD_OFFSET(IO_STACK_LOCATION, CompletionRoutine)); \</span></span><br><span class="line"><span class="meta">    nextIrpSp-&gt;Control = 0; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IoSkipCurrentIrpStackLocation( Irp ) \</span></span><br><span class="line"><span class="meta">    (Irp)-&gt;CurrentLocation++; \</span></span><br><span class="line"><span class="meta">    (Irp)-&gt;Tail.Overlay.CurrentStackLocation++;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​       <code>IoCopyCurrentIrpStackLocationToNext</code> 拷贝<code>IO_STACK_LOCATION</code> 成员到下一层。由于初始化的时候只初始化了第一个I/O堆栈位置，所以每个驱动需要初始化下一个驱动。</p>
<p>​     <code>IoSkipCurrentIrpStackLocation</code> 上移一层，下次使用的时候仍旧使用当前的<code>IO_STACK_LOCATION</code>。</p>
<p>​     2.完全处理这个请求。接收到这个请求的设备可以调用<code>IoCompleterequest</code>处理这个请求，这样更低层的设备不会看到这个请求。</p>
<p>​     3.结合1和2，驱动程序可以检查IRP，做一些事情（比如记录请求），然后传递它。或者它可以对下一个I/O堆栈位置进行一些更改，然后传递请求。</p>
<p>​     4.传递请求并在请求完成时由底层设备通知。任何一层（除了最低的一层）都可以通过在传递请求之前调用<code>IoSetCompletionRoutine</code>来设置I/O完成例程。当其中一个较低的层完成请求时，将会调用驱动程序的完成例程。</p>
<p>​      5.开始一些异步IRP处理。驱动程序可能想要处理该请求，但如果请求很长（典型的硬件驱动程序，但也可能是软件驱动程序），驱动可能通过调用<code>IoMarkIrpPending</code>标记IRP为挂起，并从它的调度例程返回一个<code>STATUS_PENDING</code>。最终，它将不得不完成IRP。</p>
<p>​    一旦一些层调用<code>IoCompleteRequest</code>，该IRP就会向反方向回到IRP的发起者（通常是在管理器），如果完成例程已经注册，它们将按注册的相反顺序被调用，即从下到上。</p>
<h3 id="IRP"><a href="#IRP" class="headerlink" title="IRP"></a>IRP</h3><p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220331155052079.png" alt="image-20220331155052079"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span> &#123;</span></span><br><span class="line">	PMDL              MdlAddress;</span><br><span class="line">	ULONG             Flags;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span>*   <span class="title">MasterIrp</span>;</span></span><br><span class="line">		PVOID          SystemBuffer;</span><br><span class="line">	&#125; AssociatedIrp;</span><br><span class="line">	IO_STATUS_BLOCK   IoStatus;</span><br><span class="line">	KPROCESSOR_MODE   RequestorMode;</span><br><span class="line">	BOOLEAN           PendingReturned;</span><br><span class="line">	BOOLEAN           Cancel;</span><br><span class="line">	KIRQL             CancelIrql;</span><br><span class="line">	PDRIVER_CANCEL    CancelRoutine;</span><br><span class="line">	PVOID             UserBuffer;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">				KDEVICE_QUEUE_ENTRY DeviceQueueEntry;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">					PVOID    DriverContext[<span class="number">4</span>];</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">			PETHREAD     Thread;</span><br><span class="line">			LIST_ENTRY   ListEntry;</span><br><span class="line">		&#125; Overlay;</span><br><span class="line">	&#125; Tail;</span><br><span class="line">&#125; IRP, *PIRP;</span><br><span class="line"></span><br><span class="line">kd&gt; dt nt!_IRP</span><br><span class="line">   +<span class="number">0x000</span> Type             : Int2B</span><br><span class="line">   +<span class="number">0x002</span> Size             : Uint2B</span><br><span class="line">   +<span class="number">0x004</span> MdlAddress       : Ptr32 _MDL</span><br><span class="line">   +<span class="number">0x008</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x00c</span> AssociatedIrp    : &lt;unnamed-tag&gt;</span><br><span class="line">   +<span class="number">0x010</span> ThreadListEntry  : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x018</span> IoStatus         : _IO_STATUS_BLOCK</span><br><span class="line">   +<span class="number">0x020</span> RequestorMode    : Char</span><br><span class="line">   +<span class="number">0x021</span> PendingReturned  : UChar</span><br><span class="line">   +<span class="number">0x022</span> StackCount       : Char</span><br><span class="line">   +<span class="number">0x023</span> CurrentLocation  : Char</span><br><span class="line">   +<span class="number">0x024</span> Cancel           : UChar</span><br><span class="line">   +<span class="number">0x025</span> CancelIrql       : UChar</span><br><span class="line">   +<span class="number">0x026</span> ApcEnvironment   : Char</span><br><span class="line">   +<span class="number">0x027</span> AllocationFlags  : UChar</span><br><span class="line">   +<span class="number">0x028</span> UserIosb         : Ptr32 _IO_STATUS_BLOCK</span><br><span class="line">   +<span class="number">0x02c</span> UserEvent        : Ptr32 _KEVENT</span><br><span class="line">   +<span class="number">0x030</span> Overlay          : &lt;unnamed-tag&gt;</span><br><span class="line">   +<span class="number">0x038</span> CancelRoutine    : Ptr32     <span class="keyword">void</span> </span><br><span class="line">   +<span class="number">0x03c</span> UserBuffer       : Ptr32 Void</span><br><span class="line">   +<span class="number">0x040</span> Tail             : &lt;unnamed-tag&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>MdlAddress</strong> : 是一个MDL的指针，当内核层和用户层采用共享内存的结构传递数据的时候，这个MDL就代表共享的内存信息（共享物理内存，通过MDL映射）。这个成员生效的标记为：DO_DIRECT_IO, METHOD_IN_DIRECT 或者METHOD_OUT_DIRECT.</li>
<li><strong>AssociatedIrp</strong> : 这个成员是个联合体，其中存在一个SystemBuffer程序；当内核层使用用户层的数据的时候是通过拷贝数据的方式来实现的话，那么拷贝后的数据就放在了AssociatedIrp.SystemBuffer中了。这个成员生效的标记是DO_BUFFERED_IO或者METHOD_BUFFERED。</li>
<li><strong>IoStatus</strong> ： 返回的状态信息。</li>
<li><strong>RequestorMode</strong> : UserMode或KernelMode，指定原始I/O请求的来源。驱动程序有时需要查看这个值来决定是否要信任某些参数。</li>
<li>**PendingReturned **: Pending 状态，如果为TRUE，则表明处理该IRP的最低级派遣例程返回了STATUS_PENDING。</li>
<li><strong>StackCount</strong> : 设备栈的数目。</li>
<li><strong>CurrentLocation</strong> : 当前处于哪个设备栈的索引。</li>
<li><strong>Cancel</strong> : IRP是否被取消，如果为TRUE，则表明IoCancelIrp已被调用(该函数用于取消这个请求)。如果为FALSE，则表明没有调用IoCancelIrp函数。</li>
<li>**CancelIrql(KIRQL) **: 是一个IRQL值，表明那个专用的取消自旋锁是在这个IRQL上获取的.</li>
<li>**CancelRoutine(PDRIVER_CANCEL) **: 是驱动程序取消例程的地址。你应该使用IoSetCancelRoutine函数设置这个域而不是直接修改该域(因为可以原子修改）。</li>
<li><strong>UserBuffer(PVOID)</strong> : 用户层参数的直接地址，设置标记METHOD_NEITHER时候有效。</li>
<li>**Tail.Overlay **是Tail联合中的一种联合结构，如下：<br><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/image-20220331160047247.png" alt="image-20220331160047247"></li>
</ul>
<p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiangbaohui/article/details/104910607">windows驱动之IRP结构</a>、<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/driver-stacks">微软官方文档</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2022/03/31/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AC%AC%E5%8D%81%E5%85%AB%E5%A4%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/31/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AC%AC%E5%8D%81%E5%85%AB%E5%A4%A9/" class="post-title-link" itemprop="url">代码随想录第十八天</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-31 00:00:00" itemprop="dateCreated datePublished" datetime="2022-03-31T00:00:00+08:00">2022-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-01 10:51:52" itemprop="dateModified" datetime="2022-04-01T10:51:52+08:00">2022-04-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>397</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="哈希表-赎金信"><a href="#哈希表-赎金信" class="headerlink" title="哈希表-赎金信"></a>哈希表-赎金信</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ransom-note/">题目链接</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; magazine.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">            record[magazine[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ransomNote.<span class="built_in">length</span>(); j++)&#123;</span><br><span class="line">            record[ransomNote[j]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span>(record[ransomNote[j]-<span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2022/03/29/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AC%AC%E5%8D%81%E4%B8%83%E5%A4%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/29/leetcode/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AC%AC%E5%8D%81%E4%B8%83%E5%A4%A9/" class="post-title-link" itemprop="url">代码随想录第十七天</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-29 00:00:00 / 修改时间：10:48:44" itemprop="dateCreated datePublished" datetime="2022-03-29T00:00:00+08:00">2022-03-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>438</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="哈希表-两数之和"><a href="#哈希表-两数之和" class="headerlink" title="哈希表-两数之和"></a>哈希表-两数之和</h4><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum/">题目链接</a></p>
<p>这道题用C++的<code>unordered_map</code>,首先不需要有顺序，以及键值不需要相同，从第一个元素开始不断比较以及往<code>myMap</code>里面插数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        std::unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; myMap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> pt = myMap.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(pt != myMap.<span class="built_in">end</span>())</span><br><span class="line">              <span class="keyword">return</span> &#123;pt-&gt;second, i&#125;;  </span><br><span class="line">            myMap.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(nums[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZouFeIYu"
      src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
  <p class="site-author-name" itemprop="name">ZouFeIYu</p>
  <div class="site-description" itemprop="description">reading, coding, travelling</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">81</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">82</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/erkeai" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;erkeai" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:563783592@qq.com" title="E-Mail → mailto:563783592@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-feather"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZouFeIYu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">195k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:57</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
