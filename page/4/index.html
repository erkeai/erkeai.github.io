<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16.ico">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"erkeai.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="reading, coding, travelling">
<meta property="og:type" content="website">
<meta property="og:title" content="hazel&#39;blog">
<meta property="og:url" content="https://erkeai.github.io/page/4/index.html">
<meta property="og:site_name" content="hazel&#39;blog">
<meta property="og:description" content="reading, coding, travelling">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ZouFeIYu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://erkeai.github.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>hazel'blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hazel'blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">58</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">58</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2021/11/14/sample/APT29%20%20Cozy%20Bear%E4%BD%BF%E7%94%A8%E7%9A%84Miniduke/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/14/sample/APT29%20%20Cozy%20Bear%E4%BD%BF%E7%94%A8%E7%9A%84Miniduke/" class="post-title-link" itemprop="url">APT29 / Cozy Bear使用的Miniduke</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-14 00:00:00" itemprop="dateCreated datePublished" datetime="2021-11-14T00:00:00+08:00">2021-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-22 14:57:22" itemprop="dateModified" datetime="2021-12-22T14:57:22+08:00">2021-12-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">样本分析</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇文章详细分析了APT29使用的Miniduke，Minicuke是纯汇编编写的一个后门 ，该恶意软件采用了<strong>控制流整平迷惑</strong>并且实现了多种数据泄露的方法，比如用POST和PUT HTTP方法发送数据给C2服务器，或者在无网络连接的情况下用一个命名管道。后门实现37种不同的功能，如下图。</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps373D.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps373D.tmp.jpg</a>) </p>
<h2 id="技术分析"><a href="#技术分析" class="headerlink" title="技术分析"></a>技术分析</h2><p>首先用IDA打开文件，看到第一个函数setunhandledexceptionfilter，恶意软件将异常过滤器函数设置为特定函数。</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps373E.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps373E.tmp.jpg</a>) </p>
<p>前面的函数有点看不出来是个啥，我们注意看最后一个函数，可以看到用了GetStartupInfo获取STARTUPINFO结构的内容。Sub_4030A4如下图，可见是创建了一个线程。我们点进StartAddress看看</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps373F.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps373F.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3740.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3740.tmp.jpg</a>) </p>
<p>StartAddress函数前部分非常多的Switch case函数，即使是后半段的这些函数也有非常多的switch case结构，<strong>非常多的无用的计算，</strong>并且加载了三个dll。</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3741.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3741.tmp.jpg</a>) </p>
<p>在IDA的图中可以看到startAddress如下，这就是前面说的控制流整平诱惑。StartAddress中的loc_4036F2中就实现了30个case,我们将该跳转用nop替换掉，因为该命令占6字节，nop一个字节，所以要用6个nop。</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3742.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3742.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3753.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3753.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3754.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3754.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3755.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3755.tmp.jpg</a>) </p>
<p>SetErrorCode函数参数为2，作用是让系统不显示Windows错误报告对话框 （0x2 = <strong>SEM_NOGPFAULTERRORBOX</strong>）。加载的三个dll后的sub_407B60中有一个函数sub_417DCC，将在执行期间运行，并使用哈希机制定位。基本上，对于DLL中的每个函数名，恶意软件计算一个4字节的值，并与硬编码的值进行比较。这些函数都是目标：GetProcAddress, GetLongPathNameA, GetLastError, CreateProcessWithLogonW, CryptAcquireContextW, CryptGenRandom, InternetOpenA, InternetConnectA, InternetSetOptionA, HttpOpenRequestA, HttpSendRequestA, HttpQueryInfoA, InternetReadFile, InternetCloseHandle, HttpAddRequestHeadersA。</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3756.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3756.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3757.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3757.tmp.jpg</a>) </p>
<p>在该函数中有一个sub_423FC8函数，红框圈起来的函数就是hashing函数</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3758.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3758.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3759.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3759.tmp.jpg</a>) </p>
<p>现在回到加载dll的目标函数中，下图中的API用于连接CSP，获得指定CSP（真正实行加密的独立模块）的密钥容器的句柄（0x1 = <strong>PROV_RSA_FULL</strong>, 0xF0000040 = <strong>CRYPT_VERIFYCONTEXT</strong> | <strong>CRYPT_SILENT****）</strong></p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps375A.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps375A.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps375B.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps375B.tmp.jpg</a>) </p>
<p>下图函数使用一个子权限分配和初始化安全标识符(SID)</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps375C.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps375C.tmp.jpg</a>) </p>
<p>通过将新的访问控制或审核控制信息合并到现有的ACL结构中来创建新的访问控制列表（ACL）</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps375D.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps375D.tmp.jpg</a>) </p>
<p>通过恶意进程初始化新的安全描述符</p>
<p>(0x1 = <strong>SECURITY_DESCRIPTOR_REVISION</strong>)，并使用setseCurityDescriptordACL API设置DACL（自定义访问控制列表）中的信息</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps375E.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps375E.tmp.jpg</a>) </p>
<p>进程创建了一个Software\Microsoft\ApplicationManager注册键值</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps375F.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps375F.tmp.jpg</a>) </p>
<p>一个新的值AppId被创建，使用GetTickCount函数调用的输出计算此值，它检索自系统启动以来经过的毫秒数</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3760.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3760.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3761.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3761.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3762.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3762.tmp.jpg</a>) </p>
<p>继续查看下一个函数sub_41CD30,</p>
<p>从上面的一个输出被转换并写入缓冲区，以及“AppID”值。将使用传统算法加密此缓冲区，该算法还包括XOR运算符（sub_420200）：</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3772.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3772.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3773.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3773.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3774.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3774.tmp.jpg</a>) </p>
<h3 id="控制流整平"><a href="#控制流整平" class="headerlink" title="控制流整平"></a>控制流整平</h3><p>if-else、while、for具有典型的跳转等结构，即使通过多层嵌套、拓展条件等方法，依然可以通过“切片技术”来判断。有了这些依据，就给程序分析带来很多便利。<br>  正是这个原因，为了增加程序逆向的难度，我们得使得这些特征结构变得模糊，并且能让类似“切片技术”这样基于具体语义分析的方法失效，迫使逆向分析人员进行完整的抽象语义分析，斩断所谓的“捷径”。<br>  控制流整平的策略是这样的，它把所有的典型控制流以及其衍生结构“统而为一”，各种控制流的区别只是语义方面的，增加了理解控制流转换关系的难度。</p>
<p> 控制流整平迷惑，是通过打破程序原有的控制流之间的嵌套和顺序关系，使得变换后的程序控制流扁平化的混淆方法，其基本思想是令程序中所有的基本块拥有共同的前驱和后继代码块。如下图</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3775.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample6/wps3775.tmp.jpg</a>) </p>
<p> 进行控制流整平后，使得面向过程的代码片段，原来比较清晰的控制流向混杂在一起，同时这也比较好的并行图形态，也有利于进一步的迷惑处理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2021/11/13/reverse/EasyRE_REvenge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/13/reverse/EasyRE_REvenge/" class="post-title-link" itemprop="url">buuctf_EasyRE_REvenge</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-13 00:00:00" itemprop="dateCreated datePublished" datetime="2021-11-13T00:00:00+08:00">2021-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-22 15:57:13" itemprop="dateModified" datetime="2021-12-22T15:57:13+08:00">2021-12-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/buuctf/" itemprop="url" rel="index"><span itemprop="name">buuctf</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>220</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="EasyRE-REvenge"><a href="#EasyRE-REvenge" class="headerlink" title="EasyRE_REvenge"></a>EasyRE_REvenge</h3><p>这道题和前面那道easyre结构一样如下，函数中有花指令</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse7/image-20211115101010954.png" alt="image-20211115101010954"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse7/image-20211115110634542.png" alt="image-20211115110634542"></p>
<p>我们edit-patch-changebyte(不是assemble)。0B前面那个00也要改成90</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse7/image-20211115112905196.png" alt="image-20211115112905196"></p>
<p>可以看到还要修改一个地方，全部nop</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse7/image-20211115113230271.png" alt="image-20211115113230271"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse7/image-20211115113438466.png" alt="image-20211115113438466"></p>
<p>发现还是不行，往下一直看会发现全是一样的代码（花指令），写个py脚本全部nop掉（IDA7.0自带IDAPython，但是需要安装python27）,File-Scripts Files就ok</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse7/image-20211115202819745.png" alt="image-20211115202819745"></p>
<p>反汇编后如图,我们自己写个代码</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse7/image-20211115203400188.png" alt="image-20211115203400188"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2021/11/06/paper/A%20Comprehensive%20Study%20on%20Learning-Based%20PE%20Malware%20Family%20Classification%20Methods/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/06/paper/A%20Comprehensive%20Study%20on%20Learning-Based%20PE%20Malware%20Family%20Classification%20Methods/" class="post-title-link" itemprop="url">A Comprehensive Study on Learning-Based PE Malware FamilyClassification Methods</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-06 00:00:00" itemprop="dateCreated datePublished" datetime="2021-11-06T00:00:00+08:00">2021-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-31 15:44:02" itemprop="dateModified" datetime="2021-12-31T15:44:02+08:00">2021-12-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/paper-reading/" itemprop="url" rel="index"><span itemprop="name">paper reading</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文章将主流的基于学习的算法按照其出入格式分为了三类，分别是<strong>基于图像的、基于二进制的和基于反汇编</strong>的。文章基于现在很多放大都没有一个一致的比较，特别是从实际应用场景来看以及在<strong>概念漂移</strong>（指的是数据流中的潜在数据分布随时间发生不可预测的变化,使原有的分类器分类不准确或决策系统无法正确决策）的场景中也没有进行比较。文章的工作主要是在4个不同的数据集和一致的实验设置上对基于学习的PE恶意软件分类方法进行了全面的<strong>实证研究</strong>。根据实验结果发现（1）没有哪类方法明显优于其他方法；（2）所有类型的方法在概念漂移上都表现出性能下降(平均f1分32.23%)；（3）的预测时间和高内存消耗阻碍了现有方法被用于行业使用。</p>
<h3 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h3><p>基于图像的分类方法，在2011年首次被提出，最初采用的是机器学习的方法，但是由于提取复杂纹理特征的开销很高，这些方法通常效率低下。随着深度学习模型在图像分类任务中的不断发展，它逐渐地被运用到恶意软件家族分类场景，表现出了比机器学习方法更好的性能。当然基于图像的方法也有缺点，例如将恶意软件转换为图像会引入新的超参数（例如，图像宽度），并施加不同行中像素之间不存在的空间相关性，这可能是错误的。</p>
<p>基于二进制的方法，以恶意软件的二进制代码为输入，通常采用现有的序列模型，特别是来自自然语言处理(NLP)领域进行分类。最初一般是n-gram算法提取特征然就用算法进行分类检测，但是随着n的增大，计算开销会非常大；随后提出了端到端的浅层CNN模型，但是接收整个二进制文件作为输入需要非常大的内存。为了解决这个问题，提出了只关注PE头的方法。</p>
<p>基于二进制文件的方法不需要领域知识，而是考虑恶意软件二进制文件中的上下文信息。然而，与其他类别的方法相比，将恶意软件样本表示为字节序列可能会带来一些挑战。首先，通过将每个字节作为一个字节序列中的一个单元，恶意软件字节序列的大小可能达到数百万个时间步长，这是相当消耗资源的。其次，相邻的字节在空间上是相关的，但是由于跳转和函数调用，这样的情况可能并不总是保持，因此二进制文件中的信息可能存在不连续性。</p>
<p>基于反汇编的方法，首先将二进制文件分解成汇编代码，并根据函数调用图(FCG)和控制流程图(CFG)等特征执行恶意软件分类，这些特征是从汇编代码中提取的。提出计算图之间的相似性，然后用其作为恶意代码聚类的距离度量。计算图之间的相似性属于计算密集型，会带来很大的性能开销。</p>
<p>也有一些方法从程序代码中提取操作码序列，与其他方法相比，基于反汇编的技术可以更好地捕获代码结构特征，但它们通常需要领域知识，如汇编语言及其相应的分析方法。</p>
<h3 id="实证研究"><a href="#实证研究" class="headerlink" title="实证研究"></a>实证研究</h3><p>首先论文提出了三个研究问题，分别是：</p>
<ul>
<li>1.不同的PE恶意软件族分类方法在不同的数据集上如何执行？</li>
</ul>
<p>指出目前缺乏系统的研究来评估在多个数据集的同一实验设置上一致的不同方法的性能。</p>
<ul>
<li>2.恶意软件概念漂移如何影响各种模型的分类性能？</li>
</ul>
<p>指出概念漂移是PE恶意软件建组分类任务中一个关键的现实问题，评估概念漂移应用场景中不同方法的性能非常重要。</p>
<ul>
<li>3.是什么因素阻碍了当前基于学习的PE恶意软件分类方法在行业中的部署和相应的改进方向？</li>
</ul>
<p>由于之前的研究问题所发现的差距，论文最终目标是为如何使当前基于学习的PE恶意软件分类方法适用于真实的行业场景提供建议。</p>
<p>基于图像的测试模型选了VGG-16、ResNet-50、Inception-V3、IMCFN.</p>
<p>VGG-16通过减少卷积层的参数来提高训练时间，它包含了13个卷积层、5个最大池化层、三个全连接层。所有隐藏层都是用ReLU，输出层使用softmax，优点是结构简单，参数多，拟合能力高。</p>
<p>ResNet的提出是为了解决传统CNN网络在深层信息传输中普遍存在的信息丢失、梯度消失和梯度爆等问题。通过在一个称为跳过连接的结构中将输入直接带到输出中来保护信息的完整性。由于该设计，ResNet-50可以训练一个包含50个隐藏层的更深的网络。ResNet-50使用全局平均池，然后使用最终预测层的softmax。相比VGG-16更有效，因为它的参数要少得多。</p>
<p>InceptionNet目的是找出如何用密集成分来近似最优的局部稀疏结。与ResNet-50一样，Inception-V3最终也使用了一个全局平均池，然后使用softmax作为最终的预测层。与VGG-16相比，它更有效，其参数数量甚至比ResNet-50更少。</p>
<p>IMCFN是使用微调卷积神经网络的基于图像的恶意软件分类，它是针对恶意软件族分类的任务而定制的。它是VGG-16的变种，将前两个FCs中的神经元从4096减少到2048，并增加了一个dropout层来减少过拟合的影响。</p>
<p>基于二进制的测试模型选了Word2Vec+MLP、MalConv.</p>
<p>Word2Vec+MLP的关键思想是，<strong>来自同一族的样本中的字节关系相似，且与不同族的样本明显不同</strong>。因此，<strong>原始字节的向量矩阵</strong>是恶意软件分类的有效特征。首先对原始二进制文件进行预处理，删除5个或更多连续的0x00或0xCC（无意义的字节）。然后将每个文件作为一个语料库，看作由从0x00到0xFF的256个单词组成的。使用Word2Vec中的连续字袋模型(CBOW)获得文件中256字节的嵌入向量，每个文件用一个字节向量升序矩阵表示。MLP将这些矩阵作为输入，并输出相应的族类别。MLP由3个FCs组成，其中由预测类的数量决定，对于前两个FCs，添加一个dropout层。MLP是最直观、最简单的深度神经网络。与VGG-16类似，虽然结构相对简单，但参数较多，可以很好地拟合训练数据。</p>
<p>MalConv是第一个允许将整个恶意软件作为输入的端到端恶意软件检测模型。首先使用嵌入层将原始字节映射到一个固定的8维向量。通过这种方式，它可以通过同时考虑本地和全局上下文来捕获原始二进制文件中的高级位置不变性。然后，使用一个浅层CNN，大滤波器宽度为500字节，结合500步幅。这使得模型能够使用PyTorch以数据并行的方式更好地平衡计算工作负载，从而可以缓解第一个卷积层的GPU内存消耗问题。</p>
<p>作为一个浅层的CNN架构，MalConv克服了一个主要的实际限制，即读取整个恶意软件字节是消耗内存的，它还捕获了原始二进制文件中的全局位置不变性。它允许将嵌入层与卷积层联合训练，以便更好地提取特征。</p>
<p>基于反汇编测试模型选了MAGIC、Word2Vec+KNN、MCSC.</p>
<p>MAGIC是一种端到端的恶意软件检测方法，通过使用深度图卷积神经网络(DGCNN)的属性控制流图（ACFG）。首先将ACFG（将CFG的顶点抽象为离散的数值向量）转换，从恶意软件反汇编文件中提取为一个数值向量。然后，DGCNN将这些不同大小的无序ACFG转换为固定大小和顺序的张量，用于恶意软件家族分类。</p>
<p>Word2Vec+KNN将反汇编文件建模为恶意软件语言，将其操作码序列提取为恶意软件文档，并使用Word2Vec模型生成此类文档的计算表示。这篇论文选择WMD作为KNN分类中文档之间语义紧密度的度量，计算将文档A的所有嵌入单词传输到文档B的所有嵌入单词的成本。</p>
<p>MCSC首先从拆反汇编件中提取操作码序列，并根据SimHash将其编码为相同长度的序列。然后，它将每个SimHash值作为一个二进制像素，并将SimHash位转换为灰度图像。它训练了一个由LeNet-5修改后的CNN结构来对这些灰度图像进行分类。在训练CNN分类器时，采用多哈列和双线性插值来提高模型的精度，并采用主要的块选择来减少图像生成时间。</p>
<p>实验采用了四个数据集，分别是BIG-15,Malimg,MalwareBazaar和MalwareDrift.（前两个开源）</p>
<h3 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h3><p>论文通过实验发现</p>
<ul>
<li><p>1.在所有方法中，基于二进制的模型CBOW+MLP在不同的数据集上表现最好，而没有单个类别的性能显著优于其他类别。</p>
</li>
<li><p>2.迁移学习有可能进一步提高基于图像的PE恶意软件分类方法的有效性，并打开模型内部特征提取层进行微调，以获得更好的迁移学习性能。</p>
</li>
<li><p>3.所有现有的方法在面对现实工业场景的概念漂移时都存在性能较差，因此在评估PE恶意软件族分类方法时应认真考虑。</p>
</li>
</ul>
<p>并且实验结果表明，不同方法的稳定性也差异很大。CBOW+MLP方法虽然在普通机器学习场景中表现最好，但在概念漂移场景中下降幅度最大，这主要是由于其结构简单。相反，MCSC和Word2Vec+KNN的下降率最小。原因是它们都从拆卸文件中提取视码序列，并专注于在恶意软件进化过程中往往被保留的视码序列的本地上下文连接，因此这些方法在概念漂移上表现出稳定的性能。一个有趣的发现是，尽管Word2Vec+KNN也有简单的结构，但在概念漂移下，它的表现比CBOW+MLP更好，这归功于KNN算法，该算法计算未来的样本与所有其他样本之间的相似性距离。因此，它通常需要更长的预测时间。</p>
<ul>
<li>4.CBOW+MLP对概念漂移的性能最差，而MCSC对概念漂移的性能最稳健。结果表明，操作码序列保留了PE恶意软件的家族特征，是概念漂移下分类的有效和鲁棒特征。</li>
</ul>
<p>论文作者向实际应用场景种的合作伙伴提出问题：公司目前采用了哪种分类方法以及原因；在实际适用的场景中，影响合适方法选择的因素是什么？概念漂移在实际应用场景中很常见吗？处理概念漂移的当前状态如何？</p>
<p><strong>目前，在行业应用场景中采用了两种主流方法，即沙箱和基于模式的方法。</strong>基于模式的方法是基于模式/特征数据库的静态检测方法。它在时间和资源消耗方面是有效的，但对噪声、混淆和概念漂移是脆弱的。</p>
<p><strong>PE恶意软件分类方法的行业使用主要受到三个因素的限制，即预测精度和召回率、预测时间和资源消耗，主要资源关注的是运行时内存和CPU使用情况。</strong></p>
<p>作为一个具体的例子，在他们的一个包含基于学习的恶意软件分类模型的产品中，他们要求运行时内存低于1gb，这是我们所有研究的方法都无法满足的。另一个要求是能够在0.1秒内预测一个恶意软件，准确率超过93%，这过滤掉了大多数基于二进制和基于反汇编的方法。</p>
<p><strong>概念漂移通常是由于恶意软件的进化</strong>。例如，在现有的恶意软件想要逃避检测的情况下，可能会有新的非内核功能，如通信和消息传递技术正在改变。这种情况经常发生，并对恶意软件家族分类提出了挑战。目前缺乏特定的机制来处理这种情况，目前的实践通常使用沙箱方法来处理这种场景。另一个观察结果是，除了概念漂移之外，它们还需要应对快速发展的新恶意软件家族和特性的挑战。除了现有学术数据集定义的细粒度家族分类外，行业合作伙伴更感兴趣的是基于恶意软件家族的恶意行为的检测，即特洛伊、Rootkit或勒索软件。<strong>然而，目前还缺乏关于这一方向的研究，很可能是因为没有这样的可用的数据集。</strong></p>
<ul>
<li>5.（1）如何处理快速发展的恶意软件家族，而不是只使用一个或几个数据集进行评估；（2）一个预测精度更高、重量更轻的模型（3）从恶意行为的角度进行恶意软件家族分类。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2021/10/27/sample/A%20step-by-step%20analysis%20of%20the%20new%20malware%20used%20by%20APT28Sofacy%20called%20SkinnyBoy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/27/sample/A%20step-by-step%20analysis%20of%20the%20new%20malware%20used%20by%20APT28Sofacy%20called%20SkinnyBoy/" class="post-title-link" itemprop="url">A step-by-step analysis of the new malware used by APT28/Sofacy called SkinnyBoy</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-27 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-27T00:00:00+08:00">2021-10-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-22 14:51:11" itemprop="dateModified" datetime="2021-12-22T14:51:11+08:00">2021-12-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">样本分析</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇文章主要分析一个dll，该恶意软件与APT28有关。</p>
<p>先拖进IDA,f5反汇编后如下图，第一次见这么简单的dll</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF69E.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF69E.tmp.jpg</a>) </p>
<p>我们查看导出有DllEntryPoint和RunMod，因为我们的IDA静态无法分析dll,所以用rundll32.exe通过调用RunMod函数启动dll</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF69F.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF69F.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A0.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A0.tmp.jpg</a>) </p>
<p>因为这样的动态调试还不会，所以先搁置一下，先用静态查看一下RunMod函数做了什么（Update already）</p>
<h2 id="IDA静态调试"><a href="#IDA静态调试" class="headerlink" title="IDA静态调试"></a>IDA静态调试</h2><p>IDA查看该函数发现，主要功能就是创建两个线程函数</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A1.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A1.tmp.jpg</a>) </p>
<p>先看线程函数下方的sub_10001CF0()函数，这个函数主要的函数是GetMessage，观察函数上下文应该是从线程队列中检索消息,如果线程消息等于22（WM _ ENDSESSION 消息通知应用程序会话是否正在结束），会中断循环。</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A2.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A2.tmp.jpg</a>) </p>
<h3 id="Thread1-StartAddress"><a href="#Thread1-StartAddress" class="headerlink" title="Thread1 StartAddress"></a>Thread1 StartAddress</h3><p>先看第一个thread，一开始的sub_100010C0函数有两条命令行指令systeminfo和tasklist，进去详细查看发现先createpipe创建了个管道<strong>（匿名），</strong>启动cmd执行命令。systeminfo输出用ReadFile函数读出，tasklist同样</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A3.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A3.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A4.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A4.tmp.jpg</a>) </p>
<p>紧接着查看下面的函数sub_100013B0，初步猜测影噶是检索各个文件目录作为目标对象，结合OD看一下是哪些目录</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A5.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A5.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A6.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A6.tmp.jpg</a>) </p>
<p>目录获取完成后，我们继续看下面的函数sub_100016C0就是一些关于堆空间的的分配，猜测是为下面的函数申请空间</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A7.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A7.tmp.jpg</a>) </p>
<p>从Sub_10002900进去看到的函数分析这部分应该是网络连接操作</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A8.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6A8.tmp.jpg</a>) </p>
<p>InternetOpenW API 初始化 WinINet 函数的使用（用户代理被硬编码为“Opera”），使用 InternetSetOptionW 例程(0x6 = INTERNET_OPTION_CONTROL_RECEIVE_TIMEOUT and 0x5 = INTERNET_OPTION_CONTROL_SEND_TIMEOUT)将发送和接收超时设置为 600 秒，InternetConnection用443端口与服务器updaterweb.com建立连接</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6B9.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6B9.tmp.jpg</a>) </p>
<p>Base64加密完数据后就要开始发送了，主要关注下面这个函数，HttpOpenRequestW 例程用于创建 HTTP POST 请求句柄，恶意软件在 HTTP 请求句柄中添加了一个 HTTP 请求标头（“application/x-www-form-urlencoded”），使用 HttpSendRequestExW API 将请求发送到 HTTP 服务器，如下图所示，看到网上的分析443端口连接失败的情况下，会尝试80端口，但是在动静态分析的时候并没有看到。</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6BA.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6BA.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6BB.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6BB.tmp.jpg</a>) </p>
<p>最后线程会将之前创建的事件置为信号状态</p>
<h3 id="Thread2-sub-6BD71960"><a href="#Thread2-sub-6BD71960" class="headerlink" title="Thread2 sub_6BD71960"></a>Thread2 sub_6BD71960</h3><p>线程一开始就将事件之谓无信号状态![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6BC.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6BC.tmp.jpg</a>)</p>
<p>有一个类似的工作流程，从调用 InternetOpenW 函数开始，直到连接到端口 443（或端口 80，如果第一个不成功）上的 C2 服务器。这次的 POST 请求不同，因为它包含用于下载 DLL 文件的“cmd=y”命令：</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6BD.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6BD.tmp.jpg</a>) </p>
<p>恶意软件使用 InternetQueryDataAvailable 例程查询服务器以确定可用数据量，函数sub_10001FD0中有InternetReadFile函数读取dll文件，下前 4 个字节表示数据大小，还有 32 个字节表示内容的 SHA256 哈希值，图中还有一个CryptStringToBinaryA 函数，对base64编码后的文件进行解码(下图是网上分析)</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6BE.tmp.png">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6BE.tmp.png</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6BF.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6BF.tmp.jpg</a>) </p>
<p>CryptAcquireContextA 用于获取 Microsoft RSA 和 AES 加密提供程序 (0x18 = PROV_RSA_AES) 的句柄，CryptCreateHash 例程用于创建 CSP（加密服务提供程序）哈希对象 (0x800c = CALG_SHA_256) 的句柄，在 base64 编码的 DLL 文件被解码后，恶意软件会使用 SHA256 算法哈希应该包含 DLL 文件的缓冲区（CryptHashData）,通过调用CryptGetHashParam API提取哈希值，（0x2 = HP_HASHVAL）,恶意进程验证上面计算出的哈希值是否与 DLL 文件附带的 32 字节缓冲区重合![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C0.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C0.tmp.jpg</a>)</p>
<p>恶意进程会在%TEMP%目录下创建一个名为fvjoik.dll的文件，新创建的文件填充从 C2 服务器下载的潜在 DLL，使用 LoadLibraryW 例程将 DLL 文件加载到当前进程的地址空间中，恶意软件将使用序号 1 执行导出的函数</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C1.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C1.tmp.jpg</a>) </p>
<p>函数完成后，sub_10001000()函数中可以看到采用WinExec函数命令行执行cmd删除dll文件</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C2.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C2.tmp.jpg</a>) </p>
<p>最后还与C2服务器进行了通信，应该是传输了DLL执行的结果</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C3.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C3.tmp.jpg</a>) </p>
<h2 id="OD动态调试"><a href="#OD动态调试" class="headerlink" title="OD动态调试"></a>OD动态调试</h2><p>具体步骤参考博客：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/feiyucq/archive/2010/06/07/1753465.html">https://www.cnblogs.com/feiyucq/archive/2010/06/07/1753465.html</a></p>
<p>拖进去一开始，如果F8或者F7的话进的是DLL的主函数，如果不想跟这些主函数的话可以直接F9，然后OD会再停下来，在最下方的消息栏会提示DLL初始化完成。</p>
<p>如下图的操作点击，然后选择导出函数，在导出函数的地址下个断点就可以直接调试了，点击调用按钮程序就断在这里了</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C4.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C4.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C5.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C5.tmp.jpg</a>) </p>
<p>结合静态分析，查找下图的字符串定位函数位置</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C6.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C6.tmp.jpg</a>) </p>
<p>调试f7进SHGetFolderPathW函数，可以看到该函数想获取的是桌面文件夹路径</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C7.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C7.tmp.jpg</a>) </p>
<p>由静态分析的图可以看出后一个函数PathAddBackslashW是在路径后加反斜杠，通过findfirstfile和findNextfile枚举桌面所有文件,并在文件夹名称前后添加了18个“#”字符然后再与提取的文件和目录列表和前面的字符串连接起来</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C8.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6C8.tmp.jpg</a>) </p>
<p>以下目录也是后门的目标“C:\Program Files”, “C:\Program Files (x86)”, “C:\Users&lt; User &gt;\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Administrative Tools”, “C:\Users&lt; User &gt;\AppData\Roaming”, “C:\Users&lt; User &gt;\AppData\Roaming\Microsoft\Windows\Templates”, “C:\WINDOWS” and “C:\Users&lt; User &gt;\AppData\Local\Temp”</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6D9.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6D9.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6DA.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6DA.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6DB.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6DB.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6DC.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6DC.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6DD.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6DD.tmp.jpg</a>) </p>
<p>使用 GetComputerNameA API 检索本地计算机的 NetBIOS 名称；GetUserNameA 用于提取与当前线程关联的用户名；恶意软件通过调用 GetVolumeInformationW 的函数提取当前目录根目录的卷序列号；systeminfo 命令的输出加 tasklist 命令的输出加目标目录列表及其内容使用 CryptBinaryToStringA API (0x1 = CRYPT_STRING_BASE64) 进行 base-64 编码（IDA）</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6DE.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6DE.tmp.jpg</a>) </p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6DF.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6DF.tmp.jpg</a>) </p>
<p>（上面这张图应该是第二个线程的，因为命令中包含cmd=y，该命令用于下载dll文件，因为两个线程在网络连接那一块是类似的，所以通过查找字符串定位函数位置的时候找错了）</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6E0.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6E0.tmp.jpg</a>) </p>
<h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><p>主线程完成最后的收尾工作，将之前创建的事件设置为信号状态，使用GetExitCodeThread API获取两个线程的终止状态：</p>
<p>![img]<a target="_blank" rel="noopener" href="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6E1.tmp.jpg">https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/sample5/wpsF6E1.tmp.jpg</a>) </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2021/10/25/reverse/overlong/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/25/reverse/overlong/" class="post-title-link" itemprop="url">buuctf_overlong</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-25 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-25T00:00:00+08:00">2021-10-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-22 10:26:43" itemprop="dateModified" datetime="2021-12-22T10:26:43+08:00">2021-12-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/buuctf/" itemprop="url" rel="index"><span itemprop="name">buuctf</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>339</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="overlong"><a href="#overlong" class="headerlink" title="overlong"></a>overlong</h4><p>用PEid显示有壳，但是ExInfo不是，直接拖到IDA看看</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse6/image-20211025101621373.png" alt="image-20211025101621373"></p>
<p>我们转到sub_401160函数看一下，图中的\x1c是十进制的28</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse6/image-20211025104708760.png" alt="image-20211025104708760"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse6/image-20211025104824155.png" alt="image-20211025104824155"></p>
<p>unk_402008指针指向的内容与TEXT(a1)一共进行了28次的一些字符操作。但是该指针指向的内容不止28个字符，点击进去查看有175个</p>
<p>exe一开始运行是这样的，说从未破坏编码，那就直接将其改为读取175个</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse6/image-20211025105732834.png" alt="image-20211025105732834"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse6/image-20211025110224330.png" alt="image-20211025110224330"></p>
<p>这样直接修改会有错误，提示Invalid operand，可能是吧修改的数据会覆盖掉后面的一些数据，我们拖进OD试试，发现改了以后后面的代码也变了</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse6/image-20211025111317713.png" alt="image-20211025111317713"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse6/image-20211025111342988.png" alt="image-20211025111342988"></p>
<p>直接修改二进制码</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse6/image-20211025113152358.png" alt="image-20211025113152358"></p>
<p>运行后如图，得到flag</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse6/image-20211025113214588.png" alt="image-20211025113214588"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    这道题目的收获主要是关于修改代码，一般都是直接修改，还没有考虑过会改变后面的数据。以后修改代码最好用OD，可以看到后面代码是否被修改</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2021/10/18/Cheese_point/CFG%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/18/Cheese_point/CFG%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">CFG机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-18 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-18T00:00:00+08:00">2021-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-22 14:24:47" itemprop="dateModified" datetime="2021-12-22T14:24:47+08:00">2021-12-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">知识点补充学习</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Control Flow Guard（CFG）是较新的windows漏洞利用缓解措施，旨在解决内存损坏漏洞。 针对的是间接跳转的保护，比如call eax，jmp eax等。 CFG扩展了先前的漏洞缓解技术，例如GS，DEP和ASLR。毫无疑问，它将大大改变攻击者的利用技术。就像ALSR导致了堆喷射技术的出现，和DEP导致了ROP技术的出现。微软的CFG实现是基于间接调用的目标必须是一个可靠的函数的起始位置。</p>
<p>以往是没有蓝色那行的，它执行的操作是将目标地址接受为参数，并实现CFG，下图是没有启用CFG的时候，有一个间接调用，他的目标地址不在编译的时候决定，而是在运行的时候。</p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps267A.tmp.jpg" alt="img"> </p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/CheesePoint1/wps267B.tmp.jpg" alt="img"> </p>
<p>CFG主要关注缓解间接调用和调用目标不可靠（不是一个有效的函数起始地址）的问题（在攻击中，这是shellcode的第一步）。所以CFG的实现是基于间接调用的目标必须是一个可靠的函数的起始位置。下图是调用目标代码后</p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps267C.tmp.jpg" alt="img"> </p>
<p>在间接调用之前，目标地址传给_guard_check_icall函数，在其中实现CFG。在没有CFG支持的Windows中，这个函数不做任何事。在Windows 10中，有了CFG的支持，它指向ntdll!LdrpValidateUserCallTarget函数。这个函数使用目标地址作为参数，并且做了以下事情：</p>
<p>**1.**访问一个bitmap（称为CFGBitmap），其表示在进程空间内所有函数的起始位置。在进程空间内每8个字节的状态对应CFGBitmap中的一位。如果在每组8字节中有函数的起始地址，则在CFGBitmap中对应的位设置为1；否则设置为0。</p>
<p>**2.**将目标地址转化为CFGBitmap中的一个位。我们以00b01030为例：</p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps267D.tmp.jpg" alt="img"> </p>
<p>高位的高位的3个字节（蓝色圈中的24位）是CFGBitmap（单位是4字节/32位）的偏移。在这个例子中，高位的3个字节相当于0xb010。因此，CFGBitmap中指向字节单元的指针是CFGBitmap的基址加上0xb010。</p>
<p>同时，第四位到第八位（红色圈中的）有值X。如果目标地址以0x10对齐（目标地址&amp;0xf==0），则X为单位内的位偏移值。如果目标地址不以0x10对齐（目标地址&amp;0xf!=0），则X|0x1是位偏移值。</p>
<p>在这个例子中，目标地址是0x00b01030，表达式0x00b01030&amp;0xf值为0。X的值为6，所以偏移也是6。</p>
<p>**3.**接下来就是转换成CFGBitmap中的一位，上一步得出位偏移是6，所以从零开始数。我们将第六位置为1，这意味着间接调用的目标是可靠的</p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps267E.tmp.jpg" alt="img"> </p>
<p>我们会产生几个问题：</p>
<ul>
<li><ol>
<li>CFGBitmap的位信息来自哪里？</li>
</ol>
</li>
<li><ol start="2">
<li>何时且怎么生成CFGBitmap？</li>
</ol>
</li>
<li><ol start="3">
<li>系统怎么处理不可靠的间接调用触发的异常？</li>
</ol>
</li>
</ul>
<h3 id="深入CFG的实现"><a href="#深入CFG的实现" class="headerlink" title="深入CFG的实现"></a>深入CFG的实现</h3><p>启用CFG的情况下用编译器编译的PE文件，用VS的dumpbin.exe转储出来，可以看到以下内容。</p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps267F.tmp.jpg" alt="img"> </p>
<p>Guard CF address of check-function pointer：_guard_check_icall的地址。在Windows 10预览版中，当PE文件加载时，_guard_check_icall将被修改并指向nt!LdrpValidateUserCallTarget。</p>
<p>Guard CF function table：函数的相对虚拟地址（RVA）列表的指针，其包含了程序的代码。每个函数的RVA将转化为CFGBitmap中的“1”位。换句话说，CFGBitmap的位信息来自Guard CF function table。</p>
<p>Guard CF function count：函数RVA的个数。</p>
<p>CF Instrumented：表明程序中启用了CFG。</p>
<h4 id="1-OS对CFG机制的支持"><a href="#1-OS对CFG机制的支持" class="headerlink" title="1.OS对CFG机制的支持"></a>1.OS对CFG机制的支持</h4><p>在OS引导阶段，第一个与该机制相关的函数是MiInitializeCfg，这个函数的主要任务是创建包含CFGBitmap的共享内存，调用时间可以在NT内核阶段1的内存管理器初始化（MmInitSystem）的时候找到,如图，在这个初始化期间，会调用MmInitSystem两次，第一个MmInitSystem将进入MiInitializeCfg，该函数的主要功能如下流程图所示。</p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps2680.tmp.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps2681.tmp.jpg" alt="img"> </p>
<ul>
<li><p>步骤A：注册表值来自HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session\Manager\kernel: MitigationOptions</p>
</li>
<li><p>步骤B：MmEnableCfg是一个全局变量，它被用来表示系统是否启用CFG功能.</p>
</li>
<li><p>步骤C：MiCfgBitMapSection的DesiredAccess允许所有的权限；它的分配类型是“reserve”。<strong>共享内存的大小可能会因为Win10的版本而有所不同。</strong>对于build 6.4.9841，它按用户模式空间大小计算。表达式是size=User Mode Space Size&gt;&gt;6。（&gt;&gt;X：右移X位）。对于build 10.0.9926，这个大小是0x3000000。CFG bitmap能表示整个用户模式空间。MiCfgBitMapSection是CFG实现的核心组件，因为它被用来包含CFGBitmap。</p>
</li>
</ul>
<h4 id="2-获得压缩RVA列表信息的函数且保存到映像的Control-Area结构"><a href="#2-获得压缩RVA列表信息的函数且保存到映像的Control-Area结构" class="headerlink" title="2.获得压缩RVA列表信息的函数且保存到映像的Control_Area结构"></a>2.获得压缩RVA列表信息的函数且保存到映像的Control_Area结构</h4><p>PE映像第一次加载到系统。NT内核将调用MiRelocateImage来重定位。MiRelocateImage将调用MiParseImageCfgBits。在函数MiParseImageCfgBits中，PE映像的压缩的RVA列表被计算且存储在PE映像节中的Control_Area数据结构。在系统引导期间一个PE映像只发生一次。</p>
<p>当PE再次加载进进程，NT内核将调用MiRelocateImageAgain。因为它的压缩的RVA列表已经保存了（且不需要再次计算），MiRelocateImageAgain不需要调用MiParseImageCfgBits，这样节省一些处理时间。因为微软实现CFG需要消耗时间和空间。在MiRelocateImage中，它的CFG相关的部分被如下描述：</p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps2682.tmp.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps2683.tmp.jpg" alt="img"> </p>
<p>下面我们详细了解一下MiParseImageCfgBits这个函数，首先看一下这个函数调用的上下文。</p>
<p>函数MiParseImageCfgBits有5个参数：</p>
<p>a) 映像节的Control_Area结构的指针</p>
<p>b) 映像文件内容的指针</p>
<p>c) 映像大小</p>
<p>d) 包含PE可选头结构的指针</p>
<p>e) 输出压缩的CFG函数RVA列表的指针</p>
<p>MiParseImageCfgBits的主要工作如下：</p>
<p>a) 从映像的Load Config Table获得函数RVA列表</p>
<p>b) 使用压缩算法压缩列表，以便在小空间保存列表</p>
<p>c) 创建压缩的RVA列表作为输出</p>
<h4 id="3-CFGBimap共享内存对象被映射的两种用途"><a href="#3-CFGBimap共享内存对象被映射的两种用途" class="headerlink" title="3.CFGBimap共享内存对象被映射的两种用途"></a>3.CFGBimap共享内存对象被映射的两种用途</h4><p>a) 用来写共享模块（.DLL文件等）的bits。在bits写入完成后，映射将释放。通过这个映射写入的bits信息是共享的，意味着它能被操作系统内所有的进程读取。这个映射发生在MiUpdateCfgSystemWideBitmap函数中。（该小节的详细内容请看5.a）</p>
<p>b) 用来写私有的bits和读取校验间接调用的bits。通过这个映射写入的bits是私有的，意味着它只能被当前进程读取。这个映射的生存周期与进程的生命周期相同。这个映射发生在MiCfgInitializeProcess中。</p>
<p>基于调用堆栈，我们知道它在一个正在初始化的进程中被映射。映射的基    址和长度将被保存在类型为MI_CFG_BITMAP_INFO的结构体中，且地址被    修改了。稍后将讨论怎么将私有的bits写入映射空间中。              MI_CFG_BITMAP_INFO的结构如下：</p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps2684.tmp.jpg" alt="img"> </p>
<h4 id="4-将RVA列表翻译为CFGBitmap中的bits"><a href="#4-将RVA列表翻译为CFGBitmap中的bits" class="headerlink" title="4.将RVA列表翻译为CFGBitmap中的bits"></a>4.将RVA列表翻译为CFGBitmap中的bits</h4><p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps2685.tmp.jpg" alt="img"> </p>
<p>在深入了解每个场景之前，要搞清楚一些背景信息。在每个进程中，包含CFGBitmap的空间被分为两部分：共享和私有。</p>
<p>MiCfgBitMapSection是一个共享内存对象，包含了CFGBitmap的共享的bitmap的内容。它与每个进程共享。当它在自己的虚拟内存空间中映射MiCfgBitMapSection时，每个进程看见的内容都相同。共享模块（dll等）的bitmap信息将通过4.a节描述的映射方法写入。</p>
<p>然而每个进程需要CFGBitmap的一部分不是被所有进程共享的。它需要私有写入一些模块的bitmap信息到CFGBitmap中。这个私有的部分将不和所有的进程共享。EXE模块的bitmap信息使用4.b节描述的方法写入。</p>
<p><strong>a) 在ReloadImage/ReloadImageAgain中，通过MiUpdateCfgSystemWideBitmap写入共享模块（dll等）的bits。</strong></p>
<p>如前面第二部分所见，在得到压缩的函数的RVA列表并将它保存到Control_Area结构后，它将调用MiSelectImageBase。这个函数是ASLR实现的核心。它返回最终选择的基址。选择的基地址对于写bit信息到CFGBitmap中非常重要。在得到基地址后，它将调用MiUpdateCfgSystemWideBitmap。</p>
<p>MiUpdateCfgSystemWideBitmap的主要任务是将压缩的RVA列表翻译为CFGBitmap中的“1”bit。通过这个函数写入的bitmap信息是共享的，且被操作系统所有的进程共享。这个函数只针对共享模块有效（dll文件等）。</p>
<p>这个函数有三个参数MiUpdateCfgSystemWideBitmap有3个参数：</p>
<p>指向Control_Area结构的指针</p>
<p>映像的基址</p>
<p>指向压缩的RVA列表的指针</p>
<p>MiUpdateCfgSystemWideBitmap的主要逻辑如下：</p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps2686.tmp.jpg" alt="img"> </p>
<p>在步骤B中，它映射CFGBitmap共享内存到系统进程空间中。它不映射所有共享内存的全部大小。它转化映像的基址为CFGBitmap的偏移，且使用转化的结果作为映射的起始地址。转为过程如下：</p>
<p>Bitmap的偏移=基地址&gt;&gt;6。按这个公式，映射大小是映像大小右移6位。这个方法在映像需要重定位（ReloadImageAgain函数）的时候也会被使用</p>
<p><strong>b) 在进程初始化阶段写私有模块（exe文件等）的bits。</strong>它将调用MiCommitVadCfgBits，其是一个调度函数。你能使用图13作为参考。它在确定的场景被调用。该函数的主要任务是为输入虚拟地址描述符所描述的空间写入bits。主要逻辑如下：</p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps2687.tmp.jpg" alt="img"> </p>
<p>MiMarkPrivateImageCfgBits函数实现向CFG Bitmap中写入私有模块（exe等）的bit信息。当系统映射一个EXE的节或者启动一个进程时，这个函数被调用。</p>
<p>这个函数有2个参数：</p>
<ol>
<li><p>Cfg信息的全局变量地址</p>
</li>
<li><p>映像空间的VAD</p>
</li>
</ol>
<p>VAD是用来描述虚拟内存空间范围的一个结构。</p>
<p>函数的主要任务是将输入VAD的相关的压缩RVA列表转化为bitmap信息，且在CFGBitmap中写入bits。函数主要逻辑如下：</p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps2688.tmp.jpg" alt="img"> </p>
<p>在步骤A中，压缩的RVA列表能从输入的VAD关联的Control_Area结构中获得，在MiRelocateImage中保存（参见第二节）。</p>
<p>这个函数的主要步骤是步骤C。它实现私有写入映射的MiCfgBitMapSection32节（在3.b节有描述）。写入的私有的bits的映射是只读的。向映射的空间写入bits怎么实现？关键步骤如下：</p>
<p>i. 获得映射的空间地址的物理地址（PFN）</p>
<p>ii. 申请一个空的页表入口（PTE）并使用上步获得的物理地址填充PTE，新的PTE被映射到相同的物理页，其包含了映射的MiCfgBitMapSection32的虚拟地址。</p>
<p>iii. 复制结果缓冲区（图12）到新的PTE。物理页将包含结果缓冲区的内容</p>
<p>iv. 释放新的PTE</p>
<p>在上面步骤完成后，bitmap信息被拷贝到当前进程地址空间内。但是不会影响MiCfgBitMapSection。换句话说，MiCfgBitMapSection不知道bitmap改变了。其他进程也不会看到改变；新添加的bitmap信息对当前进程是私有的。</p>
<p><strong>c)写虚拟内存操作的bits。</strong>如果一个进程有虚拟内存操作，它可能会影响CFGBitmap中的bitmap的bits状态。从图13的场景看，它将调用MiMarkPrivateImageCfgBits。函数的主要工作是复制“1”或“0”页到CFGBitmap空间中。</p>
<p>i. 对于NtAllocVirtualMemory函数</p>
<p>如果一个进程调用NtAllocVirtualMemory函数来分配具有可执行属性的虚拟内存，NT内核将设置CFGBitmap中相关的位为“1”。但是如果分配的内存的保护属性有 SEC_WRITECOMBINE，NT内核将使用“0”设置bitmap。</p>
<p>ii. 对于MiProtectVirtualMemory函数</p>
<p>如果一个进程调用MiProtectVirtualMemory来改变虚拟内存的保护属性为“可执行”，NT内核将设置CFGBitmap相关位为“1”。</p>
<p><strong>d) 写映像和数据段映射的bits</strong></p>
<p>i. 对于映像（dll，EXE等）节的映射，如果映像不是共享的，处理过长如4.b节描述。如果是共享的，将由图13中的MiMarkPrivateImageCfgBits函数处理。它遍历映射空间中的每个页且将页地址转化为CFGBitmap中的偏移。</p>
<p>i. 如果CFGBitmap中的偏移不被PrototypePTE支持，相关的bits信息将被拷贝到CFGBitmap空间中。</p>
<p>ii. 如果CFGBitmap中的偏移已经有bitmap信息，CFGBitmap部分将改为只读。</p>
<p>ii. 对于数据段的映射，处理与前面的c.i相同。</p>
<h4 id="5-用户模式下获取CFGBitmap映射的地址"><a href="#5-用户模式下获取CFGBitmap映射的地址" class="headerlink" title="5. 用户模式下获取CFGBitmap映射的地址"></a>5. 用户模式下获取CFGBitmap映射的地址</h4><p>上面提到的步骤都发生在内核模式下。但是对于用户模式，CFGBitmap需要访问LdrpValidateUserCallTarget函数，它在上一部分已经描述了。当创建一个进程，NT内核调用PspPrepareSystemDllInitBlock函数来写CFGBitmap映射的地址和全局变量的长度，其数据结构是PspSystemDllInitBlock结构。PspSystemDllInitBlock是修正过的地址并且从用户模式和内核模式都能访问。用户模式可以访问硬编码的PspSystemDllInitBlock全局变量的CFGBitmap字段。</p>
<h4 id="6-LdrpCfgProcessLoadConfig"><a href="#6-LdrpCfgProcessLoadConfig" class="headerlink" title="6. LdrpCfgProcessLoadConfig"></a>6. LdrpCfgProcessLoadConfig</h4><p>在之前的图中，_guard_check_icall函数指针将指向ntdll的LdrpValidateUserCallTarget。何时发生，如何发生？LdrpCfgProcessLoadConfig来完成这个工作。进程创建过程将在用户模式下调用LdrpCfgProcessLoadConfig。</p>
<h4 id="7-RtlpHandleInvalidUserCallTarget"><a href="#7-RtlpHandleInvalidUserCallTarget" class="headerlink" title="7.RtlpHandleInvalidUserCallTarget"></a>7.RtlpHandleInvalidUserCallTarget</h4><p>在所有的准备都完成后，如果间接调用的目标地址相关的位在CFGBitmap中不是“1”，将触发CFG。进程将采取行动处理这个异常。处理函数是RtlpHandleInvalidUserCallTarget。这个函数使用间接调用的目标为唯一的参数。函数的主要逻辑如下：</p>
<p><img src="file:///C:\Users\16434\AppData\Local\Temp\ksohtml\wps2689.tmp.jpg" alt="img"> </p>
<p>函数的主要流程是校验DEP状态和触发int 29中断，这个内核中断处理例程是KiRaiseSecurityCheckFailure。它的行为是结束进程。</p>
<p>如果一个间接调用的目标地址的CFGBitmap中的相关的位不能访问（如超出了CFGBitmap空间），意味着目标地址是不可靠的。系统将抛出访问异常。当这个异常回到用户模式的处理函数KiUserExceptionDispatcher时，它将调用RTLDispatchException。在RTLDispatchException中，它将校验异常发生的地址。如果指令的地址能访问CFGBitmap，它将继续调用RtlpHandleInvalidUserCallTarget。</p>
<p>如果一个进程需要自定义CFGBitmap，它能调用ntdll中的NtSetInformationVirtualMemory。在内核中函数MiCfgMarkValidEntries实现了这个功能。MiCfgMarkValidEntries以一个缓冲区和长度作为参数。缓冲区中的每个单位是8字节。头四个字节是目标地址，其想在CFGBitmap中设置相关的位，且后四个字节是设置“0”或“1”的标志。MiCfgMarkValidEntries自定义的CFGBitmap只在当前进程能看见。</p>
<p>如果一个攻击者需要改变用户模式下的CFGBitmap的内容，是不可能的。因为CFGBitmap被映射为只读（在3.b节讨论过）。不管改内存保护属性还是向空间中写值都将失败。</p>
<h3 id="CFG的弱点"><a href="#CFG的弱点" class="headerlink" title="CFG的弱点"></a>CFG的弱点</h3><p>当然，这个机制不是没有弱点的。指出了一些弱点如下：</p>
<p>CFGBitmap空间地址存储在修正过的地址中，其能被用户模式代码获得。这在CFG实现中讨论过。这是很重要的安全问题，但是被简单的放过了。</p>
<p>如果主模块没有开启CFG，即使加载的启用了CFG的模块，进程也不会受保护。</p>
<p>基于最后一个图，如果一个进程的主模块禁用了DEP（通过/NXCOMPAT:NO），能绕过CFG访问处理，即使间接调用的目标地址是不可靠的。</p>
<p>在CFGBitmap中的每个bit在进程空间中表示8个字节。因此如果一个不可靠的目标地址少于8个字节，CFG将认为是可靠的。</p>
<p>如果目标函数是动态生成的（类似JIT技术），CFG的实现不能保护。这是因为NtAllocVirtualMemory将在CFGBitmap中为所有分配的可执行的内存空间设置为“1”（4.c.i描述）。通过MiCfgMarkValidEntries自定义的CFGBitmap解决这个问题是可能的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2021/10/18/%E8%84%B1%E5%A3%B3%E5%AD%A6%E4%B9%A0/%E5%8A%A0%E5%A3%B3%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/18/%E8%84%B1%E5%A3%B3%E5%AD%A6%E4%B9%A0/%E5%8A%A0%E5%A3%B3%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">加壳知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-18 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-18T00:00:00+08:00">2021-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-22 16:30:32" itemprop="dateModified" datetime="2021-12-22T16:30:32+08:00">2021-12-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%84%B1%E5%A3%B3%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">脱壳学习</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="脱壳存根"><a href="#脱壳存根" class="headerlink" title="脱壳存根"></a>脱壳存根</h3><p>​    脱壳存根是一个类似于一个exe加载器，如果静态分析某个加壳的exe，实际上分析的是脱壳存根。主要执行如下：</p>
<pre><code>* 将原始程序脱壳到内存
* 解析原始可执行文件的所有导入函数
* 将可执行程序转移到原始的程序入口点（EOP）
</code></pre>
<h3 id="解析函数导入表"><a href="#解析函数导入表" class="headerlink" title="解析函数导入表"></a>解析函数导入表</h3><ul>
<li><p>导入Loadlibrary和GetProcAddress</p>
</li>
<li><p>保持原始导入表的完整，让windows加载器加载所有dll以及导入函数</p>
</li>
<li><p>为原始导入表种的每个dll保留一个导入函数</p>
</li>
<li><p>不导入任何函数，在不用函数的前提下，自己从库中查找所有需要的函数或者首先找到LoadLibrary和GetProcAddress，然后定位其他的库</p>
<p><u>第二种和第三种静态分析都会很容易看到导入库。</u></p>
</li>
</ul>
<h3 id="尾部跳转"><a href="#尾部跳转" class="headerlink" title="尾部跳转"></a>尾部跳转</h3><p>​    完成脱壳后必须使用尾部跳转指令跳转到OEP执行，jmp是最简单的指令，所以有些使用ret或者call来隐藏。有时还会使用操作系统转移控制的函数来掩盖（譬如NtContinue、ZwContinue）。</p>
<h3 id="脱壳过程"><a href="#脱壳过程" class="headerlink" title="脱壳过程"></a>脱壳过程</h3><p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/image-20211129202544768.png" alt="image-20211129202544768"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/image-20211129202522905.png" alt="image-20211129202522905"></p>
<h3 id="脱壳分类"><a href="#脱壳分类" class="headerlink" title="脱壳分类"></a>脱壳分类</h3><h4 id="自动脱壳"><a href="#自动脱壳" class="headerlink" title="自动脱壳"></a>自动脱壳</h4><p>​    自动静态脱壳解压缩或者解密一个可执行文件，但是仅仅只针对某个壳。PE Explorer提供了一些默认安装的静态脱壳插件，支持NSPack、UPack、UPX。</p>
<p>​    自动动态脱壳程序运行可执行文件，并让脱壳存根脱出原始的可执行文件。自动的脱壳程序必须确定脱壳存根的结束位置，原始文件的开始位置。但是目前并没有非常好用的公开的自动动态脱壳程序。</p>
<h4 id="手动脱壳"><a href="#手动脱壳" class="headerlink" title="手动脱壳"></a>手动脱壳</h4><ul>
<li><p>找到加壳算法，然后编写程序逆向运行它。</p>
</li>
<li><p>运行托克程序，让脱壳存根帮你工作。（让它从内存中转储出进程，然后再手动修正PE头部）</p>
<h5 id="用UPX的壳尝试一下OllyDbg脱壳"><a href="#用UPX的壳尝试一下OllyDbg脱壳" class="headerlink" title="用UPX的壳尝试一下OllyDbg脱壳"></a>用UPX的壳尝试一下OllyDbg脱壳</h5><h5 id="重构导入表"><a href="#重构导入表" class="headerlink" title="重构导入表"></a>重构导入表</h5><p>​    当OllyDump重构导入表失败时，可以使用导入重构器（ImpRec）。</p>
<p>操作系统如何填充IAT：</p>
<p>​      1:定位导入表</p>
<p>​      2:解析第一个IID(IMAGE_IMPORT_DESCRIPTOR)项,根据IID中的第4个字段定位DLL的名称</p>
<p>​      3:根据IID项的第5个字段DLL对应的IAT项的起始地址</p>
<p>​      4:根据IAT中的指针定位到相应API函数名称字符串</p>
<p>​      5:通过GetProcAddress获取API函数的地址并填充到IAT中</p>
<p>​      6:当定位到的IAT项为零的时候表示该DLL的API函数地址获取完毕了,接着继续解析第二个IID,重复上面的步骤。</p>
<p>1)定位导入表</p>
<p> <img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/wps5B8D.tmp.jpg" alt="img"></p>
<p>2)定位到导入表的起始地址</p>
<p> <img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/wps5B8E.tmp.jpg" alt="img"></p>
<p>3)根据第一个IID项中的第四个字段得到DLL名称字符串的指针,这里指向的是USER32.DLL</p>
<p> <img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/wps5B8F.tmp.jpg" alt="img"></p>
<p>根据第五个字段的内容定位到IAT项的起始地址,这里是403184,我们定位到该地址处。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/wps5B90.tmp.jpg" alt="img"> </p>
<p>这里我们可以看到已经被填充了正确的API函数的入口地址,跟我们dump出来的结果一样,我们再来看看相应的可执行文件偏移处的内容是什么。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/wps5B91.tmp.jpg" alt="img"> </p>
<p>这里我们可以看到第一个API函数的名称位于4032CC地址处,我们定位到该地址处。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/wps5BA1.tmp.jpg" alt="img"> </p>
<p>第一个API函数是KillTimer,我们在OD中看到的KillTimer的入口地址是操作系统调用GetProcAddress获取到的。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/wps5BA2.tmp.jpg" alt="img"> </p>
<p>这里我们可以看到KillTimer的入口地址为77D18C42。该地址将被填充到IAT相应单元中去覆盖原来的值。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/wps5BA3.tmp.jpg" alt="img"> </p>
<p>这里是IAT中的第一元素。</p>
<p>我们再来看下一个元素,向后偏移4就是,来看一看该API函数名称字符串的指针是多少。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/wps5BA4.tmp.jpg" alt="img"> </p>
<p>定位到可执行文件的相应偏移处:</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/wps5BA5.tmp.jpg" alt="img"> </p>
<p>32D8即4032D8,来看看该API函数的名称是什么,这里由于该指针不为零,说明该API函数还是位于USER32.DLL中的。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/wps5BA6.tmp.jpg" alt="img"> </p>
<p>这里我们可以看到第二个API函数是GetSystemMetrics,通过该函数名称可以通过GetProcAddress获取到其函数地址然后填充到IAT中。接下来按照以上步骤依次获取USER32.DLL中的其他的函数地址,直到遇到的IAT项为零为止。我们来看一看可执行文件中结束项位于哪里。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/wps5BA7.tmp.jpg" alt="img"> </p>
<p>我们可以看到当IAT中元素为零的时候表明USER32.DLL就搜索完毕了,</p>
<h5 id="手动修复导入表"><a href="#手动修复导入表" class="headerlink" title="手动修复导入表"></a>手动修复导入表</h5><p>​    前面的工具是搜索内存中的导入函数来重构导入表，但是也有失败的时候。先了解一下导入表如何工作的。导入表在内存中实际有两个表，<u>一个是函数名称或者序号列表，其中包含记载器或脱壳存根需要的函数名称或者序号；第二个表是所有导入函数的地址列表。</u>实际上运行的时候只需要第二个，所以加壳程序可以通过移除名字列表阻止分析。这时候就需要手动重构。</p>
<p>​    在反汇编中遇到导入函数时，逐个进行修复是最简单的策略，比如下图为例，IDA中DWORD处的值明显位于加载程序的地址范围之外，使用OD打开文件，将光标移动到该处查看内容，OD标注为WriteFile,所以我们可以将其标注。</p>
<p>​    另外一种方法是需要运行脱壳程序，如果发现了导入函数表就看可手动重构原始的导入表，也可以写个脚本来帮助输入这些信息，缺点是复杂又费时。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/image-20211201103634458.png" alt="image-20211201103634458"></p>
<h5 id="查找OEP"><a href="#查找OEP" class="headerlink" title="查找OEP"></a>查找OEP</h5><p>​    自动工具查找OEP,最常使用的是OllyDump。通常脱壳存根与可执行文件不在一个节中，使用step-over或者step-into的方法，当程序跳转到另外一个节中运行时，OllyDbg可以探测到这种转移，并在那里进行中断。call函数就是用来调用其他节的代码，这种方法旨在防止OllyDbg错误标注这些调用OEP的曹祖破，step-over方法将跳过所有call指令。但是如果该call没有返回，那么OllyDbg就会定位到OEP。<u>因此一些恶意代码经常包含一些没有返回的call，以此来干扰分析。</u></p>
<p>​    所以实际情况要结合step-over和step-into方法。</p>
<p>​    <strong>手动查找OEP</strong></p>
<p>​    <strong>1.<strong>最简单的就是查找尾部跳转指令（</strong>一串无效字节指令前的最后一条有效指令</strong>），填充这些字节的目的是为了保证节的字节对齐。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/tuoke/image-20211130161428842.png" alt="image-20211130161428842"></p>
<p>​    图中非常明显的标志是：位于尾部但是<u>链接到了一个很远的位置</u>（<strong>正常情况为几百个字节以内</strong>），并且<u>一般情况下跳转指令之后会有一个返回，但是图中全是一些无意义代码</u>。</p>
<p>​    在IDA中，<u>如果是一个尾部跳转会标注为<strong>红色</strong></u>。</p>
<p>​    在脱壳存根开始运行时，<u>尾部跳转的地址不包含有效指令，但是一旦被运行就肯定包含有效指令。</u></p>
<p>​    <strong>2.<strong>在栈上设置读断点。反汇编中的大部分函数，包括脱壳存根都是以push开头，首先在栈中记录第一个入栈的内存地址，然后在这个栈位置设置一个读断点，只有在脱壳完成的情况下，才能获取原始push的堆栈地址。所以在pop指令获取那个地址的时候，就会命中断点。（</strong>通常尾部跳转紧跟pop</strong>）</p>
<p>​    **3.**在代码中每个循环后面设置断点（通过扫描代码来识别循环，并且在每个循环之后设置断点）</p>
<p>​    **4.**在GetprocAddress函数设置断点。</p>
<p>​    **5.**在被原始程序调用且继续向后工作的函数上设置断点。因为壳通常相同，因此可以在它调用的一个函数上设置断点，来发现OEP。比如壳通常很早就调用了GetVersion以及GetCommandlineA函数，所以可以在这些函数调用时中断程序。<u>于GUI程序，GetModuleHandleA通常是第一个被调用的函数。</u></p>
<p>​    **6.**使用OllyDbg的Run Trace。Run Trace提供一些额外的断点选项，这使得能在较大范围的内存地址上 设置断点。很多加壳程序都会留下原始文件的.text节，OEP总是位于原始文件的该节中，一般是这个节中第一个被调用的指令，Run Trace可以让你设置这样的一个断点，无论什么时候执行.text节中的指令，此段点都能被触发。</p>
<h3 id="常见的壳"><a href="#常见的壳" class="headerlink" title="常见的壳"></a>常见的壳</h3><h4 id="UPX"><a href="#UPX" class="headerlink" title="UPX"></a>UPX</h4><p>​    这个壳开源免费并且易于使用，但是它不会对分析人员造成阻碍，所以很多恶意代码看似使用了UPX，但是实际上使用其他的壳或者修改过的UPX，这个时候可以根据前面描述的策略查找OEP，也可以通过OllyDump的Section Hop功能来查找OEP,或者直接仔细检查脱壳存根，直到找到尾部跳转为止，然后使用OllyDump转储文件，并重构导入表，成功脱壳。</p>
<h4 id="PECompact"><a href="#PECompact" class="headerlink" title="PECompact"></a>PECompact</h4><p>​    是一个商业的壳，它有一个插件框架，允许第三方工具集成进去，因此恶意程序进场使用该第三方工具，使得脱壳变得更困难。该加壳方法的脱壳与谦和相似，程序会产生几个异常，所以需要设置OD将异常传回程序（options-Debugging options-Exceptions）。可以通过查找尾部跳转失灵来查找OEP。</p>
<h4 id="ASPack"><a href="#ASPack" class="headerlink" title="ASPack"></a>ASPack</h4><p>​    使用了自我修改代码，让设置断点和分析它变得困难。在程序上设置断点，可以让程序立即终止，但是可以在栈地址行设置硬件断点完成手动脱壳，但是因为该壳很流行，所以网上有很多自动脱壳程序。</p>
<p>​    手动脱壳时，首先打开脱壳存根的代码，在代码开始部分，会看到一个PUSHA指令。确定用来存在寄存器的栈地址，然后在这些栈地址设置硬件断点，调用POPAD指令时，就会触发，然后会在离尾部跳转不远的地方找到OEP。</p>
<h4 id="Petite"><a href="#Petite" class="headerlink" title="Petite"></a>Petite</h4><p>​    使用了单步异常，但是可以像前面说的将异常传回程序，与ASPack相同，使用栈上的硬件断点来查找OEP是最佳策略。另外，它保持从原始导入表的每个库中至少导出一个函数，这在没有脱壳的情况下，很容易确定恶意程序使用了那些dll。</p>
<h4 id="WinUpack"><a href="#WinUpack" class="headerlink" title="WinUpack"></a>WinUpack</h4><p>​    一个有着GUI终端的壳，设计目的在于优化压缩而不是安全。该壳有一个命令行版本叫做UPack，有专门针对该两种壳的自动脱壳器。</p>
<p>​    识别尾部跳转有一个技巧，大多数脱壳存根都小于0x4000个字节，因此跳转的大小大于或者等于0x4000一般是跳转到OEP（针对书中例子），<u>脱壳存根通常有很多条件跳转并且在函数中间返回</u>，但是OEP周围的代码应该不会有这些不寻常的元素。</p>
<p>​    另一种针对Upack的策略是在函数GetModuleHandleA（GUI）或者函数GetCommandlineA(命令行)上设置断点。在windows中，这些函数在调用Oep不久后就会被调用，一旦触发断点就向后搜索代码查找OEP。</p>
<p>​    WinUpack有时会使用一个OD不能正确解析的头部，使其崩溃，这时候需要首先使用WinDbg.</p>
<h4 id="Themida"><a href="#Themida" class="headerlink" title="Themida"></a>Themida</h4><p>​    一个非常复杂的壳，包含阻止使用vmware、调试器，以及Procmon分析的功能。此外还有一个内核模块，运行在内核中的代码限制很少，而且分析程序通常运行在用户空间中，所以分析会受到很多限制。<u>自动化工具成功与否与加壳版本有关。</u></p>
<p>​    如果自动化工具无法脱壳，那么一种较好的方法是用procDump工具从内存中转储不在进行调试的进程。该工具的最大优点是在不停止进程或者调试进程的情况下，转储进程中的内存。这个过程并不能完全恢复可执行文件，但是能让我们在代码上运行strings工具并做一些分析。</p>
<h3 id="加壳DLL"><a href="#加壳DLL" class="headerlink" title="加壳DLL"></a>加壳DLL</h3><p>​    加壳Dll列出的开始地址是脱壳存根中的一个地址，位于DllMain中，而不是主函数中。DllMain函数在OC终端他运行之前被调用，中段发生的时候，脱壳存根已经运行，这将很难找到OEP。解决这个问题，我们可以打开PE文件，定位到IMAGE_FILE_HEADER节的特征标志域，将该节0x2000处的比特位从1修改为0，文件从dll变为exe.</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2021/10/14/paper/2020%E9%BB%91%E5%B8%BDDetecting%20Access%20Token%20Manipulate%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/14/paper/2020%E9%BB%91%E5%B8%BDDetecting%20Access%20Token%20Manipulate%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">2020黑帽Detecting Access Token Manipulate学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-14 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-14T00:00:00+08:00">2021-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-22 15:49:57" itemprop="dateModified" datetime="2021-12-22T15:49:57+08:00">2021-12-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/paper-reading/" itemprop="url" rel="index"><span itemprop="name">paper reading</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇文章主要目的是帮助安全从业人员理解：Windows下访问令牌是怎么工作的；攻击者是如何利用合法的Windows功能来横向移动并损害整个ActiveDirectory域信；他们检测和响应其环境中的访问令牌操作的能力。</p>
<h3 id="Windows-Security-Internals"><a href="#Windows-Security-Internals" class="headerlink" title="Windows Security Internals"></a>Windows Security Internals</h3><h4 id="Logon-Sessions-and-Access-Tokens"><a href="#Logon-Sessions-and-Access-Tokens" class="headerlink" title="Logon Sessions and Access Tokens"></a>Logon Sessions and Access Tokens</h4><p>简单的说，用户登陆到windows系统之后，不管该用户是本地登陆的，还是远程登陆，系统都会为这个用户分配一个新的**会话ID(SID)**。也就是说会话与用户的登录是相关连的，没有用户登录就不存在会话。因此，会话的含义是指用户登录之后的一种运行的环境。会话管理器(\Windows\System32\Smss.exe)是系统中第一个创建的用户态模式进程，负责完成执行体和内核的初始化工作的内核模式系统线程在最后阶段创建了实际的Smss进程。</p>
<p>会话(session)是由进程和其他的系统对象(比如窗口站、桌面和窗口)构成的，它们代表了一个用户的工作站登录会话。会话具体是由如下几个部分组成的：</p>
<p>   \1. 每个会话包含一个单独的win32k.sys</p>
<p>   \2. 专门的换页池区域</p>
<p>   \3. 私有windows子系统和登陆进程的拷贝</p>
<p>   \4. 系统空间中被映射的空间,被称为会话空间的区域</p>
<p>现在会话同进程做一个比较，发现他们之间有一些相似之处：</p>
<p>   \1. 都提供一个执行的环境</p>
<p>   \2. 都有一个私有空间</p>
<p>   进程是为了内部的执行的线程提供一个空间和环境，而会话则是为内部所有的进程提供一个执行的空间和环境。当用户登陆到系统中之后，用户下所有的进程都属于这个会话空间，在每个进程的PEB当中就有SessionID。Windows创建的第一个会话被称为会话0，是系统用户SYSTEM的会话通常称为会话0，服务就是运行在此会话中。而令牌就像是一个标识符，标识该账号的一切应用和操作。</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/desktop/SecAuthZ/access-tokens"><strong>访问令牌</strong></a>是用来描述进程或线程安全上下文的对象，令牌所包含的信息是与该 user 账户相关的进程或线程的身份和权限信息。当 user 登录时，系统通过将 user 输入的密码与储存在安全数据库中的密码进行对比。若密码正确，系统此时会为 user 生成一个访问令牌。之后，该 user 执行的每个进程都会拥有一个该访问令牌的副本。每个线程默认直接继承进程的token，线程还可以通过模拟，改变自己的token，让自己拥有别的用户的token。</p>
<p>令牌产生过程：使用凭据(用户密码)进行认证；</p>
<p>登录Session创建；</p>
<p>Windows返回用户sid和用户组sid；</p>
<p>LSA(Local Security Authority)创建一个Token；</p>
<p>依据该token创建进程、线程(如果CreaetProcess时自己指定了 Token, LSA会用该Token， 否则就继承父进程Token进行运行)</p>
<p>首先了解下令牌的四个模拟级别，分别是：Anonymous，Identification，Impersonation，Delegation</p>
<p>Anonymous：服务器无法模拟或识别客户端。</p>
<p>Identification：服务器可以获取客户端的身份和特权，但不能模拟客户端。</p>
<p>Impersonation：服务器可以在本地系统上模拟客户端的安全上下文。</p>
<p>Delegation：服务器可以在远程系统上模拟客户端的安全上下文。</p>
<p>所以当令牌具有Impersonation和Delegation级别的时候才可以进行模拟。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/wpsD52E.tmp.jpg" alt="img"><br>    言而总之，只要我们有SeAssignPrimaryToken或者SeImpersonate权限，就可以通过模拟Primary令牌来提升权限，而Primary令牌可以通过DuplicateTokenEx调用一个Impersonation令牌来转换。</p>
<p>所以一个模拟令牌的过程大概是：OpenProcess(获取目标进程上下文)-&gt;OpenProcessToken(获得进程访问令牌的句柄)–&gt;DuplicateTokenEx(创建一个主/模拟令牌)–&gt;CreateProcessWithTokenW(创建进程)</p>
<h4 id="How-Attackers-Abuse-Access-Token"><a href="#How-Attackers-Abuse-Access-Token" class="headerlink" title="How Attackers Abuse Access Token"></a>How Attackers Abuse Access Token</h4><p>攻击者可以使用内置的Windows API函数从现有进程复制访问令牌，这就是所谓的令牌窃取。然后可以将这些令牌应用于现有进程（即Token Impersonation/Theft）或用于生成新进程（即Create Process with Token）。攻击者必须已经处于特权用户上下文（即管理员）中才能窃取令牌。然而，攻击者通常使用令牌窃取将其安全上下文从管理员级别提升到系统级别。然后，如果帐户在远程系统上具有适当的权限，则攻击者可以使用令牌向远程系统进行身份验证，作为该令牌的帐户。</p>
<p>在ATT&amp;CK框架中，对于令牌操作有五种技术介绍：</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/wpsD53E.tmp.jpg" alt="img"> </p>
<h4 id="Token-Impersonation-Theft"><a href="#Token-Impersonation-Theft" class="headerlink" title="Token Impersonation/Theft"></a>Token Impersonation/Theft</h4><p>攻击者可以使用DuplicateToken（Ex）创建一个新的访问令牌来复制现有令牌。然后，该令牌可与ImpersonalLoggedOnUser一起使用，以允许调用线程模拟登录用户的安全上下文，或与SetThreadToken一起将模拟令牌分配给线程。</p>
<p><strong>检测：</strong></p>
<p>如果攻击者使用标准命令行shell，分析人员可以通过审核命令行活动来检测令牌操纵。具体来说，分析人员应该寻找runas命令的使用。默认情况下，Windows中未启用详细的命令行日志记录。</p>
<p>分析人员还可以监视Windows API（如DuplicateToken（Ex）、ImpersonalLoggeDonUser和SetThreadToken）的使用情况，并将活动与其他可疑行为关联起来，以减少由于用户和管理员正常的良性使用而导致的误报。 </p>
<h4 id="Create-Process-with-Token"><a href="#Create-Process-with-Token" class="headerlink" title="Create Process with Token"></a>Create Process with Token</h4><p>攻击者可能会使用重复的令牌创建一个新进程，以升级权限并绕过访问控制。攻击者可以使用DuplicateToken（Ex）复制所需的访问令牌，并将其与CreateProcessWithTokenW一起使用，以创建在模拟用户的安全上下文下运行的新进程。这对于在不同用户的安全上下文下创建新进程非常有用。</p>
<p><strong>检测：</strong></p>
<p>如果攻击者使用标准命令行shell，同上。</p>
<p>如果攻击者使用直接调用Windows令牌API的有效负载，分析人员只能通过仔细分析用户网络活动、检查正在运行的进程以及与其他端点和网络行为的关联来检测令牌操纵。 </p>
<p>分析人员还可以监视Windows API，同上。</p>
<h4 id="Make-and-Impersonate-Token"><a href="#Make-and-Impersonate-Token" class="headerlink" title="Make and Impersonate Token"></a>Make and Impersonate Token</h4><p> 攻击者可以制作和模拟令牌以提升权限并绕过访问控制。如果攻击者拥有用户名和密码，但用户未登录系统，则攻击者可以使用LogonUser功能为用户创建登录会话。该函数将返回新会话的访问令牌的副本，攻击者可以使用SetThreadToken将令牌分配给线程。</p>
<p><strong>检测：</strong></p>
<p>同上</p>
<h4 id="Parent-PID-Spoofing"><a href="#Parent-PID-Spoofing" class="headerlink" title="Parent PID Spoofing"></a>Parent PID Spoofing</h4><p>攻击者可以欺骗新进程的父进程标识符（PPID），以逃避进程监视防御或提升权限。除非明确指定，否则新进程通常直接从其父进程或调用进程派生。显式分配新进程的PPID的一种方法是通过CreateProcess API调用，该调用支持定义要使用的PPID的参数。此功能由Windows功能（如用户帐户控制（UAC））使用，以便在系统生成请求的提升进程后正确设置PPID（通常通过svchost.exe或approve.exe）而不是当前用户上下文。</p>
<p>攻击者可能会利用这些机制来逃避防御，例如阻止直接从Office文档生成的进程，以及针对异常/潜在恶意父子进程关系的分析，例如将PowerShell/Rundll32的PPID欺骗为explorer.exe，而不是将Office文档作为Spearphishing Attachment的一部分。此欺骗可以通过Visual Basic在恶意Office文档或任何可以执行本机API的代码中执行。</p>
<p>显式分配PPID还可以启用提升的权限，赋予父进程适当的访问权限。例如，特权用户上下文（即管理员）中的攻击者可能会生成一个新进程，并将父进程分配为作为系统运行的进程（如lsass.exe），导致新进程通过继承的访问令牌提升。</p>
<p><strong>检测：</strong></p>
<p>查找存储PPID信息的各个字段之间的不一致性，例如通过Windows事件跟踪（ETW）收集的数据中的EventHeader ProcessId、Windows事件日志中的创建者进程ID/名称以及ProcessId和ParentProcessID（也由ETW和其他实用程序（如任务管理器和Process Explorer）生成）。ETW提供的EventHeader ProcessId标识实际的父进程。</p>
<p>监视和分析对CreateProcess/CreateProcessA的API调用，特别是来自用户/潜在恶意进程的API调用，并使用显式分配PPID的参数（例如：进程创建标志0x8XXX，表示正在使用扩展启动信息创建进程）。恶意使用CreateProcess/CreateProcessA也可能通过调用UpdateProctThreadAttribute进行，这可能是更新进程创建属性所必需的。这可能会从正常UAC提升行为中产生误报，因此如果可能，请与系统基线/对正常系统活动的理解进行比较。</p>
<h4 id="SID-History-Injection"><a href="#SID-History-Injection" class="headerlink" title="SID-History Injection"></a>SID-History Injection</h4><p>对手可以使用SID历史记录注入来升级权限和绕过访问控制。Windows安全标识符（SID）是标识用户或组帐户的唯一值。Windows security在安全描述符和访问令牌中都使用SID。帐户可以在SID-History Active Directory属性中保存其他SID，从而允许在域之间进行可互操作的帐户迁移（例如，SID-History中的所有值都包含在访问令牌中）。</p>
<p>使用域管理员（或同等）权限，可以将获取的或已知的SID值插入到SID历史记录中，以启用对任意用户/组（如企业管理员）的模拟。此操作可能会导致通过横向移动技术（如远程服务、SMB/Windows管理员共享或Windows远程管理）提升对本地资源的访问和/或访问无法访问的域。</p>
<p><strong>检测：</strong></p>
<p>使用PowerShell Get-ADUser 命令行工具检查用户SID历史记录属性中的数据，尤其是具有来自同一域的SID历史记录值的用户。还可以监视域控制器上的帐户管理事件，以查看SID历史记录的成功更改和失败更改。</p>
<p>监视对DsAddSidHistory函数的Windows API调用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2021/10/11/paper/2020%E9%BB%91%E5%B8%BDDemystifying%20Modern%20Windows%20Rootkits%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/11/paper/2020%E9%BB%91%E5%B8%BDDemystifying%20Modern%20Windows%20Rootkits%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">2020黑帽Demystifying Modern Windows Rootkits学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-11 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-11T00:00:00+08:00">2021-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-22 15:57:00" itemprop="dateModified" datetime="2021-12-22T15:57:00+08:00">2021-12-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/paper-reading/" itemprop="url" rel="index"><span itemprop="name">paper reading</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>1.加载一个rootkit

2.与rootkit通信

3.采用合法的网络通信

4.作者写的一个示例rootkit以及其背后的设计选择

5.执行来自内核的命令

6.掩盖你的rootkit的文件系统踪迹的技巧
</code></pre>
<p>Rootkit是一种特殊的恶意软件，它的功能是在安装目标上隐藏自身及指定的文件、进程和网络连接等信息，比较多见到的是Rootkit一般都和木马、后门等其他恶意程序结合使用。Rootkit通过加载特殊的驱动，修改系统内核，进而达到隐藏信息的目的。</p>
<h3 id="Loading-a-Rootkit"><a href="#Loading-a-Rootkit" class="headerlink" title="Loading a Rootkit"></a>Loading a Rootkit</h3><p>1.利用合法的驱动。有很多脆弱的驱动，利用逆向知识，找到一个驱动的0day漏洞是很容易的。并且只需要几句原语即可提升权限，找到一个脆弱的驱动相对来说是简单的，因为兼容性的问题很难被检测。</p>
<p>缺点：跨操作系统版本的兼容性的主要问题取决于所拥有的原语；最有可能的是稳定性问题；最后一件事是你的恶意软件使得受害者蓝屏。</p>
<p>2.买证书。买一个合法的证书就没有稳定性的问题了，但是可能会揭露自己的身份以及会被拉进黑名单。</p>
<p>3.利用已经泄露的证书。这种方式相比购买证书来说更安全，但是在未来可能被检测，并且根据证书发布时间是有操作系统版本限制的。</p>
<h3 id="Communicating-with-a-Rootkit"><a href="#Communicating-with-a-Rootkit" class="headerlink" title="Communicating with a Rootkit"></a>Communicating with a Rootkit</h3><p>1.发给C2服务器。防火墙可以阻止或标记对未知/可疑IP地址或端口的传出请求，先进的网络检查可以捕捉到一些试图“融入噪音”的外渗技术。</p>
<p>2.打开一个端口。一些恶意软件通过C2直接连接到受害者主机来控制它。这样设置相对简单。但是可能会被防火墙发现，并且很难融入噪声。</p>
<p>3.应用程序Hooking技术。更高级的恶意软件可能会选择hook一个特定的应用程序的通信作为一个通信通道。这样就很难被检测，特别是如果用的是合法的协议，但是这样不是特别灵活，机器可能没有暴露出该服务。</p>
<p>我们想要的是有限的检测向量，各种环境下的灵活性，假设受害主机会有一些已经揭露出来的服务，入站和出站访问可能被监控。那么第三种方法非常符合我们的需求，除了灵活性。现在要考虑的是如何不依赖一个应用程序。</p>
<p>如果不直接hook一个应用程序，那么我们hook像wireshark这样的工具的网络通信；在恶意数据包中放置一个特殊的指示器（一个”magic”常数）；将这些恶意数据包发送到受害者机器上的合法端口；搜索这个常数的数据包，以将数据传递给我们的恶意软件.</p>
<h3 id="Hooking-the-User-Mode-Network-Stack"><a href="#Hooking-the-User-Mode-Network-Stack" class="headerlink" title="Hooking the User-Mode Network Stack"></a>Hooking the User-Mode Network Stack</h3><h4 id="hook-Windows-Winsock-driver"><a href="#hook-Windows-Winsock-driver" class="headerlink" title="hook Windows Winsock driver"></a>hook Windows Winsock driver</h4><p>在用户模式下windows上的许多服务都可以被发现，但是如何全面地获取这些流量是一个问题。与winsock相关的网络是由Afd.sys处理的，mswsock.dll用NtDeviceIoControlFiles实现与Afd.sys驱动的通信。逆向分析在mswsock.dll中的一些函数显示大量的通信是由IOCTLs完成的，如果我们可以拦截到这些请求，我们可以窥探所收到的数据。</p>
<p>\1. 在拦截之前要知道Irps是怎么走的，当对一个设备调用文件句柄上的NtDeviceIoControlFile函数时，内核如何确定要调用什么函数？</p>
<p>首先通过IoGetRelatedDeviceObject检索与Afd驱动程序相关联的设备(检索FILE_OBJECT结构中的DeviceObject成员)，然后判断驱动是否支持FastIo（在进行基于IRP 为基础的接口调用前, IO MANAGER 会尝试使用FAST IO 接口来加速各种IO 操作），如果支持那么就调用DriverObject-&gt;FastIoDispatch，如果不支持，那么就分配并填写Irp，然后调用IoCallDriver来发送Irp，对于IoCallDriver，内核将通过在DRIVER_OBJECT结构的MajorFunction数组中查找Irp内部指定的“Major function Code”来确定调用哪个函数</p>
<p>\2. 这里有拦截Irps的两种常见方法。替换掉驱动对象中你想hook的主函数；直接对调度处理程序执行代码hook。</p>
<p>\3. 要选择hooking最好的方法，要考虑的问题（可能有的检测向量有多少种，方法如何可用，检测这种方法昂贵吗）</p>
<p><strong>Hook驱动对象</strong>：memory artifacts；对于稳定性，通过用互锁交换替换单个函数，这种方法应该是稳定的。对于兼容性，驱动程序对象有很好的文档记录，并且易于找到；但是检测起很便宜，所有的防病毒软件都需要枚举已加载的驱动程序，并检查主要功能是否在驱动程序的范围内。</p>
<p><strong>Hook驱动程序的调度函数</strong>：memory artifacts；除非函数被导出，否则需要自己找到函数，由于补丁保护程序，并不是所有的驱动程序都与此方法兼容，HVCI不兼容的；检测也比较便宜。</p>
<p><strong>Hook文件对象：</strong>没有被文档化；稳定；检测成本相对昂贵，反病毒软件必须复制我们的连接过程，并枚举文件对象，以确定设备/驱动程序对象是否被交换。。</p>
<p><strong>Hook文件对象</strong></p>
<pre><code>1.创建我们自己的设备对象和驱动程序对象。 

2.修补驱动程序对象的副本。 

3.用我们自己的设备替换我们文件对象的DeviceObject指针
</code></pre>
<p><strong>首先</strong>我们需要获得Afd设备的文件对象，我们可以通过<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/sysinfo/zwquerysysteminformation">ZwQuerySystemInformation</a>函数，特别是使用SystemHandleInformation信息类来查询系统上的每个打开句柄。此信息类将为每个句柄返回以下结构：</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/wps2D3A.tmp.jpg" alt="img"> </p>
<p>有了这些信息我们需要判断句柄是否是Afd设备的。首先通过比较ObjectTypeNumber成员与已知的文件对象类型索引来判断该句柄是否是一个文件对象的，然后我们再将FILE_OBJECT结构的DeviceObject成员与一致的Afd设备比较。</p>
<p><strong>然后</strong>我们需要创建我们自己的假的驱动或者设备对象。Windows内核使用ObCreateObject函数来创建对象，内核大概是为了允许其他Windows驱动创建他们自己的对象，导出了该函数。</p>
<p>最后我们需要hook我们的假的驱动对象，可以用前面提到过的方法，将DRIVER_OBJECT结构中的MajorFunctions数组部分替换为我们的hook函数，（要注意我们要hook的是我们自己创建的驱动对象，而不是真正的驱动对象），</p>
<p>最后一步就是将FILE_OBJECT的DeviceObject成员替换成我们自己的设备。</p>
<p>现在文件对象被Hook了，对IoGetRelatedDeviceObject的任何调用都将返回我们的假设备，IoCallDriver将使用该设备调用我们的补丁MajorFunctions数组。</p>
<p>剩下的工作：检查我们是都正在hook被调用的MajorFunction，如果是，则调用为该主函数传递原始设备对象和原始调度函数的hook函数；确保当MajorFunction是IRP_MJ_CLEANUP时保存了原始的DeviceObject。</p>
<h3 id="How-the-Spectre-Rootkit-Abuses-the-User-Mode-Network-Stack"><a href="#How-the-Spectre-Rootkit-Abuses-the-User-Mode-Network-Stack" class="headerlink" title="How the Spectre Rootkit Abuses the User-Mode Network Stack"></a>How the Spectre Rootkit Abuses the User-Mode Network Stack</h3><h4 id="Abusing-the-Network"><a href="#Abusing-the-Network" class="headerlink" title="Abusing the Network"></a>Abusing the Network</h4><p>有了前一步的hook，现在我们已经可以拦截Afd驱动的Irps了。并且我们可以拦截所有用户模式的网络流量，通过任何套接字发送和接收我们自己的数据。</p>
<h4 id="Packet-Structure"><a href="#Packet-Structure" class="headerlink" title="Packet Structure"></a>Packet Structure</h4><p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/wps2D4A.tmp.jpg" alt="img"> </p>
<h4 id="Processing"><a href="#Processing" class="headerlink" title="Processing"></a>Processing</h4><p>收到数据包后先对数据包的magic constant部分进行判断。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/wps2D4B.tmp.jpg" alt="img"> </p>
<p>在发出包之前，我们需要创建一个完整的数据包</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/wps2D4C.tmp.jpg" alt="img"> </p>
<h4 id="Packet-Handlers"><a href="#Packet-Handlers" class="headerlink" title="Packet Handlers"></a>Packet Handlers</h4><p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/wps2D4D.tmp.jpg" alt="img"> </p>
<p>其他数据包处理程序继承这个基类。在上面的类中需要注意的两个关键问题是，调度器不仅会在处理程序的构造函数中传递指向自身的指针，而且实际的数据包将被传递给数据包处理程序的ProcessPacket函数。</p>
<p>一旦数据包被填充完，process handler会采取以下步骤</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/wps2D4E.tmp.jpg" alt="img"> </p>
<p>通过将一个指针传递给相关的包处理程序，该包处理程序可以递归地处理一个新的包。示例XorPacketHandler：</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/wps2D4F.tmp.jpg" alt="img"> </p>
<p>此XOR_PACKET实际上并不执行恶意操作。相反，它充当了一个封装的数据包。当Xor软件包处理程序收到一个数据包时，它将使用XorKey消除XorContent；递归地将XorContent分派为一个新的数据包。</p>
<p>该模型允许您创建无限的封装层。</p>
<h4 id="Executing-the-Commands"><a href="#Executing-the-Commands" class="headerlink" title="Executing the Commands"></a>Executing the Commands</h4><p>首先我们需要了解从用户模式上下文执行命令的过程</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/wps2D50.tmp.jpg" alt="img"> </p>
<p>关于内核模式，让我们从创建获取输出所需的管道开始，下面是创建管道在后台所做的事情。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/wps2D51.tmp.jpg" alt="img"> </p>
<p>现在我们有了管道，我们需要创建实际的流程。我们将使用ZwCreateUserProcess，因为这是kernelbase.dll使用自己来创建进程的方法。</p>
<p>我们需要从从进程的属性列表开始，我们必须设置的最重要的属性是PsAttributeImageName。这将指定新进程的映像文件名。</p>
<p>接下来我们需要为进程填充RTL_USER_PROCESS_PARAMETERS结构，主要填充参数有窗口标志和输出到我们的管道的句柄，当前目录、命令行参数、进程映像路径和默认的桌面名称。</p>
<p>然后我们就可以用ZwCreateUserProcess开启进程了，一旦进程退出，类似于我们在用户模式下所做的事情，我们可以调用ZwReadFile来从未命名的管道中读取输出。</p>
<h3 id="Hiding-a-Rootkit"><a href="#Hiding-a-Rootkit" class="headerlink" title="Hiding a Rootkit"></a>Hiding a Rootkit</h3><h4 id="MiniFilter"><a href="#MiniFilter" class="headerlink" title="MiniFilter"></a>MiniFilter</h4><p>微过滤驱动通过过滤管理驱动进行注册来实现拦截特定文件I/O.</p>
<p>Minifilter可以用于掩盖我们的根工具包在文件系统上的存在。它可以将某一文件的所有文件访问权限定向到另一个文件。我们可以使用此功能将对驱动程序文件的访问重定向到另一个合法的驱动程序。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/wps2D52.tmp.jpg" alt="img"> </p>
<p>利用MiniFilter最简单的方法就是自己成为一个MiniFilter,这个方法的检测向量主要是注册表和内存痕迹，不用担心稳定性和实用性，但是检测比较便宜，除了注册表工件之外，注册为MiniFillter的驱动程序也可以通过FltEnumerateFilters等API轻松枚举。</p>
<p>第二个方法是Hook一个MIniFilter，有三种方式，第一种是代码Hook现有的过滤器的回调；第二种是在受害驱动程序使用FLT_REFISTRATION结构体获得你自己的回调之前重写该结构；第三种是DKOM（直接<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1">内核对象</a>操作技术）一个现有的过滤器实例，并用您的替换原始回调。第一种方式虽然简单，但是有很多缺点。对于第三种方式，这是一种半文档化的方法，可以通过FltEnumerateFilters和FltEnumerateInstances这两个API枚举过滤器和实例，为某个操作调用的函数在FLT_INSTANCE结构中的CallBackNodes数组中指定。这种方式会有内存痕迹，对于稳定性来说，虽然获得一个FLT_INSTANCE结构是文档化的，但是FLT_INSTANCE结构它自己不是文档化的，并且检测并不昂贵，反病毒软件需要偶尔枚举注册的过滤器在CallBackNodes数组中的钩子及其实例。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/paper/wps2D53.tmp.jpg" alt="img"> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://erkeai.github.io/2021/10/11/reverse/Maze/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
      <meta itemprop="name" content="ZouFeIYu">
      <meta itemprop="description" content="reading, coding, travelling">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hazel'blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/11/reverse/Maze/" class="post-title-link" itemprop="url">buuctf_Maze</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-11 00:00:00" itemprop="dateCreated datePublished" datetime="2021-10-11T00:00:00+08:00">2021-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-22 10:23:35" itemprop="dateModified" datetime="2021-12-22T10:23:35+08:00">2021-12-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/buuctf/" itemprop="url" rel="index"><span itemprop="name">buuctf</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>558</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Maze"><a href="#Maze" class="headerlink" title="Maze"></a>Maze</h4><p>1.首先PEid查壳，查到是UPX的壳</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse5/image-20211011192051606.png" alt="image-20211011192051606"></p>
<p>2.UPX脱壳，之前在网上找脱壳工具，但是其实UPX是开源的，在github上下载后，在cmd下执行upx -d yourfile.exe就可以脱壳，拖进IDA是下面的样子，发现f5不能查看伪代码，再看左边的函数栏，没有main函数。</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse5/image-20211011195316028.png" alt="image-20211011195316028"></p>
<p>网上搜索后发现是加了<strong>花程序</strong></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse5/image-20211011195716680.png" alt="image-20211011195716680"></p>
<p>查看上图的jnz跳转到了下一行代码。相当于没有跳转，接下来的call调用的一个不是地址的地址，网上的方法是将jnz指令nop掉（<u>nop指令也就是控指令，执行的时候不做任何事，有时候可用于短接某些触点或用nop指令将不要的指令覆盖掉</u>）</p>
<p>3.先将jnz指令nop掉（Edit-&gt;Patch program-&gt;Assemble），因为call后面很有可能事有用的数据，所以用d先转换为数据,jnz后面的也是花指令，所以应该把该数据包的高字节部分也nop掉，但是IDA总是不成功，所以用OD,修改后右键复制到可执行文件，然后右键保存</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse5/image-20211011201009496.png" alt="image-20211011201009496"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse5/image-20211011203812041.png" alt="image-20211011203812041"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse5/image-20211011203847749.png" alt="image-20211011203847749"></p>
<p>4.拖进IDA反汇编,这个代码逻辑比较简单，wsad其实就是玩游戏的上下左右，</p>
<p>初始dword_408078=7,dword_40807c = 0,需要经过十四次移动修改两个变量为5和-4，按照迷宫题目的经验应该有地图或者字符。提取出来自己排列一下</p>
<p>flag{ssaaasaassdddw}</p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse5/image-20211012094241147.png" alt="image-20211012094241147"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse5/image-20211012154856963.png" alt="image-20211012154856963"></p>
<p><img src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/typora/reverse5/image-20211012154814391.png" alt="image-20211012154814391"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZouFeIYu"
      src="https://blog-1257910714.cos.ap-chengdu.myqcloud.com/images%2FhdImg_f7fb2f283d6fd693d9c2444fb73eaf4715853190130.jpg">
  <p class="site-author-name" itemprop="name">ZouFeIYu</p>
  <div class="site-description" itemprop="description">reading, coding, travelling</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">58</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/erkeai" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;erkeai" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:563783592@qq.com" title="E-Mail → mailto:563783592@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-feather"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZouFeIYu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">149k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:16</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
